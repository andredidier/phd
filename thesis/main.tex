\documentclass[12pt,openright,twoside,a4paper,oldfontcommands,english,brazil,draft]{abntex2}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{makeidx}
\usepackage{colortbl}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tabularx}
\usepackage{microtype}
\usepackage{bibentry}
%\usepackage{subfigure}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{booktabs}
\usepackage{pdfpages}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{verbatim}
\usepackage{environ}
\usepackage{acro}
\usepackage{longtable}
\usepackage{isabelle,isabellesym}
\usepackage{lastpage}
\usepackage[alf]{abntex2cite}
%Erro: \textquotesingle:
\usepackage{textcomp}
%Quantas vezes e em quais páginas a referência foi citada
%\usepackage[english,hyperpageref]{backref}
%\usepackage[colorinlistoftodos,prependcaption,textsize=footnotesize,textwidth=4cm]{todonotes} % NOTAS
\usepackage[draft]{fixme}
\usepackage{soul}

\usepackage{indentfirst}
\usepackage{microtype}      % para melhorias de justificação

%%%%%%%%%%%%%%%%% NOTAS
%TODONOTES
%\newcommand{\notename}{Comment}%
%
%\addto\captionsbrazil{%
%  %\renewcommand{\chaptername}{Tema}%
%  \renewcommand{\contentsname}{Temas}%
%  \renewcommand{\notename}{Comentário}%
%}
%
%\newcounter{note}
%\newcommand{\note}[2][]{%
%  % initials of the author (optional) + note in the margin
%  \refstepcounter{note}%
%  {%
%    %\setstretch{0.7}% spacing
%    \todo[color={red!100!green!33},size=\small,inline]{%
%    \textbf{\notename{} [\uppercase{#1}\thenote]:}~#2}%
%  }
%}
%\newcommand{\texthl}[1]{#1}
%\newcommand{\hlfix}[2]{\texthl{#1}\todo{#2}\xspace}

%SIMPLES
%\makeatletter
%\newcommand{\texthl}[1]{#1}
%\newcommand{\todo}[1]{\@latex@warning{TODO #1}}
%\newcommand{\hlfix}[2]{\texthl{#1}\todo{#2}\xspace}
%\newcommand{\listoftodos}[1]{}
%\makeatother

%FIXME
\fxsetup{layout={footnote}}
%\fxuselayouts{pdfnote,margin}
%\fxusetargetlayout{signature}
\FXRegisterAuthor{ad}{alrd}{AD}
\FXRegisterAuthor{am}{acm}{AM}
%\fxuselayouts{pdfsignote,margin}
\newcommand{\todo}[1]{\adnote{#1}}
\newcommand{\note}[2][]{\adnote{#2}}
\newcommand{\listoftodos}[1]{\listoffixmes}
%%%%%%%%%%%%%%%%% NOTAS

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

\acsetup{%
  hyperref=true,
  index=true,
  index-cmd={\index},
  list-type=table,
  list-style=longtable,
  page-ref=plain,
  pages=all%
}

\captionsetup[table]{position=top,justification=centering,width=.85\textwidth,labelfont=bf,font=small}
\captionsetup[lstlisting]{position=top,justification=centering,width=.85\textwidth,labelfont=bf,font=small}
\captionsetup[figure]{position=bottom,justification=centering,width=.85\textwidth,labelfont=bf,font=small}
\usepackage[capitalise]{cleveref}

\addto\captionsenglish{% ingles
  %% adjusts names from abnTeX2
  \renewcommand{\folhaderostoname}{Title page}
  \renewcommand{\epigraphname}{Epigraph}
  \renewcommand{\dedicatorianame}{Dedication}
  \renewcommand{\errataname}{Errata sheet}
  \renewcommand{\agradecimentosname}{Acknowledgements}
  \renewcommand{\resumoname}{Abstract}
  \renewcommand{\anexoname}{ANNEX}
  \renewcommand{\anexosname}{Annex}
  \renewcommand{\apendicename}{APPENDIX}
  \renewcommand{\apendicesname}{Appendix}
  \renewcommand{\orientadorname}{Supervisor:}
  \renewcommand{\coorientadorname}{Co-supervisor:}
  \renewcommand{\folhadeaprovacaoname}{Approval}
  \renewcommand{\resumoname}{Abstract}
  \renewcommand{\listadesiglasname}{List of abbreviations and acronyms}
  \renewcommand{\listadesimbolosname}{List of symbols}
  \renewcommand{\fontename}{Source}
  \renewcommand{\notaname}{Note}
  %% adjusts names used by \autoref
  \renewcommand{\pageautorefname}{page}
  \renewcommand{\sectionautorefname}{section}
  \renewcommand{\subsectionautorefname}{subsection}
  \renewcommand{\subsubsectionautorefname}{subsubsection}
  \renewcommand{\paragraphautorefname}{subsubsubsection}
}

\input{capa}

%% Change the following pdf author attribute name to your name.
\autor{André Luís Ribeiro Didier}
\titulo{An Algebra of Temporal Faults}
\data{March 2016}
\instituicao{%
Federal University of Pernambuco%
\par
Center of Informatics%
\par
Graduate in Computer Science%
}
\local{Recife, PE}
\tipotrabalho{Ph.D. Thesis}
\orientador{Alexandre Cabral Mota}
\coorientador{Alexander Romanovsky}
\preambulo{
A Ph.D. Thesis presented to the Center for Informatics of Federal University of Pernambuco in partial fulfillment of the requirements for the degree of Philosophy Doctor in Computer Science.}

\makeatletter
\hypersetup{%
  pdftitle={\@title},
  pdfauthor={\@author},
  pdfsubject={\imprimirpreambulo},
  %pdfkeywords={PALAVRAS}{CHAVE}{EM}{PORTUGUES},
  pdfcreator={LaTeX with abnTeX2},
  colorlinks=true,
  linkcolor=blue,
  citecolor=blue,
  urlcolor=blue
}
\makeatother


% Tamanho do parágrafo
\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}
\frenchspacing


%\address{Recife-PE}

%\universitypt{Universidade Federal de Pernambuco}
%\universityen{Federal University of Pernambuco}

%\departmentpt{Centro de Informática}
%\departmenten{Center for Informatics}

%\programpt{Pós-graduação em Ciência da Computação}
%\programen{Graduate in Computer Science}

%\majorfieldpt{Ciência da Computação}
%\majorfielden{Computer Science}

%\title{\thesistitle}

%\date{2017}

%\author{\thesisauthor}
%\adviser{Alexandre Cabral Mota}
%\coadviser{Alexander Romanovsky}

%\addbibresource{references-jabref.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Macros (defines your own macros here, if needed)
%\def\x{\checkmark}

\newtheorem{Def}{Definition}[chapter]
\theoremstyle{theo}
\newtheorem{Axi}{Axiom}[chapter]
\newtheorem{Conj}{Conjecture}[chapter]
\newtheorem{Lem}{Lemma}[chapter]
\newtheorem{Theo}{Theorem}[chapter]
\newtheorem{Prop}{Proposition}[chapter]
\newtheorem{Cor}{Corollary}[chapter]

\hyphenation{EMBRAER}
\newcommand{\includegraphicsaspectratio}[2][1]{%
  \includegraphics[width=#1\textwidth,height=#1\textheight,keepaspectratio]{#2}%
}

\newcommand{\EMBRAER}{EMBRAER\xspace}
\newcommand{\matlab}{\textsf{Matlab}\xspace}

\input{acronyms}
%\makeatletter
%\renewcommand{\listofacronyms}{%
%  \acresetall
%  \pagestyle{empty}
%  \if\@language1
%    \printacronyms[name={\acronymname},heading=chapter*]
%    \thispagestyle{empty}
%  \else\if\@language0
%    \printacronyms[name={\acronimoname},heading=chapter*]
%    \thispagestyle{empty}
%  \fi\fi
%  \acresetall
%}
%\makeatother

%USED IN SOME REFS, AS IN CBL+2014.
\newcommand\mathplus{+}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT
%\Crefname{chapter}{Chapter}{Chapters}
%\Crefname{section}{Chapter}{Chapters}
\Crefname{Lem}{Lemma}{Lemmas}
\Crefname{Def}{Definition}{Definitions}
\Crefname{figure}{Figure}{Figures}
%\crefname{Def}{Def.}{Defs.}

\newcommand{\textsim}[1]{$#1$}
\newenvironment{snippetcspm}[1][2]
{
\ifthenelse{\equal{#1}{0}}
    {\tiny}
    {
    \ifthenelse{\equal{#1}{1}}
        {\scriptsize}
        {
        \ifthenelse{\equal{#1}{2}}
            {\footnotesize}
            {\small}
        }
    }
%\begin{samepage}
\verbatim
}
{
\endverbatim
%\end{samepage}
}
\newcommand{\simulink}{Simulink\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%References
\def\FThandbook{Fault Tree Handbook~\cite{VGR+1981}\index{Fault Tree!Handbook}%
  \gdef\FThandbook{Fault Tree Handbook\index{Fault Tree!Handbook}\xspace}%
  \xspace}
\def\pandora{Pandora\footnote{Pandora stands for: P-AND-ORA, which translates to Priority AND, Time.}%
  \gdef\pandora{Pandora\xspace}%
  \xspace}
\def\theftanalyser{%
  the Fault Tree Analyser\footnote{\url{http://www.fault-tree-analysis-software.com}, accessed 2/feb/2016}%
  %~\cite{ALDSoftwareFTAnalyser}%
  \gdef\theftanalyser{the Fault Tree Analyser\xspace}%
}
%\AtEveryBibitem{%
%  \ifentrytype{online}{%
%    \clearfield{labelyear}%
%  }{%
%  }%
%}
\def\ortext{OR ($\lor$)%
  \gdef\ortext{OR\xspace}%
  \xspace
}
\def\andtext{AND ($\land$)%
  \gdef\andtext{AND\xspace}%
  \xspace
}
\def\pandtext{Priority-AND (PAND, $\pand$)%
  \gdef\pandtext{PAND\xspace}%
  \xspace
}
\def\portext{Priority-OR (POR, $\por$)%
  \gdef\portext{POR\xspace}%
  \xspace
}
\def\sandtext{Simultaneous-AND (SAND, $\sand$)%
  \gdef\sandtext{SAND\xspace}%
  \xspace
}
\def\nottext{NOT ($\lnot$)%
  \gdef\nottext{NOT\xspace}%
  \xspace
}
\def\nibeforetext{non-inclusive-before (NIBefore, $\nibefore$)%
  \gdef\nibeforetext{NI-Before\xspace}%
  \xspace
}
\def\ibeforetext{inclusive-before (IBefore, $\ibefore$)%
  \gdef\ibeforetext{IBefore\xspace}%
  \xspace
}
\def\simultaneoustext{simultaneous ($\simultaneous$)%
  \gdef\simultaneoustext{simultaneous\xspace}%
  \xspace
}
\def\xbeforetext{exclusive-before (XBefore, $\xbefore$)%
  \gdef\xbeforetext{XBefore\xspace}%
  \xspace
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATH
\newcommand{\sliceright}[2]{\ensuremath #1_{\left[..#2\right]}}
\newcommand{\sliceleft}[2]{\ensuremath #1_{\left[#2..\right]}}
\newcommand{\slice}[3]{\ensuremath #1_{\left[#2..#3\right]}}
\def\varop{\ensuremath\operatorname{\mathbf{var}}}
\newcommand{\var}[1]{\ensuremath\varop #1}
\def\xbeforeop{\ensuremath\rightarrow}
\newcommand{\xbefore}[2]{\ensuremath #1 \xbeforeop #2 }
\newcommand{\xbeforedef}[2]{\ensuremath \left\{ zs | \exists i \bullet \sliceright{zs}{i} \land \sliceleft{zs}{i}  \right\}}
\def\Tempotext{Tempo\xspace}
\def\tempotext{tempo\xspace}
\def\tempoop{\ensuremath\operatorname{\mathbf{tempo}}}
\newcommand{\tempo}[2][1-4]{\ensuremath\tempoop_{#1} #2}
\def\independenteventsop{\ensuremath\operatorname{\triangleleft\triangleright}}
\newcommand{\independentevents}[2]{\ensuremath #1 \independenteventsop #2}
\def\True{\ensuremath\operatorname{UNIV}}
\def\False{\ensuremath\operatorname{\left\{\right\}}}
\def\distinctop{\ensuremath\operatorname{distinct}}
\newcommand{\distinct}[1]{\ensuremath\distinctop #1}
\newcommand{\emptylist}{\ensuremath[]}
\newcommand{\nth}[2]{\ensuremath #1_{#2}}
\newcommand{\length}[1]{\ensuremath\left|#1\right|}
\newcommand{\fact}[1]{\ensuremath #1!}
\newcommand{\append}[2]{\ensuremath #1 \operatorname{\mathbf{@}} #2}
\def\listsetop{\ensuremath\operatorname{\mathbf{set}}}
\newcommand{\listset}[1]{\ensuremath\listsetop #1}
\def\dropop{\ensuremath\operatorname{drop}}
\newcommand{\drop}[2]{\ensuremath\dropop {#2} {#1}}
\def\takeop{\ensuremath\operatorname{take}}
\newcommand{\take}[2]{\ensuremath\takeop {#2} {#1}}
%\def\maxop{\ensuremath\operatorname{max}}
%\newcommand{\max}[1]{\ensuremath\maxop #1}
\def\algebraset{\ensuremath\operatorname{\mathbf{atf}}}
\def\tracetobool{\ensuremath\operatorname{\stackrel{\leadsto}{\text{\tiny B}}}}
\def\tracetofba{\ensuremath\operatorname{\stackrel{\leadsto}{\text{\tiny F}}}}
\def\tracetoalgebra{\ensuremath\operatorname{\stackrel{\leadsto}{\text{\tiny XB}}}}
\newcommand{\setsin}[1]{\ensuremath\left\{ #1 \right\}}
\newcommand{\listsin}[1]{\ensuremath\left[ #1 \right]}
\newcommand{\parsin}[1]{\ensuremath\left( #1 \right)}
\newcommand{\anglesin}[1]{\ensuremath\left\langle #1 \right\rangle}
\newcommand{\squaresin}[1]{\ensuremath\left[ #1 \right]}
\newcommand{\func}[2]{\ensuremath #1 \left( #2 \right)}
\newcommand{\highlight}[1]{\fcolorbox{red}{white}{$\displaystyle#1$}}
\newcommand{\highlightresult}[1]{\colorbox{green!50}{$\displaystyle#1$}}
%\def\dlists{\ensuremath\operatorname{\mathbf{dlists}}}
\def\union{\ensuremath\operatorname{\cup}}
\def\inter{\ensuremath\operatorname{\cap}}
\def\powersetop{\ensuremath\mathbb{P}}
\newcommand{\powerset}[1]{\ensuremath\powersetop\left(#1\right)}
\def\cartesian{\ensuremath\operatorname{\times}}
\def\ftcoherencyop{\ensuremath\operatorname{\Phi}}
\newcommand{\ftcoherency}[1]{\ensuremath\ftcoherencyop\parsin{#1}}
\newcommand{\replace}[2]{\ensuremath\squaresin{#1\middle/#2}}
\def\pand{\ensuremath\operatorname{<}}
\def\por{\ensuremath\operatorname{|}}
\def\sand{\ensuremath\operatorname{\&}}
\def\nibefore{\ensuremath\operatorname{\lhd}}
\def\ibefore{\ensuremath\operatorname{\unlhd}}
\def\simultaneous{\ensuremath\operatorname{\bigtriangleup}}
\def\probabilityop{\ensuremath P}
\newcommand{\probability}[1]{\ensuremath \probabilityop\parsin{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeindex

\begin{document}
\selectlanguage{english}

\imprimircapa
\imprimirfolhaderosto*{}

\input{ficha-catalografica}

\input{folha-aprovacao}


%\frontmatter

%\frontpage

%\presentationpage

%\begin{fichacatalografica}
%	\FakeFichaCatalografica % Comment this line when you have the correct file
%     \includepdf{fig_ficha_catalografica.pdf} % Uncomment this
%\end{fichacatalografica}

%\banca

\begin{dedicatoria}
\vspace*{\fill}
I dedicate this thesis to Juliana, Luciana (pipoquinha), and Bianca (snowflake).
\vspace*{\fill}
\end{dedicatoria}

\begin{agradecimentos}

If I were afraid of the path, I wouldn't have gotten here.

Two men helped me to build this path far before I started my scholar journey: Roberto and Júnior.
My two grandparents couldn't see how far I got.
My heart was with them all the time, but I was physically far away from them in their very last breath.
May God have them in his arms.

It is now ten years since I graduated.
I met professors Alexandre and Augusto still during the Computing Science undergrad course.
They have been present in my academic life ever since.
Their comments, instructions, talks, (even jokes), are what molded my path to here.
I have no words to express how much I thank them.
%I hope this is the beginning of a healthy partnership for the improvement of science.

CNPq and FACEPE were keen to guarantee my existential needs.
The former with the trip to Newcastle upon Tyne, and the latter during the time I stayed in Recife, before and after the trip.

I thank to Sascha Romanovsky for accepting me as his \hl{advisee}\adnote{Advisee estaria correto, não? Não entendi\ldots} while I was a Research Assistant of the COMPASS project.
His comments, instructions, and knowledge were of great importance for this work.

My stay in Newcastle upon Tyne could be as good as it was without the hospitality, useful discussions, and support of my colleagues at Newcastle University.
A big THANK YOU to John Fitzgerald, Zoe Andrews, Richard Payne, Claire Smith, Dee Carr, Claire Ingram, my shared office colleague Anirban Bhattacharyya, and all other staff members.

Still in Newcastle upon Tyne, I thank all friends my family and I made outside University.
Thanks to Kelechi Dibie and her family to welcome us for the Christmas' and new year's dinners.
They were our family abroad.

I thank all my family for their patience to have me away in several family reunions, due the time required to do this work.
In special, my two girls and my wife.

\end{agradecimentos}

\begin{epigrafe}

  \vspace*{\fill}
  \begin{flushright}
  \textit{‘‘Mathematical reasoning may be regarded
  rather schematically as the exercise of a combination of two facilities,
  which we may call intuition and ingenuity.\\
  (Alan Turing)}
  \end{flushright}

\end{epigrafe}

%\begin{epigraph}[]{Alan Turing}
% quotes from: http://www.brainyquote.com/quotes/authors/e/edsger_dijkstra.html
% http://www.brainyquote.com/search_results.html?q=boole
% http://www.azquotes.com/author/14856-Alan_Turing
%Mathematical reasoning may be regarded rather schematically as the exercise of a combination of two facilities, which we may call intuition and ingenuity.
%\end{epigraph}

\begin{resumo}[Resumo]
\begin{otherlanguage*}{brazil}
A modelagem de defeitos é essencial na antecipação de falhas em sistemas críticos.
Tradicionalmente, Árvores de Defeitos Estáticas são empregadas para este fim, mas Árvores de Defeitos Temporais e Dinâmicas têm ganho evidência devido ao seu maior poder para modelar e detectar propagações complexas de defeitos que levam a uma falha.

Em um trabalho anterior, mostramos uma estratégia baseada na álgebra de processos CSP e modelos Simulink para obter rastros (propagações) de defeitos que levam a uma falha.
Apesar de o trabalho usar Árvores de Defeitos Estáticas, poderíamos ter usado Árvores de Defeitos Temporais ou Dinâmicas.
No presente trabalho, apresentamos duas álgebras: (i) uma para modelar formalmente defeitos a partir de modelos arquiteturais, racionalizando sobre combinações de defeitos, e (ii) uma álgebra temporal de defeitos (com noção de propagação de defeitos) e provar que ela é de fato uma álgebra Booleana.
Isso permite herdar as propriedades de álgebras Booleanas, leis e técnicas de redução existentes, as quais são muito benéficas para a modelagem e análise de defeitos.
Nós ilustramos nosso trabalho com alguns estudos de caso simples, mas reais, fornecidos pelo nosso parceiro industrial, a EMBRAER.

\vspace{\onelineskip}
\noindent
\textbf{Palavras-chave}: Simulink, CSP, FDR, Fault Tree Analysis, Temporal Fault Trees, Dynamic Fault Trees, Pandora, Fault Injection
\end{otherlanguage*}
\end{resumo}


%\begin{keywords}
%Simulink, CSP, FDR, Fault Tree Analysis, Temporal Fault Trees, Dynamic Fault Trees, Pandora, Fault Injection
%\end{keywords}

\begin{resumo}
Faults modelling is essential to anticipate failures in critical systems.
Traditionally, Static Fault Trees are employed to this end, but Temporal and Dynamic Fault Trees are gaining evidence due to their enriched power to model and detect intricate propagation of faults that lead to a failure.

In previous work, we showed a strategy based on the process algebra CSP and Simulink models to obtain fault traces that lead to a failure.
Although that work used Static Fault Trees, it could be used Temporal or Dynamic Fault Trees.
In this work we present two algebras: (i) one to model faults from architectural models formally, reasoning about faults combinations, and (ii) an algebra of temporal faults (with a notion of fault propagation) and prove that it is indeed a Boolean algebra.
\hl{This allows us to inherit Boolean algebra's properties, laws and existing reduction techniques, which are very beneficial for faults modelling and analysis.}\amnote{Qual a conexão com Temporal e Dynamic Fault Trees?? E as propagações complexas}
We illustrate our work on simple but real case studies, some supplied by our industrial partner EMBRAER.

\vspace{\onelineskip}
\noindent
\todo{Adicionar MSC2010 06E25, 68M15, 68Q60, 93A30}
%\begin{keywords}
\textbf{Keywords}: Simulink, CSP, FDR, Fault Tree Analysis, Temporal Fault Trees, Dynamic Fault Trees, Pandora, Fault Injection
%\end{keywords},
\end{resumo}

% List of figures
\listoffigures*
\cleardoublepage

% List of tables
\listoftables*
\cleardoublepage

% List of acronyms
% Acronyms manual: http://linorg.usp.br/CTAN/macros/latex/contrib/acronym/acronym.pdf
%\input{acronyms}
%\listofacronyms

\acresetall
\printacronyms[name={\listadesiglasname{}},heading=chapter*]
\acresetall
\cleardoublepage


% Summary (tables of contents)
\tableofcontents*
\acresetall
\cleardoublepage

%\mainmatter
\textual

%\part{Context}
%\label{part:context}
\chapter{Introduction}
\label{chap:intro}

\todo{Write the problem: simple mathematical notation for all fault trees. Include direct DFT-to-ATF mapping.}
\todo{use all figure captions before figures (ABNT)}
\todo{fix table lines (ABNT)}

The development process of critical control systems is based essentially on the rigorous execution of guides and regulations~\cite{ANAC2011,FAA1993,FAA2007,SAE1996b}.
Specialized agencies (like FAA, EASA and ANAC in the aviation field) use these guides and regulations to certify such systems.

Safety plays a crucial concern on critical systems and it is the responsibility of the safety assessment process.
ARP-4761~\cite{SAE1996b} defines several techniques to perform safety assessment.
One of them is \ac{FTA}\index{Fault Tree!Analysis}.
It is a deductive method that uses trees to model faults and their dependencies and propagation.
In such trees, the premises are the leaves (basic events) and the conclusions are the roots (top events).
Intermediary events use gates to combine basic events and each kind of gate has its own combination semantics definition.
\Acp{FT} that use only \ortext and \andtext gates are called \emph{coherent \aclp{FT}}~\cite{Andrews2001,AB2003,Oliv2006,CCR2008,Vaurio2016}\index{Fault Tree!coherent}.
They combine the events as \emph{at least one shall occur} and \emph{all shall occur}, respectively.
To analyse \acp{FT}, their structures are abstracted as Boolean\index{Boolean Algebra} expressions called \emph{structure expressions}\index{structure expression}.
The analysis of coherent \acp{FT} uses a well-defined algorithm based on the Shannon's method\index{Binary Decision Diagrams!Shannon's method}---which originated the \ac{BDD}\index{Binary Decision Diagrams}---to obtain \acp{MCS}\adnote{Correct the first citation of the plural form of MCS} from the structure expressions\index{structure expression} and a general formula to calculate the probability of top events.

Besides the traditional \ortext and \andtext gates, the \FThandbook defines other gates.
For example the \pandtext gate, which considers the order of occurrence of events.
Although the \FThandbook defines these new gates, there is no algorithm to perform the analysis of trees that contain such new gates.
This and the need of analysis of dynamic aspects of increasingly complex systems motivated the introduction of two new kinds of \aclp{FT}: \acp{DFT} and \acp{TFT}.
These variant trees can capture sequence dependencies of fault events in a system.
The difference from \ac{TFT} to \ac{DFT} is that \acp{TFT} use temporal gates directly, while \ac{DFT} does not---\acp{DFT} gates are an abstraction of temporal gates.
To differentiate the \aclp{FT} as defined in the \FThandbook from the other two, we will call them \acp{SFT}.

The work reported in~\cite{WP2009} aims at performing the full implementation of the \FThandbook, adding temporal gates to its \pandora methodology.
It was this implementation that introduced the new concept of \acp{TFT}, cited previously.
In such trees, events ordering is well-defined and an algebraic framework was proposed to reduce structure expressions\index{structure expression} to obtain \acp{MCSeq} and perform probabilistic analysis.
Reducing expressions is also desirable to check for tautologies, for example.

\Acp{DFT} introduce very different gates to capture dynamic configurations of systems: \ac{CSp}, \ac{FDEP}, and \ac{SEQ}.
The semantics of the first is to add ``backup'' events, so the gate is active if the primary event and all spares are active.
The second adds basic events dependency from a trigger event.
The third forces the occurrence of events in a particular order.
There is also \iac{WSp} gate that is slightly different from the \ac{CSp} gate.
They differ on the nature of sparing, whether fast (warm, always-on) or slow (cold, stand-by).
The readiness of the backup system in \iac{WSp} gate is higher than in \iac{CSp} gate.
The work reported in~\cite{MRL2011} shows an algebraic framework to compositionally reduce \ac{DFT} gates to order-based gates and perform probabilistic analysis of structure expressions\index{structure expression}. Thus, despite some limitations for spare gates~\cite{MRL2014}, the structure expressions\index{structure expression} used in \acp{TFT} and \acp{DFT} can be formulated in terms of a generic order-based operator.

\begin{sloppypar}
The NOT operator is absent in the algebras reported in~\cite{WP2009,Walker2009,Merle2010,MRL2011b}.
There is no consensus about the relevance of its use: (i) it can be misleading, generating non-coherent analysis~\cite{Oliv2006}, or (ii) it can be essential in practical use~\cite{Andrews2001}.
Our concern is that the decision of the relevance of its use should not be due to the choice of events-occurrence representation.
The algebra created in this work defines the NOT operator and allows its use, as we show in \cref{sec:strategy}.
\end{sloppypar}

In previous work~\cite{Didier2012,DM2012}, we proposed a systematic hardware-based faults identification strategy to obtain failure expressions as defined in \acifused{hiphops}{\acs{hiphops}}{\acscite{hiphops}} for \acp{SFT}.
We considered faults in components or subsystems, but if we obtain failure expressions of a whole system, they are in fact structure expressions\index{structure expression} of \iac{FT}.
%
%Using our strategy as input for \ac{hiphops} we obtain a failure expression of a fault tree.
%
We focused on hardware faults because we assume that software does not fail as a function of time (wear, corrosion, etc).
%
We inherited this view from our industrial partner (\EMBRAER), which assumes that functional behaviour is completely analysed by functional verification~\cite{SP2011}.
%
We followed industry common practices using \simulink diagrams~\cite{Nise1992} as a starting point.
%
The work~\cite{DM2012} was based on \ac{CSPm} to allow an automatic analysis using the model checker \acs{fdr}.
%
Thus, our strategy required the translation from \simulink to \ac{CSPm}~\cite{JMS+2011}.
%
It then runs \acs{fdr} to obtain several counter-examples (which are fault traces) ending in failures.
%
For two case studies provided by our industrial partner, we showed that our automatically created failure expressions match with the engineer's provided ones or are better (a weaker proposition).

\section{Research questions}

Both \ac{TFT} and \ac{DFT} lack a first-order logic mathematical model as there is to \ac{SFT}.
For \acp{SFT}, mathematical models for structure expressions reduction is either based on set inclusion, with \ac{FBA}, or through tree search, with \ac{BDD}.
Both are very efficient.

The mathematical model for \ac{TFT} has a discontinuity between two activation states: (i) non-occurrence, and (ii) occurrence some time later.
Such a discontinuity has some drawbacks, as for example, the impossibility to use \nottext gates and handling the specific case with zeros in \acp{TTT}.
The reduction of structure expressions in \ac{TFT} is based in a combination of: (i) algebraic reduction---that can lead to an ever-growing rules application---and (ii) \ac{TDT}---which are limited to seven basic events, due to exponential grow of the tree.

\begin{sloppypar}
Most of the mathematical models for \ac{DFT} are based on the formalisation of \ac{DTMC} or \ac{CTMC}, because \acp{DFT} were initially conceived to be a visual representation of such models.
There are other approaches, however.
For instance, a modified version of \ac{BDD} to tackle events ordering, called \ac{SBDD}, to reduce structure expressions, and the work reported in \cite{BRM+2005}, which proposes a conversion of \ac{DFT} into \ac{DBN} to perform probabilistic analysis.
The construction of \iac{DBN} is automatic and handles time slices as $t + \Delta t$, which implies a notion of events ordering as well.
\Acp{SBDD}...
The work reported in~\cite{BRM+2005} is focused in probabilistic analysis, so qualitative analysis is not directly supported.
\end{sloppypar}

The works reported in~\cite{Merle2010,XTD2012} show that \acg{DFT} operators can be converted into order-related operators, simplifying \ac{DFT} analysis.
Although the mathematical model presented in~\cite{Merle2010} establishes a denotational semantics for order-related operators, it lacks a method for expression reduction based on such a model.
It defines, instead, several algebraic laws to reduce expressions.

\section{Proposed solution}

In this work, we present a strategy to perform \aclp{FTA} on systems by: (i) injecting faults on its nominal model, and (ii) complement the injected faults by modelling faults in a formal model.
\Cref{fig:strategy-overview} show the strategy overview.
``Faults injection'' block is obtained from part of the work reported in~\cite{Didier2012}.
It starts with \simulink modelling, converts the model to \ac{CSPm} and then obtains fault events sequences.
The fault events sequences are then mapped to \theac{algebra}.
As fault names are obtained directly from components and subsystems in a Simulink model, \theac{activation} (in the ``Faults Modelling'' group) allows them to be modified or complemented.
\Theac{activation} also allows reasoning about faults that are not modelled in Simulink as, for example, common cause or environmental faults.
\Ac{activation} can be used to model faults formally, reasoning about basic fault events and top-event failures.
Each predicate in \ac{activation} generates an expression in \theac{algebra}, which allows expressions reduction to obtain a canonical form that enables finding \acp{MCSeq} and calculating top-events probability.

\Theac{FTA} has associated system requirements which are in fact acceptance criteria.
Once \acg{FT} acceptance criteria is modelled as expressions in \ac{algebra}, we formally check whether they are accepted by system models' expressions.

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.8]{StrategyOverview}
  \caption{Strategy overview}
  \label{fig:strategy-overview}
\end{figure}

\section{Contributions}

The main contributions of this work are:

\begin{enumerate}
  \item Define a denotational and algebraic model to express fault events order with \theac{algebra}, and formally verify \acg{FT} acceptance;
  \item Reusing \simulink models, obtaining fault event sequences and mapping to \ac{algebra};
  \item Reasoning about faults modelling in \ac{activation}, obtaining formal expressions of top-event failures;
  \item Illustrating the application of the laws on real case studies, two provided by our industrial partner.
\end{enumerate}

Other contributions of this work are:

\begin{enumerate}
  \item Defining a new operator to express order explicitly and proving that the resulting algebra---(\ac{algebra}) using this operator and Boolean\index{Boolean Algebra} operators---is a conservative extension of the Boolean algebra\index{Boolean Algebra} (also published in~\cite{DM2016});
  \todo{When accepted, add work submitted to ISF}
  \item Generalising laws in~\ac{algebra} in terms of abstract properties, similar to healthiness conditions in \theac{UTP}.
\end{enumerate}

We used Isabelle/HOL\index{Isabelle/HOL} 2015\footnote{The 2002 tutorial is reported in~\cite{NPW2002}, but there is a newer version published with the tool itself.
The tool and the tutorial are available on their website at http://isabelle.in.tum.de .}, theories in Isabelle's library, and a theory in the AFP library \cite{JM2005} to prove all theorems presented in this work.
%We omit the proofs in the paper, but they are available in Online Resource 1.\todo{publish theory files online: ``Specialized format such as .pdb (chemical), .wrl (VRML), .nb (Mathematica notebook), and .tex can also be supplied.''}

\section{Thesis organization}

This thesis is organized as follows: in \cref{part:background} we show the concepts and tools used as basis for this work.
\Cref{part:results} describes the results: \cref{sec:strategy} presents our strategy, \cref{sec:case-study} the case study and the application of the proposed strategy, and we present our conclusions and future work in \cref{sec:conclusion}.

\part{Background}
\label{part:background}

\chapter{Basic concepts}
\label{chap:basic-concepts}

Means to dependability are obtained by modelling and analysing a system.
It is strongly related to faults modelling, which depends on which analyses we want to perform.
%For instance, in \aclp{FT}, even if a fault can be repaired, it is considered as a non-repairable fault.
\Acp{FT} are present in several stages of systems' modelling.
We introduce dependability and faults modelling in \cref{sec:dependability}.

\Iacl{FT} is a snapshot\footnote{Whether a top event indeed causes a catastrophic or major failure is out of the scope of this thesis; we consider that, if it is possible that such failure occur, then it will.} of a faults topology of a system, subsystem or component.
%\acp{TFT} and \acp{DFT} uses sequences of fault events because they consider a time relation on fault events.
The time relation of fault events in \acp{TFT} and \acp{DFT} allows the analysis of different configurations (or snapshots) of a system, subsystem or component.
We discuss these time relations in \cref{sec:time-relations}.

\section{Systems, dependability\index{Dependability} and fault modelling\index{fault modelling}}
\label{sec:dependability}

\begin{sloppypar}
Computing systems are characterized by five properties: functionality, performance, cost, dependability\index{dependability}, security.
The work reported in~\cite[p. 289--302]{Sommerville2011} explain these properties---including dependability---with a focus in software.
Hardware and software are connected, as software faults may cause software-controlled hardware to fail, and hardware faults may send incorrect data, causing software to fail.
\end{sloppypar}

The work reported in~\cite{ALR+2004} summarizes all concepts of and related to dependability for computing systems that contains software and hardware.
In the following, we show these concepts and highlight those used in this work.

\subsection{Systems}

Before introducing systems' dependability, we first describe what a system is and its characteristics.
It is an entity that interacts with other systems (software and hardware as well), users (humans), and the physical world.
These other entities are the \emph{environment} of the given system, and its \emph{boundary} is the frontier between the system and its environment.

The \emph{function} of a system is what the system is intended to do, and its \emph{behaviour} is what the system does to implement its function.
The \emph{total state} of a system are the means to implement its function and defined as the set of the following states: computation, communication, stored information, interconnection, and physical condition.
The \emph{service} delivered by a system is its behaviour as it is perceived by its boundary.
A system can both provide and consume services.

The \emph{structure} of a system is how it is composed: a system is composed of components, and each component is another system, etc.
This concept of hierarchical compositionality in systems, is what originated the concept of \ac{SoS} and is object of analysis in \ac{hiphops}.
Such recursion stops when a component---or a constituent system---is considered to be atomic.
A system is the total state of its atomic components.

\subsection{Dependability}

The concepts of dependability\index{dependability} are: (i) threats to, (ii) attributes of, and (iii) means to attain.

\emph{Threats to dependability}\index{dependability!threats to} are the so-called \emph{fault-error-failure} chain.
A failure is a service deviation perceived on systems' boundary.
An error is the part of the total state of a system that leads to subsequent service failure.
Depending on how a system tolerate internal errors, many errors may not reach system's boundary.
Finally, a fault is what causes an error.
In this case, we say that the fault is active, the fault \emph{occurred}.
Otherwise, the fault is dormant, and has not occurred (yet).
A \emph{degraded} mode of a system is when there are active faults, so some functions of the system are inoperative, but the system still delivers its service.

There are two acceptable definitions of dependability reported in~\cite{ALR+2004}.
One is more general, difficult to measure: ``the ability to deliver service that can justifiably be \emph{trusted}''.
A more precise definition that uses the definition of service failure is: ``the ability to avoid service failures that are more frequent and more severe than is acceptable''.
This definition has two implications about system's requirements: there should be how it can fail, and what are the acceptable severity and frequency of its failures.

The following systems' dependability attributes\index{dependability!attributes of} enlightens such requirements:
\begin{description}
  \item[Availability:] the readiness for correct service;
  \item[Reliability:] continuity of correct service;
  \item[Safety:] absence of catastrophic consequences on the environment (other systems, users, and the physical world).
  Safety can be verified using \acp{FT}, which is part of the objective of this work;
  \item[Integrity:] absence of improper systems alterations;
  \item[Maintainability:] ability to be modified and repaired.
\end{description}
%
A system description should mention all or most of these attributes, at least the first three.

The implementation of these attributes requires a the deep analysis of system's models.
The \emph{means to attain dependability}\index{dependability!means to attain} are summarized as follows:

\begin{description}
  \item[Prevention] is about avoiding incorporate faults during development.
  \item[Tolerance] deals with usage of mechanisms to still deliver a---possibly degraded---service even in the presence of faults.
  \item[Removal] is about detecting and removing (or reducing severity of) failures from a system, as in the development stage, as in production stage.
  \item[Forecasting] is about predicting likely faults so they can removed, or tackling their effects.
\end{description}

The intersection of this work with dependability is in fault removal during development and fault tolerance (analysis).
There are some techniques for fault removal, summarized as follows:
\begin{itemize}
  \item Static verification
  \begin{itemize}
    \item System
    \begin{description}
      \item[Static analysis:] Range from inspection or walk-through, data flow analysis, complexity analysis, abstract interpretation, compiler checks, vulnerability search, etc.
      \item[Theorem proving:] Check properties of system models.
    \end{description}
    \item Behaviour model
    \begin{description}
      \item[Model checking:] Usually the model is a state-transition model (\acp{PN}, finite or infinite state automata).
      Model-checking verifies all possible states on a given system's model.
    \end{description}
  \end{itemize}
  \item Dynamic verification
  \begin{itemize}
    \item Symbolic inputs
    \begin{description}
      \item[Symbolic Execution:] It's the execution with respect to variables (symbols) as inputs.
    \end{description}
    \item Actual inputs
    \begin{description}
      \item[Testing:] Selected input values are set on system's inputs and their outputs are compared to expected values.
      Outputs in this case are observed faults, in case of hardware testing or software's mutation testing, and criteria-based, in case of software testing.
    \end{description}
  \end{itemize}
\end{itemize}

Verification methods are often used in combination.
For example, symbolic execution may be used to obtain testing patterns, test inputs can be obtained by model-checking as in~\cite{CBC+2015}, faults can be used as symbolic inputs, and system behaviour can be observed using model-checking as in~\cite{DM2012,Didier2012} (this technique is called fault injection; see also~\cite{AAL+1996}).

The techniques to attain fault tolerance are summarized as follows:
\begin{description}
  \item[Error detection:] is used to identify the presence of an error.
  It can be a concurrent or a preemptive detection.
  Concurrent detection takes place during normal service, while preemptive detection takes place while normal service is suspended.
  \item[Recovery:] transforms a system state that contains errors into a state without them. The behaviour of the system upon recovery is equivalent to the normal behaviour.
  Techniques range from rollback to a previously saved state without errors, error masking, isolation of faulty components, to reconfiguration using spare components.
\end{description}

In this work, we use a combination of: (i) fault-injection, (ii) theorem proving, and (iii) symbolic execution.
We use these methods to obtain an erroneous behaviour of the system which is compared to system's dependability attributes (safety).
We explain how these methods combine in \cref{sec:strategy}.

\subsection{Fault Modelling}

Fault modelling plays an important role in reasoning about the fault-error-failure chain.
They are the initial steps to perform the verification of a system.

\todo{Solve the same author, same year citation problem.}
\Ac{SysML} is a profile for \ac{UML} that provides features to model structure and behaviour of systems.
The works reported in~\cite{APR+2013,ADP+2013} define several structural and behavioural views in \ac{SysML} to model the fault-error-failure chain and fault tolerance.
Fault, error, failures, and fault propagation have structural views, which are related to behavioural views to describe fault activation and recovery.
These works map \ac{SysML} to two formal languages---\ac{CML} and \ac{CSP}, respectively---to verify fault tolerance.

In~\cite{SAE1996b} the safety assessment process for civil airborne systems and equipment describes development cycles and methods to ``clearly identify each failure condition''.
The methods that involves failure identification are: (i) \ac{SFT}, (ii) \ac{DD}, (iii) \aca{DTMC}, and (iv) \ac{FMEA}.
The first three are top-down methods, that starts with undesired failure conditions and moves to lower levels to obtain more detailed conditions that causes the top-level event.
\Acp{DD} are an alternate method of representing the data in \ac{SFT}.
\Ac{FMEA} is a bottom-up method that identifies failure modes of a component and determines the effects on the next higher level.
We detail \ac{SFT} in \cref{sec:static-fault-trees}.

\Acp{DFT} are an extension of \acp{SFT} and models dynamic behaviour of system's faults.
Similarly to the relation of \acp{SFT} and \acp{DD}, the work reported in~\cite{DP2009} demonstrates the relation of \acp{DFT} to \acp{DRBD}.
As the models (\ac{DFT} and \ac{DRBD}) are equivalent, this work sticks to \ac{DFT} due to the amount of work already published.
We detail \acp{DFT} in \cref{sec:dynamic-fault-trees}.

\section{Time relation of fault events}
\label{sec:time-relations}

The most general case for time relations\index{time relations}\index{order!time relations} is to consider that each fault event has a continuous time duration.
They are the basis on how fault events discretisation are defined.
In \cref{fig:time-relations} we show all possibilities of events relations in a continuous time line (from $A$ to $B$; the converse relation is similar):

\begin{description}
  \item[a.] $A$ starts and ends before $B$ starts;
  \item[b.] $A$ starts before and ends after $B$ has started, but before $B$ has ended;
  \item[c.] $A$ starts before $B$ and ends after $B$ has ended ($A$ contains $B$);
  \item[d.] $A$ and $B$ start at the same time, but $A$ ends before $B$;
  \item[e.] $B$ starts after $A$, but they end at the same time;
  \item[f.] $A$ and $B$ start and end at the same time;
  \item[g.] $A$ starts before $B$ and ends when $B$ starts.
\end{description}

Although the occurrence of fault events has at least seven possibilities, what really matters when analysing systems is when a fault is \emph{detected}.
Considering that fault detection corresponds to the start of a fault event, from \cref{fig:time-relations} we clearly identify which event comes first: $A$ comes before than $B$, except in the cases (d) and (f), where they start exactly at the same time.
If fault events are independent (they are not susceptible to have a common cause) then the probability of they are starting at the same time is very low.
In \cref{sec:strategy} we abstract events relation in continuous time as an \emph{exclusive before} relation, based on fault \emph{detection} (it is similar---at least implicitly---to what is reported in~\cite{WP2009,MRL2011}).


\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.5]{time-relations}
  \caption{Relation of two events with duration}
  \label{fig:time-relations}
\end{figure}

\chapter{Analysis and tools}
\label{chap:analysis}

Structure expressions\index{structure expression} are used to analyse \aclp{FT}.
In general, a structure expression\index{structure expression} comes from gates semantics and basic events.
Basic events become variables and gates become operators (a gate may become one or more operators).
In \cref{sec:fault-trees} we explain \acp{SFT}, \acp{TFT}, \acp{DFT}, and their respective structure expressions\index{structure expression}.

\Acp{FBA} and \acp{BDD} are a basis to analyse structure expressions.
Also, we were inspired by \ac{FBA} concepts to create our \acl{algebra} (\cref{sec:strategy}).
We explain \acp{BDD} and derived techniques in \cref{sec:structure-expressions-analysis}, and \acp{FBA} in \cref{sec:fba}.

The use of the Boolean\index{Boolean Algebra} operator \emph{NOT}: (i) can be misleading, generating non-coherent \aclp{FT}, or (ii) can be essential in practical use.
We discuss such cases in \cref{sec:not-operator}.

To reuse a nominal model to analyse faults we need fault injection.
In \cref{sec:faults-injection} we explain how we used \simulink and \ac{CSPm} to inject faults and obtain failure logic from a nominal model.

Finally, in \cref{sec:isabelle} we present basic usage of Isabelle/HOL\index{Isabelle/HOL} and \ac{Isar}, which were essential to carry out the proofs presented in this thesis.

\section{\Acl{FTA} and structure expressions}
\label{sec:fault-trees}

\Ac{FTA} was introduced in the \FThandbook with \aclp{SFT}.
\Ac{FTA} is a deductive method that investigates what are the possible causes of a unwanted event.
The method starts with the top-level event as the unwanted event and the combination of lower-level events that can cause it.
Events are combined using gates, and each gate has a well defined semantics.
It continues until basic (atomic) events are reached.
\Iac{SFT} represents, in a single view---very often considering faults outside of the boundaries of a system---different states in which a particular failure is active in a system.
The most traditional gates are \andtext and \ortext, which are equivalent to Boolean operators.
These gates are also called coherent gates\index{coherent gates} because they construct coherent trees (see \cref{sec:not-operator} about the use of \nottext gates).
%A Boolean expression represents the structure of \iac{SFT}.
%Qualitative and quantitative analysis are evaluated on these Boolean expressions, that are referred to as \emph{structure expressions}.
\Acg{SFT} gates and analysis are detailed in \cref{sec:static-fault-trees}.

\Acp{TFT} were created aiming at fully implement the \FThandbook~\cite{VGR+1981}.
The \pandtext gate was first defined for \acp{SFT}, but its analysis was left open in the handbook.
The analysis of \acp{TFT} uses a denotational semantics based on \emph{sequence values}\index{Temporal Fault Tree!sequence value} to express ordering of events, thus tackling \pandtext's order.
We explain \acp{TFT} and the sequence values in \cref{sec:temporal-fault-trees}.

\begin{sloppypar}
With component and system design evolution, \acp{DFT} were created to tackle dynamic behaviour: fault-tolerance-related components (\ac{CSp}), functional dependency (\ac{FDEP}), and analysis of particular order of occurrence of faults (\ac{SEQ}).
\Acg{SFT} gates are still present as \acg{DFT} gates.
We explain them and \acg{DFT} analysis in \cref{sec:dynamic-fault-trees}.
\end{sloppypar}

The structure of \iac{FT} (or the structure of \iac{MCS}, explained further) is represented with a formula.
The variables represent occurrence of basic events.
Unary and binary relation symbols capture the semantics of gates.
A formula with these characteristics is called \emph{structure expression}\index{structure expression} or \emph{structure function}\index{structure expressions!function} (as the expression depends on the variables).
The semantics of a structure expression is that the top-level event occurs if some combination of basic events occur.

\begin{sloppypar}
The results obtained from the evaluation of \acp{FT} are shown in the \FThandbook.
We summarize them as:
%
\begin{itemize}
  \item Qualitative
  \begin{description}
    \item[\Acp{MCS}\index{Fault Tree Analysis!minimal cut set}:]
    Smallest combinations of components failures causing system failure.
    They are obtained from the reduction to a normal form.
    For example, in \acp{SFT}, structure expressions\index{structure expression} are reduced to \ac{DNF}.
    Each term in a reduced \ac{DNF} is \iac{MCS}.
    \item[Importances\index{Fault Tree Analysis!qualitative importance}:]
    Qualitative rankings on contributions to system failure.
    A single fault causing a catastrophic failure is usually unacceptable.
    Ranking \acp{MCS} is the same as ordering them in ascending order of their size (smaller first).
  \end{description}
  \item Quantitative
  \begin{description}
    \item[Numerical probabilities\index{Fault Tree Analysis!numerical probability}:]
    Probabilities of system and \acg{MCS} failures.
    A system failure probability is obtained by assigning probabilities to basic events and then calculating it accordingly to gates' semantics.
    \Acg{MCS} failure probability is the calculation of the probability of the occurrence of \emph{all} basic events of a specific \ac{MCS}.
    \item[Importances\index{Fault Tree Analysis!quantitative importance}:]
    Quantitative rankings on contributions to system failure.
    Ranking \acp{MCS} is the same as ordering them in descending order of some unreliability formula (higher first).
    These formulas used to calculate importance vary.
    The most commons are: (i) system unavailability, and (ii) system failure occurrence rate.
    \item[Sensitivity evaluation\index{Fault Tree Analysis!sensitivity evaluation}:]
    Modifying characteristics of components and evaluate their impact.
    For a particular event in a tree, a higher and a lower failure probability value are assigned.
    If system's unavailability is not changed, then such event is not important---the system is not sensitive to such an event.
  \end{description}
\end{itemize}
\end{sloppypar}

As stated in~\cite{SVD+2002}, there are other uses of \ac{FTA}.
One of great importance is using it to minimize and optimize resources, which has been object of study in \ac{hiphops}~\cite{APS+2011}.
Through importance measures\index{importance measure}, \ac{FTA} not only identifies what is important but also what is unimportant, thus removing components without impacting the overall failure probability, which is related to the quantitative importance\index{Fault Tree Analysis!quantitative importance} and sensitivity evaluation\index{Fault Tree Analysis!sensitivity evaluation}.

\begin{sloppypar}
In important stages of critical systems, \ac{FTA} plays essential role.
At least three dependability means can be achieved using \acp{FT}:
%
\todo{Improve the relations of dependability and FTA}
\begin{description}
  \item[Removal.]
  \Iac{FTA} indicates if the probability of failure of a subsystem is high, so such subsystem should be removed or left to be incorporated in combination of a more reliable component.
  \item[Tolerance.]
  \Iac{FTA} indicate whether a single fault---or fewer combinations than expected---could lead to a catastrophic failure.
  In this case, a system should have replication, or stages of fault detection and error handling.
  Also, the probability of failure of the chosen fault tolerance method can be evaluated.
\end{description}
\end{sloppypar}

In \cref{sec:static-fault-trees,sec:temporal-fault-trees,sec:dynamic-fault-trees} we show briefly \acpg{FT} symbology and means to analyse \acp{FT}.
We will detail it structure expressions extraction because they are a common means to perform both qualitative and quantitative analysis.

\subsection{\Aclp{SFT}}
\label{sec:static-fault-trees}

\Acg{SFT} gates and structure expressions are explained in this section.

The \FThandbook shows traditional symbols for gates and events.
Basic events are usually drawn as rectangle (for the text) and a circle below it. Top-level and intermediary events are drawn as a rectangle (for the text) and a gate below it.
When \iac{FT} becomes too large, transfer in and out symbols can be used.
They are usually drawn as triangles with a letter or a number.
\Cref{fig:sft-example-traditional-gates} depicts traditional gates as specified in the \FThandbook, and \cref{fig:sft-example-ald-software} shows \iac{FT} using \theftanalyser{}---a free commercial tool.
In this work, to keep a visual identity with other \acp{FT}, and to avoid symbols confusion, we use gates symbols as shown in~\cref{fig:sft-gates}.

\begin{figure}[t]
\includegraphicsaspectratio[0.9]{sft-symbols-ft-handbook}
  \caption{\acs{SFT} symbols as in the \FThandbook}
  \label{fig:sft-example-traditional-gates}
\end{figure}

\begin{figure}[t]
  \includegraphicsaspectratio[1]{sft-example-ald-software}
  \caption{\Ac{SFT} symbols using a free commercial tool}
  \label{fig:sft-example-ald-software}
\end{figure}

\begin{figure}[t]
  \centering
  \subcaptionbox{Basic event\label{fig:sft-basic-event}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.2]{ft-symbol-basic-event}
    }%
  \subcaptionbox{Intermediary event\label{fig:sft-intermediary-event}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.2]{ft-symbol-top-or-intermediary}
    }
  \subcaptionbox{\andtext gate\label{fig:sft-and-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-and-gate}
    }
  \subcaptionbox{\ortext gate\label{fig:sft-or-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-or-gate}
    }
  \subcaptionbox{\nottext gate\label{fig:sft-not-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-not-gate}
    }
  \subcaptionbox{Transfer symbol\label{fig:sft-transfer}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.15]{ft-symbol-transfer}
    }
  \caption{\ac{SFT} gates}
  \label{fig:sft-gates}
\end{figure}

Structure expressions\index{structure expression} in \ac{FTA} are defined in terms of set theory, using symbols for fault events occurrence.
%, using what is called of generative sets.
If a fault event symbol is in a set, then it means that fault has occurred.
A set is a combination of fault events that causes the top-level event of a tree.
A structure expression\index{structure expression} of a tree is denoted by a set of sets of fault event combinations.
The \ortext gate becomes the union operator between sets and the \andtext gate, the intersection.
For example, if a system contains fault events \emph{a}, \emph{b}, and \emph{c}, \aclp{FT} for this system contain at most all these three events.
%The occurrence of a single event $a$ may be associated with the occurrence (or not) of the other events in any order.
The occurrence of the fault event $a$ is denoted by a set of sets $A$, which contains the following sets:
%
\begin{enumerate}
  \item\label{item:fta-only-a-occurs} $\left\{a\right\}$: only \emph{a} occurs;
  \item\label{item:fta-a-and-b-occur} $\left\{a,b\right\}$: \emph{a} and \emph{b} occur;
  \item\label{item:fta-a-and-c-occur} $\left\{a,c\right\}$: \emph{a} and \emph{c} occur;
  \item\label{item:fta-all-occur} $\left\{a,b,c\right\}$: all three events occur.
\end{enumerate}
%
%Fault event \emph{a} occurs in all possibilities.
%As these are sets, they represent combinations and not permutations.
%Combination $\left\{a,b,c\right\}$ represents the same as $\left\{b,a,c\right\}$, $\left\{c,b,a\right\}$, etc.
%Let the set that contains these sets be $A$.
%Similarly, let $B$ be the set of sets that contain the fault event $b$.

The \acl{FT} in \cref{fig:ex-fault-tree1} contains only two events and the resulting structure expression\index{structure expression} for this \ac{FT} is the expression $A \inter B$ ($TOP$), where $A$ and $B$ are the sets of sets that contain $a$ and $b$, respectively.
The resulting combinations for $TOP$ are $\left\{a,b\right\}$ and $\left\{a,b,c\right\}$ (fault events \emph{a} and \emph{b} occur in all possibilities).\todo{Pedir para Alexandre avaliar pontualmente esta frase}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.45]{ex-fault-tree1}
  \caption{Very simple example of a \acl{FT}}
  \label{fig:ex-fault-tree1}
\end{figure}

After obtaining structure expressions\index{structure expression}, the next step is to reduce the expressions to a canonical form to obtain the \emph{\acp{MCS}}\index{Minimal Cut!Sets}, which are the sets that contain the minimum and sufficient events to activate the top-level failure.
%That is, \acp{MCS}\index{Minimal Cut!Sets} are the smallest sets of fault event that, if all occur, cause the top-level failure to occur.
Probabilistic analysis is then performed on these events to obtain the overall probability of occurrence of the top-level event.
The \FThandbook shows an algorithm based on Shannon's method\index{Binary Decision Diagrams!Shannon's method} to reduce structure expressions\index{structure expression} to obtain minimal cut sets\index{Minimal Cut!Sets}.
%BDDs are essentially the diagrams of Shannon's method.
The Boolean\index{Boolean Algebra} expression of the tree shown in \cref{fig:ex-fault-tree1} is $TOP = A \wedge B$.
A technique called \ac{BDD}---which derives from Shannon's method---is explained in \cref{sec:bdd}.

\subsection{\Aclp{TFT}}
\label{sec:temporal-fault-trees}

There are at least two versions of \acp{TFT}.
One is described in~\cite{Palshikar2002} and use more traditional style of temporal logic (a variation of \ac{LTL}).
The other version is also called \pandora, and is the one we refer to in the following.

\Acp{TFT} were conceived taking a slightly different direction to \ac{DFT}.
They are focused on directly expressing ordering relationships rather than different states of a system. Basically they extend \acg{SFT} \pandtext gates, allowing analysis of \ac{FT} with such gates.
It is simpler to express than \ac{DFT}, but lacks the fault-tolerance-related gate of \acp{DFT} (which we show in \cref{sec:dynamic-fault-trees}).

\begin{sloppypar}
Structure expressions\index{structure expression} are also present in \acp{TFT}~\cite{WP2009,Walker2009,WP2010}, through the \pandora methodology.
These expressions use the \ac{SFT} operators \ortext and \andtext, and three new operators related to events ordering: \pandtext\adnote{Use the first appearance form.}, \portext, and \sandtext.
The semantics of the \pandtext in \acp{TFT} is similar to the semantics of the \pandtext described in the \FThandbook.
To avoid ambiguous expressions, the semantics in \acp{TFT} is stated in terms of natural numbers, using a \emph{sequence value} function.
For every possible combination of events ordering, it assigns a sequence value to each fault event.
For example, if event A occurs before event B, then the sequence value of A is lower than the sequence value of B, and one formula to express this is $A \pand B$.
\end{sloppypar}

An invariant on sequence values is that there are no gaps for assigned values.
For example, if faults A and B occur at the same time and there are only these two events, then they should both be assigned value $1$.
On the other hand, if A occurs before B, then the assigned values are 1 and 2, respectively.
Value zero means that the event is not active on the combination.
Similar to Boolean's truth tables, the \pandora methodology defines \acp{TTT}.
They represent formula values for every combination of events.
\Cref{tbl:tft-operators} shows the \ac{TTT} of all \ac{TFT} operators, and \cref{fig:tft-symbols} shows \ac{TFT}-specific symbols used in this work.
To illustrate \acp{TFT}, for the formula $\parsin{A \pand C} \lor \parsin{A \land B}$, we show: (i) the \ac{TFT} in \cref{fig:tft-small-example}, and (ii) its corresponding \ac{TTT} in \cref{tbl:ttt-small-example} (the column `\#' indicates the \ac{MCSeq} number).

\begin{table}
% table caption is above the table
\caption{\acs{TTT} of \acsg*{TFT} operators and sequence value numbers}
\label{tbl:tft-operators}
% For LaTeX tables use
\centering
\begin{tabular}{ccccccc}
\hline\noalign{\smallskip}
A & B & \andtext & \ortext & \pandtext & \portext & \sandtext  \\
\noalign{\smallskip}\hline\noalign{\smallskip}
0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 1 & 0 & 0 & 0\\
1 & 0 & 0 & 1 & 0 & 1 & 0\\
1 & 1 & 1 & 1 & 0 & 0 & 1\\
1 & 2 & 2 & 1 & 2 & 1 & 0\\
2 & 1 & 2 & 1 & 0 & 0 & 0\\
\noalign{\smallskip}\hline
\end{tabular}
\end{table}

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{0.15\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-pand-gate}
    \caption{\pandtext gate}\label{fig:tft-pand-gate}
  \end{subfigure}
  \begin{subfigure}[b]{0.15\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-por-gate}
    \caption{\portext gate}\label{fig:tft-por-gate}
  \end{subfigure}
  \begin{subfigure}[b]{0.15\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-sand-gate}
    \caption{\sandtext gate}\label{fig:tft-sand-gate}
  \end{subfigure}
  \caption{\acs{TFT}-specific gates}
  \label{fig:tft-symbols}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.55]{tft-small-example}
  \caption{\acs{TFT} small example}
  \label{fig:tft-small-example}
\end{figure}

\begin{table}
  \caption{\acs{TTT} of a simple example}
  \label{tbl:ttt-small-example}
  \centering
  {\scriptsize
  \begin{tabular}{ccccccc}
  \hline\noalign{\smallskip}
  \# & A & B & C & $A \pand C$ & $A \land B$ & $\parsin{A \pand C} \lor \parsin{A \land B}$ \\
  \noalign{\smallskip}\hline\noalign{\smallskip}
  01 & 0 & 0 & 0 & 0 & 0 & \textbf{0}\\
  02 & 0 & 0 & 1 & 0 & 0 & \textbf{0}\\
  03 & 0 & 1 & 0 & 0 & 0 & \textbf{0}\\
  04 & 0 & 1 & 1 & 0 & 0 & \textbf{0}\\
  05 & 0 & 1 & 2 & 0 & 0 & \textbf{0}\\
  06 & 0 & 2 & 1 & 0 & 0 & \textbf{0}\\
  07 & 1 & 0 & 0 & 0 & 0 & \textbf{0}\\
  08 & 1 & 0 & 1 & 0 & 0 & \textbf{0}\\
  09 & 1 & 0 & 2 & 2 & 0 & \textbf{2}\\
  10 & 1 & 1 & 0 & 0 & 1 & \textbf{1}\\
  11 & 1 & 1 & 1 & 0 & 1 & \textbf{1}\\
  12 & 1 & 1 & 2 & 2 & 1 & \textbf{1}\\
  13 & 1 & 2 & 1 & 0 & 2 & \textbf{2}\\
  14 & 1 & 2 & 2 & 2 & 2 & \textbf{2}\\
  15 & 1 & 2 & 3 & 3 & 2 & \textbf{2}\\
  16 & 1 & 3 & 2 & 2 & 3 & \textbf{2}\\
  17 & 2 & 0 & 1 & 0 & 0 & \textbf{0}\\
  18 & 2 & 1 & 0 & 0 & 2 & \textbf{2}\\
  19 & 2 & 1 & 1 & 0 & 2 & \textbf{2}\\
  20 & 2 & 1 & 2 & 0 & 2 & \textbf{2}\\
  21 & 2 & 1 & 3 & 3 & 2 & \textbf{2}\\
  22 & 2 & 2 & 1 & 0 & 2 & \textbf{2}\\
  23 & 2 & 3 & 1 & 0 & 3 & \textbf{3}\\
  24 & 3 & 1 & 2 & 0 & 3 & \textbf{3}\\
  25 & 3 & 2 & 1 & 0 & 3 & \textbf{3}\\
  \noalign{\smallskip}\hline
  \end{tabular}
  }
\end{table}

From structure expressions in order-sensitive \acp{FT} (\ac{TFT} and \ac{DFT}), \acp{MCSeq} are obtained.
Several approaches represent \acg{MCSeq} ordering differently.
For the best of our knowledge they are introduced in~\cite{TD2004} similarly as \ac{MCS}, allowing set elements with arrows (``$\rightarrow$'') to represent order.

For \acp{TFT}, in~\cite{Walker2009} \acp{MCSeq} are represented as \iac{DNF} using \andtext and the temporal operators (\pandtext, \portext, and \sandtext) as doublets (a single temporal relation)---which are the minimal terms---or prime implicants---in the \ac{DNF}.
In a doublet, the expression is a product (of \andtext{}s) of temporal operators.

The normal form for \ac{TFT} is similar to \ac{SFT}: it is \iac{DNF} with temporal operators (\pandtext, \portext, \sandtext) in the minterms.
The reduction of \ac{TFT} structure expressions is achieved using \ac{TDT}\adnote{Cite dependency tree}.
In \iac{TDT}, if all children of a tree node are true, then the node is also true.
Conversely, if a node is true, then all its children are also true.
An issue with \acp{TDT} is that they grow exponentially.
Accordingly to the work reported in~\cite{WP2010}, it is already infeasible to deal with seven fault events in TFTs.
The solution is based on a mixed application of \acp{TDT}, modularisation of independent subtrees, and algebraic laws~\cite{WP2009}.
We show \acp{TDT} in~\cref{sec:dependency-trees}.
Some of these algebraic laws are:
%
\begin{subequations}
\begin{align}
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} &= X \land Y & \text{Conjunctive Completion Law}\label{law:tft-conjunctive-completion-law}\\
  \parsin{X \por Y} \lor \parsin{X \sand Y} \lor \parsin{Y \por X} &= X \lor Y & \text{Disjunctive Completion Law}\\
  \parsin{X \por Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} &= X & \text{Reductive Completion Law 1st}\\
  \parsin{X \land Y} \lor \parsin{X \por Y}  &= X & \text{Reductive Completion Law 2nd}
\end{align}
\end{subequations}

\subsection{\Aclp{DFT}}
\label{sec:dynamic-fault-trees}

\begin{sloppypar}
\Aclp{DFT} were designed with the goal of analysing complex systems with dynamic redundancy management and complex fault and recovery mechanisms~\cite{DBB1992}.
The idea was to create easy-to-use and less error-prone modelling tools than using \acp{DTMC}---or simply \emph{\acap{DTMC}}---directly.
So, since the very beginning, \acp{DFT} were intended to be evaluated using \acap{DTMC}.
\Cref{fig:dft-original-symbols} depicts the original gate symbols as shown in~\cite{DBB1992,Boyd1992}.
In this work, we use gates symbols as depicted in \cref{fig:dft-symbols}.
The informal semantics of them are:
%
\begin{description}
  \item[\Ac{FDEP}:]
  When the trigger event occurs, the dependent events are forced to occur.
  Timing in this gate between trigger event and dependent events occurrences can be at the same time (like in \acg{TFT} \sandtext gate), or in a small amount of time, thus implying an order of occurrence, depending on the kind of dependency.
  \item[\Ac{CSp}:]
  It is a specific gate to handle spare components.
  It is important to note that connected inputs are not components---they are fault events of connected components.
  If the i\emph{th} input is already active (fault has occurred), then it is expected that the input i\emph{th}$+1$ is not, following the specified order.
  The output becomes true after all connected inputs become true.
  A spare event can be connected to more than one \ac{CSp} gate, representing the spare unit connection to one or more components.
  \item[\pandtext:]
  The same as in \ac{TFT}: when the connected input events occur in the specified order, it outputs true.
  \item[\Ac{SEQ}:]
  The connected events \emph{shall} occur in the specified order.
  It is different from the \pandtext gate, because the latter \emph{detects} the specified order.
  The usage of this gate is usually associated with \ac{FDEP}.
\end{description}
\end{sloppypar}

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{.32\linewidth}
    \centering
    \includegraphicsaspectratio[1]{dft-original-fdep-symbol}
    \caption{\Ac{FDEP} gate}\label{fig:dft-original-fdep-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.45\linewidth}
    \centering
    \includegraphicsaspectratio[1]{dft-original-csp-symbol}
    \caption{\Ac{CSp} gate}\label{fig:dft-original-csp-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.20\linewidth}
    \centering
    \includegraphicsaspectratio[1]{dft-original-seq-symbol}
    \caption{\Ac{SEQ} gate}\label{fig:dft-original-seq-symbol}
  \end{subfigure}%
  %
  \caption{\acspg{DFT} original gates symbols}
  \label{fig:dft-original-symbols}
\end{figure}

\begin{figure}[t]
  \caption{\acpg{DFT} gates symbols}
  \label{fig:dft-symbols}
  \centering
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphicsaspectratio[0.7]{ft-symbol-fdep-gate}
    \caption{\Ac{FDEP} gate}\label{fig:dft-fdep-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphicsaspectratio[1]{ft-symbol-csp-gate}
    \caption{\Ac{CSp} gate}\label{fig:dft-csp-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphicsaspectratio[0.8]{ft-symbol-seq-gate}
    \caption{\Ac{SEQ} gate}\label{fig:dft-seq-symbol}
  \end{subfigure}%
  %
  \legend{Source: \cite{DBB1992,Boyd1992}}
\end{figure}


There are several means to analyse qualitative and quantitative analysis.
The works reported in~\cite{Merle2010,MRL+2010,MRL2011,MRL2014} use structure expressions to perform both qualitative and quantitative analysis, and the work reported in~\cite{MRL2014} summarizes other approaches.
We increment their summary (\cref{tbl:dft-conversion-te-probability}) and categorize them as:
%
\begin{itemize}
  \item
  Finding \acp{MCSeq} (qualitative analysis) is obtained by replacing \ac{DFT} gates with \ac{SFT} gates, using the text as its logical constraints.
  \Acp{MCS} in the \ac{SFT} are expanded using timing constraints from the texts into \ac{MCSeq}.
  In this case, the behaviour of spare events cannot be correctly taken into account;
  \item
  Quantitative analysis is based in converting \iac{DFT} to a well-defined formalism to calculate the probability of its top-level event.
  \Cref{tbl:dft-conversion-te-probability} shows the conversion, the calculation, and where the method is explained.
\end{itemize}

\begin{table}[t]
  \caption{\Ac{DFT} conversion to calculate probability of top-level event}
  \label{tbl:dft-conversion-te-probability}
  \centering
  \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } p{6cm} p{3.5cm} p{5.5cm} }
  %\begin{tabularx}{\linewidth}{XXX}
  \hline\noalign{\smallskip}
  \textbf{Conversion} & \textbf{Calculation} & \textbf{Explained in}\\
  \hline\noalign{\smallskip}\hline\noalign{\smallskip}
  Automaton-like structure & \ac{CTMC} & \cite{CSD2000}\\
  %
  \hline\noalign{\smallskip}
  \Ac{BN} & Inference algorithm (model-specific) & \cite{BRM+2005}\\
  %
  \hline\noalign{\smallskip}
  \Ac{SWN} (a kind of \ac{CPN}) & \ac{CTMC} & \cite{BR2004} \\
  %
  \hline\noalign{\smallskip}
  \Ac{SBDD} (a modified version of \ac{BDD}) & model-specific & \cite{TXD2011,XTD2012} \\
  \hline\noalign{\smallskip}
  \end{tabular*}
  %\end{tabularx}
\end{table}

%Structure expressions\index{structure expression} are also used in \acp{DFT}.
In~\cite{Merle2010,MRL+2010,MRL2011} fault events occur in a specific time and are instantaneous (similar to detected faults), stated through a ``date-of-occurrence'' function.
As the ``date-of-occurrence'' function is stated in continuous time, the probability of two events occurring at the same time is negligible.
In fact, useful information is obtained from the possibilities of relation in time of the occurrence of the events.
\Ac{DFT} gates' algebraic model is summarized in \cref{tbl:merle-dft-algebraic-model}.
Structure expressions\index{structure expression} are written with an algebra that has operators \ortext and \andtext, and three new operators to express events ordering: (i) \nibeforetext, (ii) \simultaneoustext, and (iii) \ibeforetext.
The \nibeforetext and the \simultaneoustext operators are similar to \ac{TFT}'s \portext and \sandtext operators, respectively.
The \ibeforetext is a composition of \nibeforetext and \simultaneoustext operators.
\Cref{tbl:date-of-occurrence-for-operators} summarizes the date-of-occurrence function for all operators.
An infinite value means the event never occurs.

\Acp{MCSeq} are extracted from canonical form of structure expressions written in \iac{DNF}.
Minimal terms are products of variables and \nibeforetext operators (the other operators can be written as combinations of \nibeforetext).
Structure expressions'\index{structure expression} reduction uses algebraic laws as, for example:
\begin{subequations}
\begin{align}
%a \lor \parsin{a \nibefore b} &= a\\
%\parsin{a \nibefore b} \lor b &= a \lor b\\
%a \land \parsin{a \nibefore b} &= a \nibefore b\\
%a \lor \parsin{a \simultaneous b} &= a\\
%a \land \parsin{a \simultaneous b} &= a \simultaneous b\\
\parsin{a \nibefore b} \lor
  \parsin{a \simultaneous b} \lor
  \parsin{b \nibefore a} &= a \lor b\\
%
\parsin{a \land \parsin{b \nibefore a}} \lor
  \parsin{a \simultaneous b} \lor
  \parsin{b \land \parsin{a \nibefore b}} &= a \land b\\
%
\parsin{a \ibefore b} \land \parsin{b \ibefore a} &= a \simultaneous b
\end{align}
\end{subequations}

\begin{table}
  \caption{Algebraic model of \ac{DFT} gates with inputs $A$ and $B$}
  \label{tbl:merle-dft-algebraic-model}
  \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c p{5.9cm} p{7.8cm} }
  \hline\noalign{\smallskip}
  \textbf{Gate} & \textbf{Algebraic model of gate's output} & \textbf{Note}\\
  \hline\noalign{\smallskip}\hline\noalign{\smallskip}
  %
  \ac{FDEP} & $A_T = T \lor A$ and $B_T = T \lor B$ & $A_T$ and $B_T$ replaces $A$ and $B$ on the resulting expression\\
  %
  \hline\noalign{\smallskip}
  \ac{CSp} &
    $\parsin{B_a \land \parsin{A \nibefore B_a}} \lor
    \parsin{A \land \parsin{B_d \nibefore A}}$ & $A$ is the active input, and $B$ is the spare. Subscripts $a$ and $d$ represents component's state---\emph{active} and \emph{dormant}, respectively, which are used on the failure distribution formulas\\
  %
  \hline\noalign{\smallskip}
  \pandtext & $B \land \parsin{A \ibefore B}$ &\\
  %
  \hline\noalign{\smallskip}
  \end{tabular*}
\end{table}

\begin{table}
  \caption{Date-of-occurrence\index{Dynamic Fault Tree!Date-of-occurrence function} function for operators defined in \cite{Merle2010}}
  \label{tbl:date-of-occurrence-for-operators}
  \centering
  \begin{tabularx}{\textwidth}{ccXXX}
    \hline\noalign{\smallskip}
    \textbf{Operator} &
      \textbf{Expression} &
      \textbf{Value if \smallskip\smallskip} $\mathbf{\func{d}{a} < \func{d}{b}}$ &
      \textbf{Value if \smallskip\smallskip} $\mathbf{\func{d}{a} = \func{d}{b}}$ &
      \textbf{Value if \smallskip\smallskip} $\mathbf{\func{d}{a} > \func{d}{b}}$\\
    \hline\noalign{\smallskip}\hline\noalign{\smallskip}
    \ortext &
      $\func{d}{a \lor b}$ & $\func{d}{a}$ & $\func{d}{a}$ & $\func{d}{b}$\\
    \andtext &
      $\func{d}{a \land b}$ & $\func{d}{b}$ & $\func{d}{a}$ & $\func{d}{a}$\\
    \nibeforetext &
      $\func{d}{a \nibefore b}$ & $\func{d}{a}$ & $+\infty$ & $+\infty$\\
    \simultaneoustext &
      $\func{d}{a \simultaneous b}$ & $+\infty$ & $\func{d}{a}$ & $+\infty$\\
    \ibeforetext &
      $\func{d}{a \ibefore b}$ & $\func{d}{a}$ & $\func{d}{a}$ & $+\infty$\\
    \hline\noalign{\smallskip}
  \end{tabularx}

\end{table}

%The work reported in~\cite{TXD2011,XTD2012} shows the top-level events probability calculation for \acp{DFT} by converting them to a simplified version, using only order-based operators.
%Such a simplified version, which is based on a modified \ac{BDD}\index{Binary Decision Diagrams} that includes an order-based operator, creates Sequential BDDs\index{Binary Decision Diagrams!Sequential} that are used to perform the probabilistic analysis.

\begin{sloppypar}
\Cref{fig:dft-example} shows an example of \ac{DFT} extracted from~\cite{MRL2014}.
It is \iac{HCAS} which is divided in four modules: trigger, CPU unit, motor section, and pumps.
The trigger is divided in two components, CS and SS.
The failure of any CS or SS, triggers a CPU unit failure.
The primary CPU (P) has a warm\footnote{Warm spare gates only differ from \ac{CSp} on the activation time.} spare (B).
The motor module fails if both M and MC fails.
In order for the pumps unit to fail, all three pumps need to fail, and the left-hand side spare gate needs to fail before (or at the same time as) the right-hand side spare gate (\pandtext gate\footnote{Although the original example uses a \pandtext gate, accordingly to the informal description, \iac{SEQ} gate would fit better.}).
The top-level event structure expression is:
\begin{align}
SYSTEM =& CS \lor SS \lor \parsin{M \land MC} \lor \\
  &\parsin{P \land \parsin{B_d \nibefore P}} \lor \parsin{B_a \land \parsin{P \nibefore B_a}} \lor \nonumber\\
  &\parsin{BP_a \land \parsin{P2 \nibefore P1} \land \parsin{P1 \nibefore BP_a}} \lor
  \parsin{P2 \land \parsin{P1 \nibefore BP_a} \land \parsin{BP_a \nibefore P2}}\nonumber
\end{align}
\end{sloppypar}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.65]{dft-example-mrl2014}
  \caption{\Ac{DFT} example}
  \label{fig:dft-example}
\end{figure}

\section{Structure expressions analysis}
\label{sec:structure-expressions-analysis}

In this section we detail the non-state-based methods to analyse structure expressions.
%As \acp{DFT} originally employs \ac{DTMC} analysis, the methods to analyse are generally state-based
%\todo{cite all dft works that are state-based}.
Another common approach to analyse fault tree is to perform structure expression analysis based on algebraic laws.
Boolean laws are well-known and are used for \acp{SFT}, temporal laws~\cite{Walker2009,WP2010} for \acp{TFT}, and the works reported in~\cite{Merle2010,MRL2011} show laws for \acp{DFT}.
An issue with algebraic laws is that in some cases, the expression needs to be expanded before it gets reduced, so reduction automation is not trivial without a theorem prover.
For example, the following \acg{TFT} structure expression needs to be expanded \cite{WP2010} before it gets reduced:
\begin{align*}
  \parsin{X \land Y} & \lor \parsin{\parsin{X \pand Y} \land Z} &\\
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} & \lor \parsin{\parsin{X \pand Y} \land Z} & \text{by \cref{law:tft-conjunctive-completion-law}}\\
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} & &\\
  X \land Y & & \text{by \cref{law:tft-conjunctive-completion-law}}
\end{align*}
%
A denotational semantics to Boolean expressions---and consequently to \ac{SFT}---is given by \acp{FBA} (\cref{sec:fba}).

There are several works with state-based analysis for \acp{FT} (\ac{SFT}, \ac{TFT}, and \ac{DFT}).
We show some of them in \cref{sec:ft-state-based-analysis}.

\subsection{State-based and temporal logic analysis}
\label{sec:ft-state-based-analysis}

The work reported in~\cite{STR2002} shows a formal approach to analyse \ac{SFT} using \ac{ITL}.
Instead of tackling basic events ordering (as in \pandtext), it consider a causal relation over a gate, as for example, a relation of a basic event and a higher-level intermediary event.

For \acp{TFT}, the works reported in~\cite{MPW2010,MWP2012} shows an inverse solution.
They map \acp{FSM}\adnote{Cite FSM} to \pandora logic, then verify system properties.
They show that such a mapping simplifies expressions reduction, thus improving performance on the analysis.

Although there is formal modelling for \acp{DFT}, most of the works are state-based.
The work reported in~\cite{CSD2000} shows a formal model for \ac{DFT} analysis.
It models \acap{DTMC} in \ac{Z}, as well as each \ac{DFT} element (basic events and gates).
The analysis uses a quantifier on states of the resulting \aca{DTMC} automaton.
The work reported in~\cite{GD1997} shows a methodology to perform a modular analysis of \acp{DFT} based on \ac{BDD} and \aca{DTMC}.
As \ac{DFT} extends \ac{SFT}, it identifies subtrees that are purely \ac{SFT} and uses \ac{BDD}, otherwise, it performs \aca{DTMC} analysis.
Still on the state-based approaches, the work reported in~\cite{SLD2011} maps \acp{DFT} to \ac{HLPN} to analyse false alarms.

%The work reported in~\cite{LR1998} uses a formal approach using \ac{FSM} to generate fault trees automatically from system models.

In the following we show specific methods that are designed to reduce structure expressions.
In essence, the methods are very similar.
Structure expressions for \acp{SFT} can be reduced using \acp{BDD} (\cref{sec:bdd}), \acp{TFT} can be reduced using \acp{TDT} (\cref{sec:dependency-trees}), and the works reported in~\cite{TXD2011,XTD2012} show the analysis of standby systems (\ac{CSp} gates) using \acp{SBDD} (\cref{sec:sbdd}).

\subsection{\Aclp*{BDD}\index{Binary Decision Diagrams}}
\label{sec:bdd}

\Acp{BDD} are directed acyclic graphs that represents a Boolean expression.
They are still referred to as \ac{BDD}, but the more spread version is the \ac{ROBDD}, which is an optimisation.
There are two ways to generate \iac{BDD} for an expression: (i) derive a diagram from the truth-table, or (ii) expand the paths based on Shannon's method (described in \FThandbook).

To demonstrate the expressiveness of \iac{BDD}, \cref{fig:bdd-diagram-for-a-truth-table} shows a diagram for a truth table with three variables (\cref{tbl:bdd-truth-table-with-three-variable}).
In a node, when a path is chosen, the variable of the node assumes the edge value.
For example, the top-level node variable of \cref{fig:bdd-diagram-for-a-truth-table} is $A$.
Following the right-hand side of the node, all leaf nodes corresponds to the lines of the truth-table that $A$ has ``0'' values (the first four lines).
The symbol nodes are replaced by the values assumed by a specific formula.

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.5]{bdd-diagram-for-a-truth-table}
  \caption{A diagram for a truth table}
  \label{fig:bdd-diagram-for-a-truth-table}
\end{figure}

\begin{table}[t]
  \caption{Truth table for a formula outputs with three variables (A, B, and C)}
  \label{tbl:bdd-truth-table-with-three-variable}
  \centering
  {\footnotesize
  \begin{tabular}{cccc}
    \hline\noalign{\smallskip}
    \textbf{A} & \textbf{B} & \textbf{C} & \textbf{Formula}\\
    \hline\noalign{\smallskip}\hline\noalign{\smallskip}
    0 & 0 & 0 & a \\
    0 & 0 & 1 & b \\
    0 & 1 & 0 & c \\
    0 & 1 & 1 & d \\
    1 & 0 & 0 & e \\
    1 & 0 & 1 & f \\
    1 & 1 & 0 & g \\
    1 & 1 & 1 & h \\
    \hline\noalign{\smallskip}
  \end{tabular}
  }
\end{table}

Following Shannon's method, we choose a variable, and build the lower level \ac{BDD} assuming the edge value for the chosen variable.
In the remainder of the path, the variable's value is unchanged.
For example, the expression $A \lor \parsin{\lnot B \land C}$ has value ``0'' on lines $a$ and $c$, and value ``1'' on the other lines.
Choosing variable $A$ first, then $B$ and $C$, the resulting \ac{BDD} with the binary values nodes (called sink nodes ``false'' and ``true'') for this formula is depicted in \cref{fig:bdd-diagram-for-example-expression}.
Starting from the top-level node $A$, the formula expressed by the \ac{BDD} is true if $A$ assumes value true.
If $A$ is false, and $B$ is false, the expression is only true if $C$ is true.

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.25]{bdd-diagram-for-example-expression}
  \caption{\Iacs{BDD} for the expression $A \lor \parsin{\lnot B \land C}$}
  \label{fig:bdd-diagram-for-example-expression}
\end{figure}

\Cref{fig:bdd-diagram-for-example-expression} is \iac{ROBDD}.
To be considered \iac{ROBDD}, the \ac{BDD} must meet the following constraints~\cite{BRB1990}:
%
\begin{itemize}
  \item the variables are assigned a constant ordering;
  \item every path to sink nodes visit the input variables in ascending order;
  \item each node represents a distinct logic function.
\end{itemize}
%
The size of \iac{ROBDD} for a given expression depends on the chosen variable ordering.
The work reported in~\cite{Rudell1993} shows initial findings on variable order, and the work reported in~\cite{KH2014} shows heuristics to improve the performance for optimal order search.

For \acp{SFT} the evaluation of \iac{BDD} is the calculation of the probability of the paths ending in \emph{true}.
For the example of \cref{fig:bdd-diagram-for-example-expression}, the probability of the expression is obtained from the formula: $\probability{A \lor \parsin{\lnot A \land \lnot B \land C}}$. Note that the formula in the probability calculation is different from the formula that originated the diagram.

\subsection{\Acl{TDT}}
\label{sec:dependency-trees}

\Acf{TDT} is a hierarchical acyclic graph of expressions that shows all possible cut sequences for any given set of events.
It is a graphical view of a \ac{TTT}.
At the top of \iac{TDT} are the variables, that is, the single events that occur in an expression.
On the lower levels are the increasingly complex expressions.
Each node represents \iac{MCSeq}.
\Cref{fig:simple-dependency-tree} shows \iac{TDT} with all nodes for variables $X$ and $Y$.

\begin{figure}
  \centering
  \includegraphicsaspectratio[0.5]{simple-dependency-tree}
  \caption{\acs*{TDT} for variables $X$ and $Y$}
  \label{fig:simple-dependency-tree}
\end{figure}

The reduction of a structure expression is given by activation (true values) of nodes.
If a node is active (true), then all child nodes are also active; the converse is also true: if all node's children are active, then it is also active.
The reduced expression is given by the \ac{DNF} created with the expressions of active higher level nodes.
To reduce the formula given on the beginning of this section, the expression $\parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z}$, we create the \ac{TDT} depicted in \cref{fig:dependency-tree-reduction}.
Nodes marked as ``1'' are those \acp{MCSeq} given directly by the formula.
Nodes marked as ``2'' are child nodes of the ``1'''s nodes, and so forth.
The node of the expression $\parsin{\parsin{X \pand Y} \land Z}$ is a grandchild of $X \land Y$, thus it is not necessary.
The final expression if obtained by the active higher level node, which is $X \land Y$.

\begin{figure}
  \centering
  \includegraphicsaspectratio[0.7]{dependency-tree-reduction}
  \caption{\acs*{TDT} for the formula $\parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z}$}
  \label{fig:dependency-tree-reduction}
\end{figure}

\subsection{\Aclp*{SBDD}\index{Sequential Binary Decision Diagrams}}
\label{sec:sbdd}

\Ac{SBDD} is an extension of \ac{BDD} to tackle ordering of events in \acp{DFT} for \ac{CSp} and \ac{WSp} gates.
Ordering of events in \ac{CSp} gates~\cite{XTD2012} is slightly different compared to \ac{WSp}~\cite{TXD2011}.
A backup system in \ac{CSp} gets activated slower than in \ac{WSp}, which implies that there are less failure possibilities in \ac{CSp}, but its the readiness is lower than in \ac{WSp}.
\Ac{SBDD} adds a new node kind that contains a binary operation of fault events, which allows to express the ordering of events.
One kind of operation expresses the slowness of the relation of the fault events of \ac{CSp}, and another one expresses the readiness of the \ac{WSp}.
The latter semantics is similar to the semantics of \pandtext and \ibeforetext (combined with \andtext) gates.

\Ac{SBDD} creation has two steps: (i) \ac{CSp} or \ac{WSp} \ac{DFT} conversion, and (ii) \ac{SBDD} model generation.
In (i), it is a \ac{DFT}-to-\ac{DFT} conversion.
\Ac{CSp} and \ac{WSp} gates are converted to a new, but equivalent \ac{DFT} without \ac{CSp} and \ac{WSp} gates, where the operations appear as basic events and are combined using other gates.
In (ii), the \ac{SBDD} model is created.
The model may contain nodes that are contradictory as, for example, nodes that assumes that an event $A$ is false and a binary operation that contains $A$ is true.
This step ends when all contradictions are removed.
The evaluation is similar to \acg{BDD}: each path ending in true is a minimal term in the \ac{DNF} that may contain one of the binary operations and individual events.


\section[Free Boolean Algebras]{\Aclp*{FBA}}
\label{sec:fba}
\index{Boolean Algebra!Free}

Another means to analyse \acp{SFT} is to use \iac{FBA} to perform set-theoretical operations (intersection, difference, etc.) to reduce expressions.
In this section we briefly present \ac{FBA} theory and elements.

Instead of using an axiomatic definition of Boolean\index{Boolean Algebra} algebra, we follow its set-theoretical definition, as shown in~\cite[pp. 254--258]{Stoll1979} and~\cite[pp. 8--11]{GH2009}.
This definition is more elegant because it represents a Boolean\index{Boolean Algebra} algebra as an algebra of sets and does not rely on axioms (which can be misleading, case there is a unfounded axiom).

\begin{Def}[Boolean Algebra]
\label{def:boolean-algebra}
A Boolean algebra is defined as a triple $\anglesin{B, \inter, -}$, where $B$ is a set with at least two elements, $\inter$ is the intersection (also called meet or \emph{infimum}) and $-$ is the complement (also called negation).
\end{Def}
%
\noindent The other Boolean elements (union, $\bot$, and $\top$) are derived from the other two operators:
\begin{description}
  \item[$\union$] is the union (also called join or \emph{supremum}): $A \union B = -(-A \inter -B)$
  \item [$\bot$] is the bottom (also called zero): $\bot = A \inter -A$
  \item [$\top$] is the top (also called unit): $\top = -\bot$
\end{description}

\begin{sloppypar}
\Iacl{FBA} is defined from a set $E$ of generators.
A generator can be represented as a proposition in statement calculus~\cite[p. 274]{Stoll1979}.
For example, ``valve A is stuck closed'' and ``motor X is malfunctioning'' are valid statements.
A \acl{FBA} is constructed from $\powerset{E}$, where $\powersetop$ is the power set\index{Power Set}.
Note that if $E$ has $n$ symbols, $\powerset{E}$ has $2^{n}$ elements, called \emph{atoms}\index{Boolean algebra!atoms} of a finite Boolean algebra.
For the two statements above, the atoms\index{Boolean algebra!atoms} are:
\begin{itemize}
  \item ``Valve A is stuck closed'' and ``motor X is malfunctioning''
  \item ``Valve A is stuck closed'' and ``motor X is \emph{not} malfunctioning''
  \item ``Valve A is \emph{not} stuck closed'' and ``motor X is malfunctioning''
  \item ``Valve A is \emph{not} stuck closed'' and ``motor X is \emph{not} malfunctioning''
\end{itemize}
Such Boolean algebra has $2^{2^{n}}$ formulas~\cite[p. 261]{GH2009}.
For example, if $E = \setsin{a,b}$, then $\powerset{E} = \setsin{ \setsin{}, \setsin{a}, \setsin{b}, \setsin{a,b} }$, hence the Boolean algebra generated by $E$ contains sixteen ($2^{2^{2}}$) formulas:
$\setsin{}$,
$\setsin{\setsin{}}$,
$\setsin{\setsin{}, \setsin{a}}$,
$\setsin{\setsin{}, \setsin{b}}, \ldots$,
$\setsin{\setsin{a}, \setsin{a,b}}, \ldots$,
$\setsin{\setsin{b}, \setsin{a,b}}, \ldots$,
$\setsin{\setsin{}, \setsin{a}, \setsin{b}, \setsin{a,b}}$.
\end{sloppypar}

The Boolean algebra $B$ can be inductively defined using some constructs.
%
\begin{Def}[Inductive \acl{FBA}]
\label{def:inductive-fba}
Let $s$ be a statement, then:
%
\begin{subequations}
\begin{align}
\var s = \setsin{X | s \in X} & \implies \var s \in B & \text{(variable)}\\
X \in B & \implies -X \in B                           & \text{(complement)}\\
X \in B \land Y \in B & \implies X \inter Y \in B     & \text{(intersection)}
\end{align}
\end{subequations}
%
\end{Def}

The characterisation of a ``free'' Boolean algebra comes from that, for some valuation function $a$, some of the formulas evaluates to ``1''.
Given a function $p:B \cartesian \setsin{0,1} \rightarrow B$, such that:
%
\begin{equation}
p\parsin{i,j} =
\begin{cases}
  i & \quad j = 1\\
  -i & \quad j = 0
\end{cases}
\end{equation}

\begin{Lem}[Free generators (valuation)]
\label{lem:boolean-algebra-free-generators-valuation}
Let $F$ be a finite set, such that $F \subseteq E$, and $a: F \rightarrow \setsin{0,1}$, a necessary and sufficient condition for a set $E$ of generators of a Boolean algebra B to be free is then:
%
\begin{equation}
\bigwedge_{i \in F} p\parsin{i, a \parsin{i}} \neq 0
\end{equation}
\end{Lem}
\begin{proof}
See~\cite[p. 258]{GH2009}.
\end{proof}


Essentially, \cref{lem:boolean-algebra-free-generators-valuation} states that there is no relation between generators, such as $a = -b$.

\begin{Lem}[Free generators (algebraic)]
Let $i$ and $j$ be statements, such that $i,j \in E$, hence from \cref{def:inductive-fba,lem:boolean-algebra-free-generators-valuation} it is necessary and sufficient that:
%
\begin{subequations}
\begin{align}
\var i = \var j & \iff i = j\\
\var i & \neq - \var j\\
-\var i & \neq \var j
\end{align}
\end{subequations}
%
\end{Lem}
%
\begin{proof}
See~\cite[p. 4]{Huffm2010}
\end{proof}

\section[Using NOT operator in fault trees]{Using NOT operator in \aclp*{FT}}
\label{sec:not-operator}

Although the \FThandbook introduces several gates, the vast majority of \ac{SFT} analysis would fit in \acp{FT} with only \andtext and \ortext gates (coherent \acp{FT})\index{Fault tree!coherent}.
Qualitative analysis requires the reduction of the structure expression of \acp{FT} and, when NOT gates are present (non-coherent \acp{FT}\index{Fault Tree!non-coherent}).
Such a reduction can cause the interpretation of failure logic to be misled~\cite{Andrews2001,Oliv2006,AB2003,CCR2008,Vaurio2016}.
The work reported in~\cite{Oliv2006} shows three funny examples of this kind of problem, and the works reported in~\cite{Andrews2001,Oliv2006,CCR2008} shows how to solve it using \acp{BDD}.
In the following we show: (i) the second example presented in~\cite{Oliv2006}, which highlights the problem when using NOT gates (\cref{sec:non-coherent-misleads-example}), and (ii) the second example presented in~\cite{Andrews2001}, which defends the usefulness of NOT gates in a multitasking system (\cref{sec:non-coherent-usefulness}).

Negated events in non-coherent analysis are in fact the working state of a component.
The probability contribution of a negated basic event is close to 1.
The problem with non-coherent \acp{FT} is that its analysis can cause impossible situations.
The general formula to identify coherency is given in~\cite{Andrews2001,CCR2008} in terms of a structure function\index{structure expression!function}.

\begin{Def}[\ac{FT} Coherency]
\label{def:ft-coherency}
Let $\ftcoherency{x}:B^n \rightarrow B^1$ be a binary function of a vector of binary variables, such that $x = \squaresin{x_1, x_2,\ldots,x_n}$, representing the states of $n$ system's components.

A binary structure function $\ftcoherency{x}$ is coherent if all the following hold:
\begin{enumerate}
  \item $\ftcoherency{x}$ is monotonic (non-decreasing) in each variable;
  \item Each $x_i$ is relevant, which means that $\ftcoherency{x}\replace{x_i}{1} \neq \ftcoherency{x}\replace{x_i}{0}$ for some vector $x$.
\end{enumerate}
\end{Def}
%
\noindent where $B^1 = \setsin{0,1}$, $B^n = B^{n-1} \cartesian B^1$, $x_i = 1$ implies that component $i$ is failed, and $\ftcoherency{x} = 1$ implies the system is failed.
For $y = \squaresin{y_1,y_2,\ldots,y_n}$, monotonicity of $\ftcoherencyop$ means that for \emph{all} $i$, $x_i \ge y_i$ ($y_i = 1 \implies x_i = 1$), and for \emph{some} $i$, $x_i > y_i$ ($x_i = 1$ and $y_i = 0$).
Variable replacement ($\replace{a}{b}$) is as usual:
$\ftcoherency{x}\replace{x_i}{a} = \squaresin{x_1, \ldots, x_{i-1}, a, x_{i+1}, \ldots, x_n}$

\subsection{Non-coherent \ac{FT} misleads}
\label{sec:non-coherent-misleads-example}

In this section we illustrate---with the second example detailed in~\cite{Oliv2006}---how non-coherent \ac{FT} misleads.

A college student who wants to visit her mother in another city has two options: wake up early ($x_3$) and take ride with a friend ($x_1$), or wake up late ($\lnot x_3$) and take the metro ($x_2$).
The top-event failure is ``fail to visit mother'' with expression $S = \parsin{x_1 \land x_3} \lor \parsin{x_2 \land \lnot x_3}$.
Its \acl{FT} is depicted in \cref{fig:non-coherent-ft-example}.
It is clear that the structure function is non-coherent in $x_3$ accordingly to \cref{def:ft-coherency}: $\ftcoherency{1,1,x_3}\replace{x_3}{1}=\ftcoherency{1,1,x_3}\replace{x_3}{0}$.

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.55]{non-coherent-ft-example}
  \caption{Non-coherent \ac{FT} college student's example}
  \label{fig:non-coherent-ft-example}
\end{figure}

The problem with this tree is the interpretation of the qualitative results.
One of the possibilities in this scenario is that the college student would take a ride \andtext take the metro ($x_1 \land x_2$).
Quantitatively, the analysis of the probabilities shows that this result is not negligible, but its interpretation is impossible.

\subsection[Usefulness of NOT gates in FTA]{Usefulness of \nottext gates in \ac{FTA}}
\label{sec:non-coherent-usefulness}

In this section we show the second example detailed in~\cite{Andrews2001}.

The gas detection system\index{gas detection system} depicted in \cref{fig:gas-detection-system} has two sensors $D_1$ and $D_2$ which are used to detect a leakage in a confined space.
When a leakage is detected, these sensors send a signal to the logic control unit $LU$, which performs three tasks:
%
\begin{enumerate}
  \item shuts-down the main system (process isolation) by de-energizing relay $R_1$;
  \item inform the operator of the leakage by lamp and siren $L$;
  \item deactivates all possible ignition sources, which is the interruption of power supply by de-energizing relay $R_2$.
\end{enumerate}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.45]{gas-detection-system}
  \caption{Gas detection system}
  \label{fig:gas-detection-system}
\end{figure}

The system\index{gas detection system} is in fail state if does not perform one of these three tasks.
The \acl{FT} that represents this generic failure is depicted in \cref{fig:ft-generic-failure-gas-detection-system}.
$G_1$, $G_2$, and $G_3$ are subtrees that represents the three tasks ``Operator not informed'', ``Process shut-down fails'', and ``Power supply not isolated'', respectively.
All three tasks will fail if their respective main component fails ($L$, $R_1$, and $R_2$) or there is no signal from $LU$ ($LU$ fails or both $D_1$ and $D_2$ fail).
The structure expressions for the subtrees are:
%
\begin{align*}
  G_1 & = L \lor LU \lor \parsin{D_1 \land D_2}\\
  G_2 & = R_1 \lor LU \lor \parsin{D_1 \land D_2}\\
  G_3 & = R_2 \lor LU \lor \parsin{D_1 \land D_2}
\end{align*}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[1]{ft-generic-failure-gas-detection-system}
  \caption{\ac{FT} for a generic failure in the gas detection system}
  \label{fig:ft-generic-failure-gas-detection-system}
\end{figure}

Analysing in more detail, there are different degrees of system failure.
There are eight outcomes (given the three tasks) and the most critical one is when both process shut-down ($G_2$) and power supply isolation ($G_3$) fail keeping energized upon a leakage, and the operator is not informed ($G_1$), but the operator information system is working (lamp and siren are off, but they are operational).
The coherent \ac{FT} of this outcome is depicted in \cref{fig:outcome-4-coherent-ft}.
The minimal cut sets obtained from this will be: $\setsin{R_1, R_2}$, $\setsin{D_1, D_2}$, and $\setsin{LU}$.

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.5]{outcome-4-coherent-ft}
  \caption{\emph{Coherent} \ac{FT} for the most critical outcome of the gas detection system}
  \label{fig:outcome-4-coherent-ft}
\end{figure}

Quantification of the coherent \ac{FT} will overestimate the probability of the critical outcome unless the part of the system that is working (lamp and siren $L$, $LU$, and sensors $D_1$ and $D_2$) is taken into account.
The non-coherent \ac{FT} with the working part is shown in \cref{fig:outcome-4-non-coherent-ft}.

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.65]{outcome-4-non-coherent-ft}
  \caption{\emph{Non-coherent} \ac{FT} for the most critical outcome of the gas detection system}
  \label{fig:outcome-4-non-coherent-ft}
\end{figure}

If the operator \emph{can} be informed, then cut sets $\setsin{D_1, D_2}$ and $\setsin{LU}$ could not have occurred (see \cref{fig:ft-generic-failure-gas-detection-system}), thus the correct qualitative analysis should consider only cut set $\setsin{R_1,R_2}$.
Reducing the expressions of the non-coherent \ac{FT} (\cref{fig:outcome-4-non-coherent-ft}), we obtain the structure expression: $\lnot L \land \lnot LU \land R_1 \land R_2 \land \parsin{\lnot D_1 \lor \lnot D_2}$.
The approximation for this expression, removing the negated events, gives the cut set $\setsin{R_1,R_2}$, which gives a correct quantitative analysis.

%The examples of the usefulness of NOT gates in \ac{FTA} are one of the following, but not limited to: (i) generally, when the probability of negated events are close to $1$, (ii) exclusive states systems as, for example, non-repairable phased mission systems.

%Here we show the example of a simplified electric network (\cref{fig:simplified-electric-network-diagram}), presented in~\cite{CCR2008}.
%Two loads, pumps, $P_1$ and $P_2$ are supplied through circuits $CP_1$ and $CP_2$ by two external lines $D_1$ and $D_2$ through bars $B_1$ and $B_2$.
%The bars can be connected by switch $I$.
%Failures in $B_1$ and $B_2$ are not considered.
%In normal conditions, $I$ is open and is automatically closed in case of a failure of a line.

%\begin{figure}[t]
%  \centering
%  \includegraphicsaspectratio[0.3]{simplified-electric-network-diagram}
%  \caption{Simplified Electric Network}
%  \label{fig:simplified-electric-network-diagram}
%\end{figure}

%Suppose we need to calculate the following probabilities:
%\begin{description}
%  \item[$TOP_1$] = $P_1$ unavailable \emph{or} $P_2$ unavailable;
%  \item[$TOP_2$] = $P_1$ unavailable \emph{and} $P_2$ unavailable;
%  \item[$TOP_3$] = $P_1$ unavailable \emph{and} $P_2$ \emph{available};
%  \item[$TOP_4$] = Only one pump unavailable given only one electric line available.
%\end{description}

%We can construct two independent fault trees, $TP_1$ and $TP_2$, for the unavailability of $P_1$ and $P_2$ as: $TP_1 = P_1 \lor CP_1 \lor \parsin{D_1 \land \parsin{I \lor D_2}}$ and $TP_2 = P_2 \lor CP_2 \lor \parsin{D_2 \land \parsin{I \lor D_1}}$.
%$TOP_1$ and $TOP_2$ generate coherent fault trees, using $TP_1$ and $TP_2$.

\section{Systems' nominal model and faults injection}
\label{sec:faults-injection}

Control system modelling using \simulink block diagrams~\cite{MathWorks2010} is recommended in~\cite{Nise1992} and have been used by our industrial partner.
%We follow this recommendation in this work.
It is a complementary tool of \matlab~\cite{MathWorks2010c}.
% ## TODO: melhorar essa frase
In fact, it works as a graphical interface to \matlab.
A \simulink model has blocks and connections between these blocks, named signals.
Each block has inputs and outputs and an internal behaviour expressed by its mathematical formula, which defines a function of the inputs for each output.
There are many predefined blocks in the tool.
It is also possible to create new blocks or use subsystems that encapsulate other blocks.
A simulation adds extra parameters to a block diagram, like elapsed time and time between states.
The elapsed time of a simulation is an abstraction for the quantity of possible simulation states and the time between states is related to the lowest common denominator of the sample time.
Some components define different sample times, depending on their mode of operation.
Usually, the value for this property is set to \textsim{auto}, allowing \simulink to choose a proper value automatically.

% \begin{figure*}[!t] \centering
%     \includegraphicsaspectratio[0.8]{acsBlockDiagrams}
%     \caption{\textpt{Diagrama em blocos do ACS fornecido pela
%     \EMBRAER.}\texten{Block diagram of the ACS provided by \EMBRAER}}
%     \label{fg:acsBlockDiagrams}
% \end{figure*}
\begin{figure}[t] \centering
  \includegraphicsaspectratio{acsBlockDiagrams}
  \caption{Block diagram of the ACS provided by \EMBRAER (nominal model)}
  \label{fg:acsBlockDiagrams}
\end{figure}

Nowadays, control systems are usually composed of an electromechanical part and a processor.
\Cref{fg:acsBlockDiagrams} shows the components of a feedback system~\cite{AM2008} which was provided by \EMBRAER.
In this system, the feedback behaviour is given by the \textsim{Controller} (1), \textsim{Actuator} (2) and \textsim{Sensor} (3). A command is received by the \textsim{Controller}, which sends a signal to the \textsim{Actuator} to start its movement.
The \textsim{Sensor} detects the actual position of the \textsim{Actuator} and sends it back to the \textsim{Controller}, which adjusts the given command to achieve the desired position. This loop (feedback) continues until the desired position given by the original command is reached.

\begin{figure}[t] \centering
\includegraphicsaspectratio[0.6]{blockDiagramMonitorInternals}
  \caption{Internal diagram of the monitor component (\cref{fg:acsBlockDiagrams}~(A)).}
  \label{fg:blockDiagramMonitorInternals}
\end{figure}

\Cref{fg:blockDiagramMonitorInternals} shows the internal elements of the monitor component (\cref{fg:acsBlockDiagrams}~(A)), which is used as case study in \cref{sec:case-study} to illustrate our
strategy.
The outputs of the hardware elements are annotated with \textsim{HW}, which are the two power sources and an internal component of the monitor (switch command).

\todo{Verificar se as frases tiradas da introdução se adequam melhor aqui.}
%As hardware components are susceptible to fault injection, this strategy consists of: (i) a process that represents the nominal behaviour (without fault injection), (ii) a process that represents the erroneous behaviour with all possibilities of faults, due to fault injection, and (iii) an observer process to compare the nominal behaviour with the erroneous behaviour.
%To create failure logic, we abstract the fault traces by not considering events ordering.


To perform a formal verification in a \simulink system design model, the work reported in~\cite{JMS+2011} translates a \simulink model to the \ac{CSPm} language.
%
The resulting \ac{CSPm} code is then used to check if it meets functional requirements also encoded in \ac{CSPm}.

In our previous work, reported in~\cite{DM2012}, we modified such a translation to perform fault injection using hardware annotations allowing a subsystem or part to ``break'' randomly.
%
We designed a \ac{CSPm} process to act as an observer, watching outputs of the nominal version and comparing to the outputs of the ``breakable'' version (with injected faults) of the system.
%
When the \ac{CSPm} process of the model and the observer are loaded into the \acs{fdr} model-checker, counter-examples are generated for each output that differs from the nominal model, thus obtaining a \emph{sequence} of injected faults combinations that leads to the unexpected output, which are indeed \emph{fault traces}.

In what follows, injected faults and the top-level failure have generic names based on the names of the \simulink model blocks.
It is out of the scope of~\cite{DM2012} to define event names.

For the \simulink model shown in~\cref{fg:blockDiagramMonitorInternals}, some representative fault traces are:

\begin{snippetcspm}[1]
TRACE 1:
failure.Hardware.N04_RelationalOperator.1.EXP.B.true
failure.Hardware.N04_RelationalOperator.1.ACT.B.false
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 2:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.true
failure.Hardware.N04_RelationalOperator.1.ACT.B.false
out.1.OMISSION

TRACE 3:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 4:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
out.1.OMISSION

TRACE 5:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
out.1.OMISSION

TRACE 6:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 7:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true

TRACE 8:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
\end{snippetcspm}
%
where \verb$N04$ is the subsystem name of the monitor in the \simulink diagram, \verb$MonIn1$ (first input of the monitor), \verb$MonIn2$ (second input of the monitor), and \verb$RelationalOperator$ (switcher controller) are the names of the hardware components in the \simulink diagram.

We only show eight counter-examples, but \acs{fdr} generates a total of 64 counter-examples for this system.
The other counter-examples are similar to the traces shown with different internal events.

To reuse \ac{hiphops}, which is based on \acp{SFT}, each fault trace is abstracted as a conjunction (\andtext combination of the inner events), and the several conjunction-based fault events are combined using \ortext\ s (disjunctions).
%
The result of the combination is a Boolean expression that represents the conditions that cause an undesirable output, the failure logic of the model.

If the failure logic is obtained for a whole system, it is indeed the structure expression\index{structure expression} of a \acl{FT} for a general failure as the top-level event.
Although it is possible to obtain the failure logic for a larger system, it may be impractical due to state-space explosion in \ac{CSPm} model analysis.
Thus it should be used for components and subsystems or small systems following \ac{hiphops} compositional structure.
%
%Failure logic is used as the input of the strategy presented in~\cite{MJG+2010}.
Using failure logic as subsystem annotations in~\cite{PMS+2001}, it is possible to obtain structure expressions\index{structure expression} for a larger system.
It is worth noting that the goal of the work reported in~\cite{DM2012} was to connect with \ac{hiphops}, which is based on static \aclp{FT}.
But we already knew that we had a richer fault modelling information than that presented in~\cite{DM2012} because we abstracted traces (which already capture fault events ordering) to create propositions (any fault events order combination).
%In the works reported in~\cite{APR+2013,AFP+2013,AIP+2014}, fault modelling was used to verify if a system model is fault tolerant with respect to undesirable critical failures.
%The faults were explicitly modelled, and the analysis starts after the preliminary analysis of faults.
%Instead of modelling faults directly in a model, it is possible to inject faults without explicit fault modelling.
%This allows the system to break in hardware parts.

%Each injected fault appears on the trace as two events: the expected (\verb$EXP$) value of the nominal system and the actual (\verb$ACT$) value used on the breakable system.
%For example, in \verb$TRACE 1$, the expected output of the switcher (\verb$N04_RelationalOperator$) is true, but the actual value is false.

To show how these traces become failure logic, let us abbreviate fault names as:
%
\begin{snippetcspm}[2]
A = failure.Hardware.N04_MonIn1.1
B = failure.Hardware.N04_MonIn2.1
S = failure.Hardware.N04_RelationalOperator
\end{snippetcspm}
%
So, for each trace, we obtain an expression:
\begin{align*}
\mathtt{TRACE\,1} &= S \land B\\
\mathtt{TRACE\,2} &= B \land S\\
\mathtt{TRACE\,3} &= A \land B\\
\mathtt{TRACE\,4} &= B \land A\\
\mathtt{TRACE\,5} &= A \land S\\
\mathtt{TRACE\,6} &= A \land S \land B\\
\mathtt{TRACE\,7} &= A \land B \land S\\
\mathtt{TRACE\,8} &= B \land A \land S
\end{align*}

And we combine them as a single Boolean expression:
%
$\mathtt{TRACE\,1} \lor \mathtt{TRACE\,2} \lor \mathtt{TRACE\,3} \lor \mathtt{TRACE\,4} \lor \mathtt{TRACE\,5} \lor \mathtt{TRACE\,6} \lor \mathtt{TRACE\,7} \lor \mathtt{TRACE\,8}$, %
which by a traditional Boolean reduction strategy results in:
%
\[(A \land B) \lor (S \land (A \lor B))\]

\begin{sloppypar}
The above expression is exactly the same failure logic expression provided by \EMBRAER if we use the following association (\cref{tbl:acsAnnotations}):
\begin{align*}
A &= \text{LowPower-In1}\\
B &= \text{LowPower-In2}\\
S &= \text{SwitchFailure}
\end{align*}
\end{sloppypar}

\begin{table}[t]
\renewcommand{\arraystretch}{1.3}
\caption{Annotations table of the ACS provided by \EMBRAER}
\label{tbl:acsAnnotations}
\centering
\begin{tabularx}{\linewidth}{|c|c|c|X|}
\hline
\bfseries Component & \bfseries Deviation & \bfseries Port & \bfseries Annotation \\
\hline
PowerSource & LowPower & Out1 & PowerSourceFailure\\
\hline
Monitor & LowPower & Out1 & (SwitchFailure AND (LowPower-In1 OR LowPower-In2)) OR (LowPower-In1 AND LowPower-In2) \\
\hline
Reference & OmissionSignal & Out1 & ReferenceDeviceFailure OR LowPower-In1\\
\hline
\end{tabularx}
\end{table}

Note that when we combine each fault with \andtext\ s, we lose the information about order\footnote{In our previous work we designed the observer to ignore order as well, by making similar traces---with different ordering---the same size. Here we modified the observer specification to make similar traces with different sizes.}: $S \land B$ and $B \land S$ are equal, due to the commutative law of Boolean expressions.

Our strategy finds fault combinations $S$ and $B$ (in the sense of $S$ occurring before $B$) as well as $B$ and $S$ (in the sense of $B$ occurring before $S$) but abstracts this ordering information obtaining $B$ and $S$, which is equivalent to $S$ and $B$ in Boolean Algebra.
%
If $A$ fails before $S$, the system fails because it should switch to $B$, but the switcher is in a faulty state.
%
On the other hand, if $S$ fails before $A$, the switcher fails because it inadvertently switched to $B$ when $A$ was still operational.
%
When $A$ fails, nothing changes and the output of the system is obtained from $B$.

We also employed the strategy proposed in the work~\cite{DM2012} in another case study and obtained a weaker failure expression (that is, our expression considers more cases).
The failure expression provided by the engineers of our industrial partner was stronger because they considered that one component has a very low probability of failure and removed it from the failure analysis.
Although acceptable, it may cause incorrect analysis.
Our strategy avoids this kind of issue by being completely systematic.

\section{Isabelle/HOL}
\label{sec:isabelle}

\input{isabelle-hol-basic/output/document/Basic}

\part{Results}
\label{part:results}

\todo{Use BA1993 to minimise the gap between systems models and fault trees. Also: MCS+1999}

\chapter{A free algebra to express structure expressions of ordered events}
\label{sec:strategy}

\todo{Explain the interaction of (i) fault-injection, (ii) theorem proving, and (iii) symbolic execution.}

There are some hints to use sets of sequences mixed with sets of variables (as in \acp{SFT}) as shown in~\cite{TD2004}.
Differently, we use a uniform representation of sets of sequences.
Considering performance, instead of using the sets of sequences directly, we use a symbolic representation using propositions for systems and \acp{FT}.
\todo{Elaborate this paragraph}

\todo{dizer que nossa abordagem usa a abordagem similar à de expressões de estrutura, mas que tem o objetivo de dar uma semântica denotacional baseada em conjuntos}

Recall from \cref{sec:time-relations,sec:fault-trees} that fault events are independent on one another if the events are not susceptible to a common cause.
The set-theoretical abstraction of structure expressions\index{structure expression} for \acp{SFT}~\cite[pp. VI-11]{VGR+1981} is very close to \iac{FBA}\index{Boolean Algebra!Free}, where each generator in \acp{FBA}\index{Boolean Algebra!Free} corresponds to a fault event symbol in \aclp{FT}.
In \acp{FBA}\index{Boolean Algebra!Free}, as generators are ``free'', they are independent on one another and Boolean formulas are written as a set of sets of possibilities, which are similar to the structure expressions\index{structure expression} of \acp{SFT}.
%This is equivalent to the disjunctive normal form, where each set is a minterm (conjunction) and the formula itself is the disjunction of minterms.

The set of sets for \acp{FBA}\index{Boolean Algebra!Free} are the denotational semantics for Boolean algebras.
We use the concept of generators to define the denotational semantics of \ac{algebra} using a set of lists without repetition (distinct lists).
The choice of lists is because this structure inherently associates a generator to an index, making implicit the representation of order.
These lists are composed by non-repeated elements (distinct lists) because the events in \aclp{FT} are non-repairable, thus they do not occur more than once.

This list representation is different from the Sequence Number function used in~\cite{WP2009,Walker2009}, but is related to the concept that there should be no gaps between consecutive events occurrence.
It is different because order 0 (zero) in~\cite{WP2009,Walker2009} means non-occurrence.
It may cause a discontinuity because 0 to 1 is different of 1 to 2.
In \acp{FBA}\index{Boolean Algebra!Free} the non-occurrence of an event is just the absence of the event, thus we use the same representation of non-occurrence in \ac{algebra} to avoid this discontinuity.

%The work reported in~\cite{MRL2011,Merle2010} uses continuous time and the relations of events is obtained from a ``date-of-occurrence'' function.
%It is related to the detection of an event as discussed in~\cref{sec:time-relations,sec:structure-expressions} and the useful information is in fact the order of occurrence of the events, not the date-of-occurrence itself.


%In our previous work, we used this technique of using fault injection to reuse a nominal model without explicit fault modelling, obtaining Boolean expressions of systems' failures, as we showed in \cref{sec:faults-injection}.
%The drawback of this approach is that fault events ordering information is lost because it is not relevant on the Boolean expressions extraction.

We shown in \cref{sec:fault-trees} that there is an omnipresence of order-based operators to analyse \acp{TFT} and \acp{DFT}.
And that each approach describes a new algebra based on different representations of events ordering with similar theorems to reduce expressions to a canonical form.

From the need to tackle events ordering and from the ordering information we had from fault injection that we developed in~\cite{DM2012}, we defined a lists-based algebra, called \ac{algebra}, to express and analyse systems considering events ordering.
We also provide a mapping from fault traces~\cite{DM2012} (from \ac{CSPm} models) to this algebra.
The order-specific operations are expressed with a new operator ($\xbeforeop$) that we call XBefore (or exclusive before).

%We show reduction laws relating the XBefore operator to traditional Boolean operators.
%It is important to note that we support a NOT operator in our algebra.

%\usepackage{graphics} is needed for \includegraphics
%\begin{figure}[t]
%\begin{center}
  %\includegraphics[width=0.5\textwidth]{strategy}
%  \caption{Strategy overview}
%  \label{fig:overview}
%\end{center}
%\end{figure}

%It is defined as a set of all sets of distinct lists, called $\algebraset$.
%Then we show that all Boolean operators takes elements from and into $\algebraset$.

%We now show the \ac{algebra} as a set of all possible formulas.
In the following we show the definitions and laws of our proposed \ac{algebra}.
To avoid repetition, let $S$, $T$ and $U$ be sets of distinct lists.
A list $xs$ is distinct if it has no repeated element.
So, if $x$ is in $xs$, then it has a unique associated index $i$ and we denote it as $x = \nth{xs}{i}$.
Furthermore, as we follow \iac{FBA}\index{Boolean Algebra!Free} characterisation, we also need to show that the generators are independent.

The \ac{algebra} form a free algebra, similarly to \acp{FBA}\index{Boolean Algebra!Free}.
\emph{Infimum} and \emph{Supremum} are defined as set intersection ($\inter$) and union ($\union$) respectively.
The order within the algebra is defined with set inclusion ($\subseteq$).

To distinguish the permutations that are not defined in \ac{FBA}\index{Boolean Algebra!Free}, we need a new operator.
We give the definition of XBefore ($\xbeforeop$) in terms of list concatenation, similar to the work reported in~\cite{DM2015}:
%
\begin{equation}
\label{def:xbefore-append}
\xbefore{S}{T} =
  \setsin{
    zs | \exists xs, ys \bullet \parsin{\listset{xs}} \inter \parsin{\listset{ys}} = \{\}
      \land xs \in S \land ys \in T \land zs = \append{xs}{ys}
  }
\end{equation}
%
where the $\listset{}$ function returns the set of the elements of a list, and $\append{}{}$ concatenates two lists.

In some cases it is more intuitive to use the XBefore definition in terms of lists slicing because it uses indexes explicitly.
%\Cref{thm:xbefore} shows that the two definitions are equivalent.
Lists slicing is the operation of taking or dropping elements, obtaining a sublist.
In slicing, the starting index is inclusive, and the ending is exclusive.
Thus the first index is 0 and the last index is the list length.
For example, the list $\slice{xs}{i}{\length{xs}}$ is equal to the $xs$ list, where $\length{xs}$ is the list length.
We use the following notation for list slicing:
%
\begin{subequations}
\begin{align}
\slice{xs}{i}{j} &= \text{starts at $i$ and ends at $j-1$}\\
\sliceright{xs}{j} &= \slice{xs}{0}{j}\\
\sliceleft{xs}{i} &= \slice{xs}{i}{\length{xs}}
\end{align}
\end{subequations}

List slicing and concatenation are complementary: concatenating two consecutive slices results in the original list:
\begin{equation}
\forall i \bullet \append{\sliceright{xs}{i}}{\sliceleft{xs}{i}} = xs
\end{equation}

There is an equivalent definition of XBefore with concatenation using lists slicing:
%
\begin{equation}
\xbefore{S}{T} =
  \setsin{
    zs | \exists i \bullet \sliceright{zs}{i} \in S \land \sliceleft{zs}{i} \in T
  }
\end{equation}

A variable in \ac{algebra} is defined by one generator, and denotes its occurrence:
%
\begin{equation}
\label{def:var}
\var{x} =
  \setsin{
    zs | x \in zs
  }
\end{equation}

The following expressions are sufficient to define the \ac{algebra} in terms of an inductively defined set ($\algebraset$):
%
\begin{subequations}
\label{def:algebraset}
\begin{align}
\var x & \in \ac{algebra}set & \text{Variable}\label{def:algebraset-var}\\
S \in \algebraset \implies -S & \in \algebraset & \text{Complement, Negation}\label{def:algebraset-compl}\\
S \in \algebraset \land T \in \algebraset \implies S \inter T & \in \algebraset & \text{Intersection, \emph{Infimum}}\label{def:algebraset-inf}\\
S \in \algebraset \land T \in \algebraset \implies \xbefore{S}{T} & \in \algebraset & \text{XBefore}\label{def:algebraset-xbefore}\\
\intertext{Following the definitions, the expressions below are also valid for $\algebraset$:}
\True &\in \algebraset & \text{Universal set, True}\label{def:algebraset-true}\\
\False &\in \algebraset & \text{Empty set, False}\label{def:algebraset-false}\\
S \in \algebraset \land T \in \algebraset \implies S \union T &\in \algebraset & \text{Union, \emph{Supremum}}\label{def:algebraset-sup}
\end{align}
\end{subequations}

The following expressions are valid for generators $a$ and $b$ and are sufficient to show that the generators are independent:
%
\begin{subequations}
\label{eqs:generators-independence}
\begin{align}
&\var a \subseteq \var b \iff a = b\label{eqs:generators-independence-subseteq-eq}\\
&\var a = \var b \iff a = b\\
&\var a \not\subseteq - \var b\\
&\var a \neq -\var b\label{eqs:generators-independence-subseteq-neq-compl} \\
&- \var a \not\subseteq \var b\\
&- \var a \neq \var b\label{eqs:generators-independence-subseteq-compl-neq}
\end{align}
\end{subequations}

Expressions \eqref{def:algebraset-var} to \eqref{def:algebraset-sup} and \eqref{eqs:generators-independence-subseteq-eq} to \eqref{eqs:generators-independence-subseteq-compl-neq} implies that the \ac{algebra} without the XBefore operator \eqref{def:xbefore-append} forms a Boolean algebra based on sets of lists.
And this is also equivalent to \iac{FBA}\index{Boolean Algebra!Free} with the same generators.

In our previous work~\cite{DM2015} we stated a relation of XBefore and \emph{supremum}, provided the operands are variables \eqref{def:var}.
Now we generalise this relation in terms of abstract properties of the operands of the XBefore.
We name these properties as \emph{temporal properties}.
%and show them in \cref{sec:temporal-properties}.

\section{Temporal properties (\emph{\tempotext})}
\label{sec:temporal-properties}

Temporal properties give a more abstract and less restrictive shape\todo{touch?} on the XBefore laws.
These properties avoid the requirement that every operand of XBefore should be a variable \eqref{def:var}.
%The properties are: $\tempo[1]{}$ (\cref{def:tempo1}), $\tempo[2]{}$ (\cref{def:tempo2}), $\tempo[3]{}$ (\cref{def:tempo3}), and $\tempo[4]{}$ (\cref{def:tempo4}).

The first temporal property is about disjoint split.
If the first part of a list is in a given set, then every remainder part is not.
So, if a generator is in the beginning of a list, it must not be at the ending (and vice-versa).
%
%\todo{Explain temporal properties with respect to Figure 1 about relation of events? At least make it clearer.}
%
\begin{subequations}
\begin{align}
\tempo[1]{S} &= \forall i, j, zs \bullet
  i \le j \implies
  \lnot \left(
    \sliceright{zs}{i} \in S \land \sliceleft{zs}{j} \in S
  \right)\label{def:tempo1}\\
\tempo[2]{S} &= \forall i, zs \bullet
  zs \in S \iff
  \sliceright{zs}{i} \in S \lor \sliceleft{zs}{i} \in S\label{def:tempo2}\\
\tempo[3]{S} &= \forall i, j, zs \bullet
  j < i \implies
  \left(
    \slice{zs}{j}{i} \in S \iff \sliceright{zs}{i} \in S \land \sliceleft{zs}{j} \in S
  \right)\label{def:tempo3}\\
\tempo[4]{S} &= \forall zs \bullet zs \in S \iff (\exists i \bullet \slice{zs}{i}{\left(i+1\right)} \in S)\label{def:tempo4}
%\intertext{Replace $\tempo[4]{S}$ by (less restrictive):}
%&= \forall zs \bullet zs \in S \iff \exists i,j \bullet i < j \land \slice{zs}{i}{j} \in S
\end{align}
\end{subequations}

The second temporal property is about belonging to one sublist in the beginning or in the end.
If a generator is in a list, then it must be at the beginning or at the ending.
%
%\begin{definition}[\Tempotext 2, belongs to one sublist in the beginning or at the ending]
%\label{def:tempo2}
%Let $S$ be a set of distinct lists:
%\end{definition}
%

The third temporal property is about belonging to one sublist in the middle.
If a generator belongs to a sublist between $i$ and $j$, then it belongs to the sublist that starts at first position and ends in $j$ and to the sublist that starts at $i$ and ends at the last position (both sublists contain the sublist in the middle).
%
%\begin{definition}[\Tempotext 3, belongs to the middle of a sublist]
%\label{def:tempo3}
%Let $S$ be a set of distinct lists:
%\end{definition}
%

Finally, if a generator belongs to a list, then there is a sublist of size one that contains the generator.
%
%\begin{definition}[\Tempotext 4, belongs to one sublist of size one]
%\label{def:tempo4}
%Let $S$ be a set of distinct lists:
%\end{definition}
%

Variables have all four temporal properties. For a generator $x$, the following is valid:
%
\[
\tempo[1]{\left(\var{x}\right)} \land
\tempo[2]{\left(\var{x}\right)} \land
\tempo[3]{\left(\var{x}\right)} \land
\tempo[4]{\left(\var{x}\right)}
\]

\begin{sloppypar}
In our previous work~\cite{DM2015} we used set difference to specify the XBefore operator.
Provided $\tempo[1]{S}$ and $\tempo[1]{T}$, XBefore in~\cite{DM2015} is equivalent to \eqref{def:xbefore-append}:
%
\begin{equation}
\xbefore{S}{T} = \left\{ zs | \exists xs, ys \bullet xs \in S-T \land ys \in T-S \land \distinct{zs} \land zs = \append{xs}{ys}  \right\}
\end{equation}
\end{sloppypar}

Other expressions also meet one or more temporal properties:
\begin{subequations}
\begin{align}
\tempo[1]{S} \land \tempo[1]{T} & \implies \tempo[1]{\parsin{S \inter T}}\\
\tempo[3]{S} \land \tempo[3]{T} & \implies \tempo[3]{\parsin{S \inter T}}\\
\tempo[2]{S} \land \tempo[2]{T} & \implies \tempo[2]{\parsin{S \union T}}\\
\tempo[4]{S} \land \tempo[4]{T} & \implies \tempo[4]{\parsin{S \union T}}
\end{align}
\end{subequations}

\section{XBefore laws}
\label{sec:xbefore-laws}

We now show some laws to be used in the algebraic reduction of \ac{algebra} formulas.
The laws follow from the definition of XBefore, from events independence, and from the temporal properties.

We use a normal form similar to the disjunctive normal form (DNF) of Boolean algebra.
In DNF each sub-expression is a minimal cut set\index{Minimal Cut!Sets} for \ac{SFT}.
In our normal form, also called DNF, we allow \andtext\ s, \nottext\ s, and \xbeforetext\ s to be in the sub-expressions.
Each sub-expression is a set of minimal cut sequences\index{Minimal Cut!Sequences} for \ac{TFT} and \ac{DFT}.
The following formulas are in DNF:
%
\begin{align*}
&\parsin{A \inter -B} \union \parsin{\parsin{\xbefore{A}{B}} \inter C}\\
&A \union B\\
&\xbefore{A}{B}\\
&A \inter B\\
&\xbefore{\xbefore{A}{B}}{C}
\end{align*}
%
The following formulas are \emph{not} in DNF:
%
\begin{align*}
&-\parsin{A \union B}\\
&A \inter \parsin{B \union C}\\
&\xbefore{A}{\parsin{B \union C}}\\
&\xbefore{A}{\parsin{B \inter C}}
\end{align*}

\begin{sloppypar}
But to transform the last two formulas into DNF, one can use Laws \eqref{thm:xbefore-sup-1},~\eqref{thm:xbefore-sup-2},~\eqref{thm:xbefore-inf-1} and~\eqref{thm:xbefore-inf-2}, for instance.
\end{sloppypar}

We define events independence ($\independenteventsop$) as the property that one operand does not imply the other.
For example, we need to avoid that the operands of XBefore are $\var{a}$ and $\var{a} \union \var{b}$ (it results in $\False$, see \eqref{thm:xbefore-not-idempotent}).
%
\begin{equation}
\independentevents{S}{T} = \forall i, zs \bullet
  \lnot \left(
    \slice{zs}{i}{\left(i+1\right)} \in S \land
    \slice{zs}{i}{\left(i+1\right)} \in T
  \right)
\end{equation}

The absence of occurrences ($\False$, the empty set of $\algebraset$) is a ``0'' for the XBefore operator.
%
\begin{subequations}
\begin{align}
\xbefore{\False}{S} =&
  \False &
  \text{left-false-absorb}
  \label{thm:xbefore-of-false-1}\\
%
\xbefore{S}{\False} =&
  \False &
  \text{right-false-absorb}
  \label{thm:xbefore-of-false-2}\\
%
\left(\xbefore{S}{T}\right) \union S =& S &
  \text{left-union-absorb}
  \label{thm:xbefore-sup-absorb-1}\\
%
\left(\xbefore{T}{S}\right) \union S =& S &
  \text{right-union-absorb}
  \label{thm:xbefore-sup-absorb-2}\\
%
\tempo[1]{S} \implies
  \xbefore{S}{S} =&
  \False &
  \text{non-idempotent}
  \label{thm:xbefore-not-idempotent}\\
%
\tempo[1]{S}\land\tempo[1]{T}\land \tempo[1]{U}\implies&\nonumber\\
  \xbefore{S}{(\xbefore{T}{U})} =&
  \xbefore{(\xbefore{S}{T})}{U} &
  \text{associativity}
%
\end{align}
\end{subequations}
%
The XBefore is absorbed by one of the operands: if one of the operands may happen alone, thus the order with any other operand is irrelevant.
However, an event cannot come before itself, thus XBefore is not idempotent.
The XBefore but is associative.

To allow formula reduction we need the relation of XBefore to the other Boolean operators.
First we use the XBefore as operands of union and intersection.
%
\begin{subequations}
\begin{align}
\tempo[1]{S} \land \tempo[1]{T}\implies&\nonumber\\
  \parsin{\xbefore{S}{T}} \inter \parsin{\xbefore{T}{S}} =&
  \False &
  \text{inter-equiv-false}
  \label{thm:xbefore-inf-equiv-bot}\\
%
\tempo{S} \land \tempo{T} \land \independentevents{S}{T}\implies&\nonumber\\
  \parsin{\xbefore{S}{T}} \union \parsin{\xbefore{T}{S}} =&
  S \inter T &
  \text{union-equiv-inter}
  \label{thm:xbefore-sup-equiv-inf}
%
\end{align}
\end{subequations}
%
As the XBefore is not symmetric, the intersection of symmetrical sets is empty.
The union of the symmetric is a partition of the intersection of the operands.

In our previous work~\cite{DM2015}, we stated that $S$ and $T$ had to be variables.
For example, of the form $\var{s}$ and $\var{t}$.
Now, each law requires that the operands satisfy some of the temporal properties, avoiding using variables explicitly.
%So, as variables satisfy all temporal properties and by \eqref{thm:xbefore-sup-equiv-inf}, our theorem ``Exclusive before \emph{supremum}'' is still valid.

Boolean operators are used as operands of the XBefore in the following laws.
%
\begin{subequations}
\begin{align}
\xbefore{\left(S \union T\right)}{U} =&
  \parsin{\xbefore{S}{U}} \union \parsin{\xbefore{T}{U}} &
  \text{left-union-dist}
  \label{thm:xbefore-sup-1}\\
%
\xbefore{S}{\left(T \union U\right)} =&
  \parsin{\xbefore{S}{T}} \union \parsin{\xbefore{S}{U}} &
  \text{right-union-dist}
  \label{thm:xbefore-sup-2}\\
%
\tempo{S} \land \tempo{T} \land \independentevents{S}{T} & \implies\nonumber \\
  \xbefore{\left(S \inter T\right)}{U} =&
  \parsin{\xbefore{\xbefore{S}{T}}{U}} \union \nonumber\\
  &\parsin{\xbefore{\xbefore{T}{S}}{U}} &
  \text{left-inter-dist}
  \label{thm:xbefore-inf-1}\\
%
\tempo{T} \land \tempo{U} \land \independentevents{T}{U} & \implies \nonumber\\
  \xbefore{S}{\left(T \inter U\right)} =&
  \parsin{\xbefore{S}{\xbefore{T}{U}}} \union \nonumber\\
  &\parsin{\xbefore{S}{\xbefore{U}{T}}} &
  \text{right-inter-dist}
  \label{thm:xbefore-inf-2}\\
%
\tempo[2]{S} \implies S \inter \parsin{\xbefore{T}{U}} =&
  \parsin{\xbefore{\parsin{S \inter T}}{U}} \union \nonumber\\
  &\parsin{\xbefore{T}{\parsin{S \inter U}}} &
  \text{unordered}
  \label{thm:and_xbefore_equiv_or_xbefore}
\end{align}
\end{subequations}
%
XBefore is distributive over union.
On the other hand, the intersection is related to order.
Thus it is not distributive with XBefore.
Finally, the intersection of an event with an XBefore states that such an event can occur in any order within the events in the XBefore.

The law name, unordered, of \eqref{thm:and_xbefore_equiv_or_xbefore} is clearer if we expand \eqref{thm:and_xbefore_equiv_or_xbefore} with \eqref{thm:xbefore-inf-1} and ~\eqref{thm:xbefore-inf-2}:
%
%\begin{subequations}
\begin{align}
\tempo{S} \land \tempo{T} \land \nonumber\\
  \tempo{U} \land \independentevents{S}{T} \land \independentevents{S}{U} & \implies \nonumber\\
  S \inter \parsin{\xbefore{T}{U}} = &
  \parsin{\xbefore{\xbefore{S}{T}}{U}} \union \nonumber\\
  & \parsin{\xbefore{\xbefore{T}{S}}{U}} \union \nonumber\\
  & \parsin{\xbefore{\xbefore{T}{U}}{S}} &
  \text{expanded-unordered}
  \label{thm:and_xbefore_equiv_or_xbefore_expanded}
%\\
%
%\tempo[2]{S} \implies S \inter \parsin{\xbefore{S}{T}} =& \xbefore{S}{T} &
%  \text{left-inter-absorb}
%  \label{thm:xbefore-inf-absorb-1}\todo{Prove this in Isabelle}\\
%
%
%\tempo[2]{S} \implies S \inter \parsin{\xbefore{T}{S}} =& \xbefore{T}{S} &
%  \text{right-inter-absorb}
%  \label{thm:xbefore-inf-absorb-2}\todo{Prove this in Isabelle}
\end{align}
%\end{subequations}
%
%From \eqref{thm:xbefore-not-idempotent} and~\eqref{thm:and_xbefore_equiv_or_xbefore}, intersection and XBefore also have an absorption law.


\chapter{Case study}
\label{sec:case-study}

\EMBRAER provided us with the \simulink model of an Actuator Control System (depicted in \cref{fg:acsBlockDiagrams}).
The failure logic of this system (that is, for each of its constituent components) was also provided by \EMBRAER (we show some of them in \cref{tbl:acsAnnotations}).
In what follows we illustrate our strategy using the Monitor component.

A monitor component is a system commonly used for fault tolerance~\cite{ONB2002,KK2007}.
Initially, the monitor connects the main input (power source on input port 1) with its output.
It observes the value of this input port and compares it to a threshold.
If the value is below the threshold, the monitor disconnects the output from the main input and connects to the secondary input.
We present the \simulink model for this monitor in \cref{fg:blockDiagramMonitorInternals}.

%As we mentioned in~\cref{sec:faults-injection} we translated the monitor to \ac{CSPm} according to our strategy and modified the observer to make \acs{fdr} generate more counter-examples.

Now we show two contributions: (i) using only Boolean operators, thus ignoring ordering, we can obtain the same results obtained in~\cite{DM2012}, and (ii) we represent each of the fault traces reported in~\cite{DM2012} as a term in our proposed algebra of temporal faults.
Similarly to the association of fault events of \cref{tbl:acsAnnotations} in \cref{sec:faults-injection}, we associate the fault events as:
%
\begin{align*}
a &= \text{LowPower-In1}& A = \var a\\
b &= \text{LowPower-In2}& B = \var b\\
s &= \text{SwitchFailure}& S = \var s
\end{align*}

\section{Structure expressions with Boolean operators}
\index{structure expression}

In this section we show that the same result reported in~\cite{DM2012} in terms of static failure logic (or Boolean propositions) can be obtained with our Boolean operator without using XBefore.
For each trace shown in \cref{sec:faults-injection}, a mapping function\footnote{In this work we do not show the mapping function from traces to \ac{algebra} (and the mapping function with XBefore in \cref{sec:case-study-xbefore}).
The mapping rules follow the traces: XBefore is obtained by the order of occurrence and the absence of an event is the complement ($-$).} ($\tracetobool$) generates the following sets of lists:
%
\begin{align*}
\text{\texttt{TRACE 1: }}&[s,b] \tracetobool S \inter B \inter -A & \setsin{\listsin{s,b},\listsin{b,s}}\\
\text{\texttt{TRACE 2: }}&[b,s] \tracetobool B \inter S \inter -A & \setsin{\listsin{s,b},\listsin{b,s}}\\
\text{\texttt{TRACE 3: }}&[a,b] \tracetobool A \inter B \inter -S & \setsin{\listsin{a,b},\listsin{b,a}}\\
\text{\texttt{TRACE 4: }}&[b,a] \tracetobool B \inter A \inter -S & \setsin{\listsin{a,b},\listsin{b,a}}\\
\text{\texttt{TRACE 5: }}&[a,s] \tracetobool A \inter S \inter -B & \setsin{\listsin{a,s},\listsin{s,a}}\\
\text{\texttt{TRACE 6: }}&[a,s,b] \tracetobool A \inter S \inter B & \setsin{\listsin{a,b,s},\listsin{a,s,b},\ldots,\listsin{s,b,a}}\\
\text{\texttt{TRACE 7: }}&[a,b,s] \tracetobool A \inter B \inter S & \setsin{\listsin{a,b,s},\listsin{a,s,b},\ldots,\listsin{s,b,a}}\\
\text{\texttt{TRACE 8: }}&[b,a,s] \tracetobool B \inter A \inter S & \setsin{\listsin{a,b,s},\listsin{a,s,b},\ldots,\listsin{s,b,a}}\\
\end{align*}

They represent the same faults shown in \cref{sec:faults-injection}.
Note that the negation in the formula is very simple to represent in \ac{algebra} (and \ac{FBA}\index{Boolean Algebra!Free}) because it is just the absence of the generator.

Combining the above sets with unions (ORs), we obtain the following formula set:
%
\[
\left\{ \listsin{s,b}, \listsin{b,s}, \listsin{a,b}, \listsin{b,a}, \listsin{a,s}, \listsin{s,a}, \listsin{a,b,s}, \listsin{a,s,b},\ldots,\listsin{s,b,a} \right\}
\]

If we use Boolean expression reduction instead, it results in the following expression in \ac{algebra} (and in \ac{FBA}\index{Boolean Algebra!Free}):
\[
(A \inter B) \union (S \inter (A \union B))
\]
%
which is equivalent to the set of sets above and is equivalent to \EMBRAER failure logic expression shown in \cref{tbl:acsAnnotations} (with \andtext\ s as $\inter$ and \ortext\ s as $\union$).
%
This shows that \ac{algebra} can represent (static) failure logic as in our previous work~\cite{DM2012}.

\section{Structure expressions with XBefore}
\label{sec:case-study-xbefore}
\index{structure expression}

Now, by using TFA with the XBefore operator and a mapping function ($\tracetoalgebra$), we can capture each possible individual sequences as generated by the work~\cite{DM2012}:
%
\begin{align*}
\text{\texttt{TRACE 1: }}&[s,b] \tracetoalgebra \parsin{\xbefore{S}{B}} \inter -A & \left\{[s,b]\right\}\\
\text{\texttt{TRACE 2: }}&[b,s] \tracetoalgebra \parsin{\xbefore{B}{S}} \inter -A & \left\{[b,s]\right\}\\
\text{\texttt{TRACE 3: }}&[a,b] \tracetoalgebra \parsin{\xbefore{A}{B}} \inter -S & \left\{[a,b]\right\}\\
\text{\texttt{TRACE 4: }}&[b,a] \tracetoalgebra \parsin{\xbefore{B}{A}} \inter -S & \left\{[b,a]\right\}\\
\text{\texttt{TRACE 5: }}&[a,s] \tracetoalgebra \parsin{\xbefore{A}{S}} \inter -B & \left\{[a,s]\right\}\\
\text{\texttt{TRACE 6: }}&[a,s,b] \tracetoalgebra \xbefore{\xbefore{A}{S}}{B} & \left\{[a,s,b]\right\}\\
\text{\texttt{TRACE 7: }}&[a,b,s] \tracetoalgebra \xbefore{\xbefore{A}{B}}{S} & \left\{[a,b,s]\right\}\\
\text{\texttt{TRACE 8: }}&[b,a,s] \tracetoalgebra \xbefore{\xbefore{B}{A}}{S} & \left\{[b,a,s]\right\}
\end{align*}

Using \ac{algebra} and combining each trace with ORs (unions), we obtain the following set:
%
\[
M_L =
  \left\{
    [a,b],[b,a],[b,s],[s,b],[a,s],
    [a,b,s],[a,s,b],[s,a,b]
  \right\}
\]

From the above traces, we also build \iac{algebra} expression by mapping each trace to an XBefore expression, composing all resulting XBefore expressions with ORs and reducing them using the XBefore laws (\cref{sec:xbefore-laws}), resulting in an expression ($M_A$) that is equivalent to the above set of lists ($M_L \equiv M_A$).
The failure expression of the monitor\footnote{In the final formula, $\parsin{B \inter S \inter -A} \union \parsin{A \inter B \inter -S}$ is equivalent to $\parsin{B \inter \parsin{S \oplus A}}$. There is a typo in our previous work \cite{DM2015}. The expression was written with an OR ($\lor$) but it should an XOR ($\oplus$).} is:
%
\begin{align*}
M_A = & \parsin{\parsin{\xbefore{S}{B}} \inter -A} \union \parsin{\parsin{\xbefore{B}{S}} \inter -A} \union\\
  &\parsin{\parsin{\xbefore{A}{B}} \inter -S} \union \parsin{\parsin{\xbefore{B}{A}} \inter -S} \union\\
  & \parsin{\parsin{\xbefore{A}{S}} \inter -B} \union \\
  & \parsin{\xbefore{\xbefore{A}{S}}{B}} \union \parsin{\xbefore{\xbefore{A}{B}}{S}} \union \parsin{\xbefore{\xbefore{B}{A}}{S}} \\
%%
= &\parsin{B \inter S \inter -A} \union & \text{by \eqref{thm:xbefore-sup-equiv-inf}}\\
  & \parsin{B \inter A \inter -S} \union & \text{by \eqref{thm:xbefore-sup-equiv-inf}}\\
  & \parsin{\parsin{\xbefore{A}{S}} \inter -B} \union\\
  & \parsin{\xbefore{\xbefore{A}{S}}{B}} \union \parsin{\xbefore{\xbefore{A}{B}}{S}} \union \parsin{\xbefore{\xbefore{B}{A}}{S}}\\
%
= &\parsin{B \inter S \inter -A} \union \\
  & \parsin{B \inter A \inter -S} \union \\
  & \parsin{\parsin{\xbefore{A}{S}} \inter -B} \union \\
  & \parsin{\parsin{\xbefore{A}{S}} \inter B} & \text{by \eqref{thm:and_xbefore_equiv_or_xbefore_expanded}}\\
%
= &\parsin{B \inter S \inter -A} \union \parsin{B \inter A \inter -S} \union \parsin{\xbefore{A}{S}} & \text{by absorption}
\end{align*}

The semantics of the above expression is: (i) fault $b$ ($\var{b}$) occurs and fault $a$ ($\var{a}$) or fault $s$ ($\var{s}$) occurs (but not both $a$ and $s$), or (ii) fault $a$ occurs before fault $s$, which is more precise than the expression found without considering order of events.

\chapter{Conclusion}
\label{sec:conclusion}

\todo{Add a schedule of activities to conclude.}

In this work we presented a foundational theory to support a more precise representation of fault events as compared to our previous strategy for injecting faults~\cite{DM2012}.
%
The failure logic is essential for system safety assessment because it is used as basic input for building \aclp{FT}~\cite{PMS+2001,JMS+2011,GMS+2010}.
%
%We use \simulink as starting point because it is a standard tool in the control systems industry.
%
Furthermore, we still connect the strategy presented in~\cite{MJG+2010} with the works reported in~\cite{JMS+2011} (functional analysis) and in~\cite{GMS+2010,PMS+2001} (safety assessment) because our new algebra is at least a Boolean algebra.


%The work reported in~\cite{Huffm2010} was used as a basis for all proofs.
%
%It contains a complete theory of Free Boolean Algebras, including a homomorphism from an FBA to any Boolean algebra.
%
%Proving that there is also a homomorphism from \ac{algebra} to any Boolean algebra is left as future work.

\begin{sloppypar}
The work reported in~\cite{Walker2009,WP2009,WP2010} tackles simultaneity with ``nearly simultaneous'' events~\cite{EWG2013}.
But we consider instantaneous events, like the work reported in~\cite{MRL2014}, because we assume that simultaneity is probabilistically impossible.
\end{sloppypar}
%Another future To show the relation of the exclusive before operator to the operators shown in~\cite{MRL2014} and~\cite{WP2009}.

%As future work we will complete the analysis including verification of a formula acceptance criteria.
%
%The objective of finding failure logic is to create fault trees and then performing qualitative and quantitative analyses to check if the fault trees meet safety requirements (for static and dynamic fault trees).
%
%We plan to verify safety requirements directly from the failure logic expressed by our TFA.
%
%It means we need a reduction technique that includes the exclusive before operator to analyse large-scale systems (say with 1000 or more fault events) without using \ac{TDT}s~\cite{WP2010}.
%
%We believe that the direct analysis on failure logic expressed by our TFA can also accelerate temporal fault trees analysis as it is a subclass of dynamic fault trees.

The distinct lists representation in our algebra does not allow obtaining minimal cut sequences\index{Minimal Cut!Sequences} directly from the formula, similar to \acp{FBA}\index{Boolean Algebra!Free}.
The sets in \iac{FBA}\index{Boolean Algebra!Free} formula are already the minimal cut sets\index{Minimal Cut!Sets}.
In our work, \ac{algebra} allows us to find minimal cut sequences\index{Minimal Cut!Sequences} (with XBefore) from the formulas in DNF algebraically: each sub-expression is a minimal cut sequence\index{Minimal Cut!Sequences}.

Boolean formulas reduction can be achieved by: (i) application of Boolean laws, (ii) \ac{BDD}\index{Binary Decision Diagrams}, or (iii) \acp{FBA}\index{Boolean Algebra!Free}.
We used Boolean and XBefore laws to reduce \ac{algebra} formulas.
%
The work reported in~\cite{TXD2011,XTD2012} uses Sequential BDDs\index{Binary Decision Diagrams!Sequential} to reduce formulas with order-based operators.
%
We plan to use similar concepts in a future work.

Although we do not use negation (\nottext operator) with XBefore in our case study it is part of \ac{algebra}, so it could be used.
As future work we will demonstrate the relations of \nottext and \xbeforetext, as we did for \andtext and \ortext.
We will also define laws to avoid the conditions that cause non-coherent analysis~\cite{Oliv2006}.
The issue with negated events comes up when both an event and its negation appear on the same tree.
One very restrictive solution to this issue is applying the \emph{generators independence} laws (\ref{eqs:generators-independence-subseteq-neq-compl}, \ref{eqs:generators-independence-subseteq-compl-neq}) on basic events of a tree, by actually considering the negation of an event a different event (for instance, $\var a= \var e$ and $\var b=-\var e$).
We look forward to obtain a less restrictive law.


We showed the DNF for \ac{algebra}, but did not demonstrate that every formula can be converted into DNF.
The laws shown in this work should be sufficient to this demonstration.
Also, we did not show the mapping rules from traces to \ac{algebra} (with Boolean operators only and with XBefore).
The mapping rules follow the traces: XBefore is obtained by the order of occurrence and the absence of an event is the complement ($-$).
We leave these demonstrations as future work.


%\include{chapters/introduction}
%\include{chapters/background}
%\include{chapters/desenv}
%\include{chapters/conclusion}

% References
\postextual
%\begin{references}
  \bibliography{references-jabref}
%\end{references}

% Appendix

%\theappendix
\begin{apendicesenv}
\partapendices
\chapter{Formal proofs in Isabelle/HOL}
\label{app:formal-proofs-isabelle-hol}

\end{apendicesenv}

\phantompart
\printindex
\todo{Verify indexes again (search again for words already in the index)}
\todo{Run makeindex main on this directory}
\cleardoublepage

\listoftodos[Notes]{}
\end{document}
