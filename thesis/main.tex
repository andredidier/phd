\documentclass[12pt,openright,twoside,a4paper,oldfontcommands,english,brazil,final]{abntex2}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{makeidx}
\usepackage{colortbl}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tabularx}
\usepackage{microtype}
\usepackage{bibentry}
%\usepackage{subfigure}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{booktabs}
\usepackage{pdfpages}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{verbatim}
\usepackage{environ}
\usepackage{acro}
\usepackage{longtable}
\usepackage{isabelle,isabellesym}
\usepackage{lastpage}
\usepackage[num,abnt-etal-list=0]{abntex2cite}
%\usepackage[alf,abnt-etal-list=0,abnt-etal-cite=3,babel]{abntex2cite}
%\usepackage[style=authoryear-icomp,maxbibnames=9,maxcitenames=3,backend=biber]{biblatex}
%\usepackage[alf,abnt-etal-cite=0]{abntex2cite}
%\usepackage[num]{abntex2cite}
%Erro: \textquotesingle:
\usepackage{textcomp}
%Quantas vezes e em quais páginas a referência foi citada
%\usepackage[english,hyperpageref]{backref}
%\usepackage[colorinlistoftodos,prependcaption,textsize=footnotesize,textwidth=4cm]{todonotes} % NOTAS
\usepackage[final]{fixme}
\usepackage{soul}

\usepackage{indentfirst}
\usepackage{microtype}      % para melhorias de justificação

%%%%%%%%%%%%%%%%% NOTAS
%TODONOTES
%\newcommand{\notename}{Comment}%
%
%\addto\captionsbrazil{%
%  %\renewcommand{\chaptername}{Tema}%
%  \renewcommand{\contentsname}{Temas}%
%  \renewcommand{\notename}{Comentário}%
%}
%
%\newcounter{note}
%\newcommand{\note}[2][]{%
%  % initials of the author (optional) + note in the margin
%  \refstepcounter{note}%
%  {%
%    %\setstretch{0.7}% spacing
%    \todo[color={red!100!green!33},size=\small,inline]{%
%    \textbf{\notename{} [\uppercase{#1}\thenote]:}~#2}%
%  }
%}
%\newcommand{\texthl}[1]{#1}
%\newcommand{\hlfix}[2]{\texthl{#1}\todo{#2}\xspace}

%SIMPLES
%\makeatletter
%\newcommand{\texthl}[1]{#1}
%\newcommand{\todo}[1]{\@latex@warning{TODO #1}}
%\newcommand{\hlfix}[2]{\texthl{#1}\todo{#2}\xspace}
%\newcommand{\listoftodos}[1]{}
%\makeatother

%FIXME
\fxsetup{layout={footnote}}
%\fxuselayouts{pdfnote,margin}
%\fxusetargetlayout{signature}
\FXRegisterAuthor{ad}{alrd}{AD}
\FXRegisterAuthor{am}{acm}{AM}
%\fxuselayouts{pdfsignote,margin}
\newcommand{\todo}[1]{\adnote{#1}}
\newcommand{\note}[2][]{\adnote{#2}}
\newcommand{\listoftodos}[1]{\listoffixmes}
%%%%%%%%%%%%%%%%% NOTAS

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

\citebrackets[]

\acsetup{%
  hyperref=true,
  index=true,
  index-cmd={\index},
  list-type=table,
  list-style=longtable,
  page-ref=plain,
  pages=all%
}

\captionsetup[table]{position=top,justification=centering,width=.85\textwidth,labelfont=bf,font=small}
\captionsetup[lstlisting]{position=top,justification=centering,width=.85\textwidth,labelfont=bf,font=small}
\captionsetup[figure]{position=bottom,justification=centering,width=.85\textwidth,labelfont=bf,font=small}
\usepackage[capitalise]{cleveref}
%\usepackage{cleveref}

\addto\captionsenglish{% ingles
  %% adjusts names from abnTeX2
  \renewcommand{\folhaderostoname}{Title page}
  \renewcommand{\epigraphname}{Epigraph}
  \renewcommand{\dedicatorianame}{Dedication}
  \renewcommand{\errataname}{Errata sheet}
  \renewcommand{\agradecimentosname}{Acknowledgments}
  \renewcommand{\resumoname}{Abstract}
  \renewcommand{\anexoname}{ANNEX}
  \renewcommand{\anexosname}{Annex}
  \renewcommand{\apendicename}{APPENDIX}
  \renewcommand{\apendicesname}{Appendix}
  \renewcommand{\orientadorname}{Supervisor:}
  \renewcommand{\coorientadorname}{Co-supervisor:}
  \renewcommand{\folhadeaprovacaoname}{Approval}
  \renewcommand{\resumoname}{Abstract}
  \renewcommand{\listadesiglasname}{List of abbreviations and acronyms}
  \renewcommand{\listadesimbolosname}{List of symbols}
  \renewcommand{\listfigurename}{List of figures}
  \renewcommand{\listtablename}{List of tables}
  \renewcommand{\fontename}{Source}
  \renewcommand{\notaname}{Note}
  %% adjusts names used by \autoref
  \renewcommand{\pageautorefname}{page}
  \renewcommand{\sectionautorefname}{section}
  \renewcommand{\subsectionautorefname}{subsection}
  \renewcommand{\subsubsectionautorefname}{subsubsection}
  \renewcommand{\paragraphautorefname}{subsubsubsection}
}
\Crefname{figure}{Figure}{Figures}
\Crefname{table}{Table}{Tables}
\Crefname{page}{Page}{Pages}
\Crefname{section}{Section}{Sections}
\Crefname{subsection}{Subsection}{Subsections}
\Crefname{subsubsection}{Subsubsection}{Subsubsections}
\input{capa}

%% Change the following pdf author attribute name to your name.
\autor{André Luís Ribeiro Didier}
\titulo{An Algebra of Temporal Faults}
\data{2016}
\instituicao{%
Federal University of Pernambuco%
\par
Center of Informatics%
\par
Graduate in Computer Science%
}
\local{Recife, PE}
\tipotrabalho{Ph.D. Thesis}
\orientador{Alexandre Cabral Mota}
\coorientador{Alexander Romanovsky}
\preambulo{
A Ph.D. Thesis presented to the Center for Informatics of Federal University of Pernambuco in partial fulfillment of the requirements for the degree of Philosophy Doctor in Computer Science.}

\makeatletter
\hypersetup{%
  pdftitle={\@title},
  pdfauthor={\@author},
  pdfsubject={\imprimirpreambulo},
  %pdfkeywords={PALAVRAS}{CHAVE}{EM}{PORTUGUES},
  pdfcreator={LaTeX with abnTeX2},
  colorlinks=true,
  linkcolor=blue,
  citecolor=blue,
  urlcolor=blue
}
\makeatother


% Tamanho do parágrafo
\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}
\frenchspacing


%\address{Recife-PE}

%\universitypt{Universidade Federal de Pernambuco}
%\universityen{Federal University of Pernambuco}

%\departmentpt{Centro de Informática}
%\departmenten{Center for Informatics}

%\programpt{Pós-graduação em Ciência da Computação}
%\programen{Graduate in Computer Science}

%\majorfieldpt{Ciência da Computação}
%\majorfielden{Computer Science}

%\title{\thesistitle}

%\date{2017}

%\author{\thesisauthor}
%\adviser{Alexandre Cabral Mota}
%\coadviser{Alexander Romanovsky}

%\addbibresource{references-jabref.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Macros (defines your own macros here, if needed)
%\def\x{\checkmark}

\newtheorem{definition}{Definition}[chapter]
\theoremstyle{theo}
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{Theo}{Theorem}[chapter]
\newtheorem{proposition}{Proposition}[chapter]

\hyphenation{EMBRAER}
\newcommand{\includegraphicsaspectratio}[2][1]{%
  \includegraphics[width=#1\textwidth,height=#1\textheight,keepaspectratio]{#2}%
}

\newcommand{\EMBRAER}{EMBRAER\xspace}
\newcommand{\matlab}{\textsf{Matlab}\xspace}
\newcommand{\algebraurl}{\url{http://www.cin.ufpe.br/~alrd/phd/phd-alrd.zip} (password: 6Zvq\$5Vyj)\xspace}

\input{acronyms}
%\makeatletter
%\renewcommand{\listofacronyms}{%
%  \acresetall
%  \pagestyle{empty}
%  \if\@language1
%    \printacronyms[name={\acronymname},heading=chapter*]
%    \thispagestyle{empty}
%  \else\if\@language0
%    \printacronyms[name={\acronimoname},heading=chapter*]
%    \thispagestyle{empty}
%  \fi\fi
%  \acresetall
%}
%\makeatother

%USED IN SOME REFS, AS IN CBL+2014.
\newcommand\mathplus{+}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TEXT
\newlist{alineasinline}{enumerate*}{1}
\setlist[alineasinline]{label=(\roman*)}


\newlist{rqenum}{enumerate}{2}
\setlist[rqenum,1]{label={$RQ_{\arabic*}$)},ref={$RQ_{\arabic*}$},topsep=0pt,itemsep=0pt,leftmargin=\parindent+\labelwidth-\labelsep}%
\setlist[rqenum,2]{label={$RQ_{\arabic{rqenumi}.\arabic*}$)},ref={$RQ_{\arabic{rqenumi}.\arabic*}$},topsep=0pt,itemsep=0pt,leftmargin=*}
\Crefname{rqenumi}{Research question}{Research questions}
\crefname{rqenumi}{research question}{research questions}
\Crefname{rqenumii}{Research question}{Research questions}
\crefname{rqenumii}{research question}{research questions}

\newlist{contrenum}{enumerate}{2}
\setlist[contrenum,1]{label={$C_{\arabic*}$)},ref={$C_{\arabic*}$},topsep=0pt,itemsep=0pt,leftmargin=\parindent+\labelwidth-\labelsep}%
\setlist[contrenum,2]{label={--},topsep=0pt,itemsep=0pt,leftmargin=*}
\Crefname{contrenumi}{Contribution}{Contributions}
\crefname{contrenum}{contribution}{contributions}

\newcommand{\textsim}[1]{$#1$}
\newenvironment{snippetcspm}[1][2]
{
\ifthenelse{\equal{#1}{0}}
    {\tiny}
    {
    \ifthenelse{\equal{#1}{1}}
        {\scriptsize}
        {
        \ifthenelse{\equal{#1}{2}}
            {\footnotesize}
            {\small}
        }
    }
%\begin{samepage}
\verbatim
}
{
\endverbatim
%\end{samepage}
}
\newcommand{\simulink}{Simulink\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%References
\def\FThandbook{Fault Tree Handbook~\cite{VGR+1981}\index{Fault Tree!Handbook}%
  \gdef\FThandbook{Fault Tree Handbook\index{Fault Tree!Handbook}\xspace}%
  \xspace}
\def\pandora{Pandora\footnote{Pandora stands for: P-AND-ORA, which translates to Priority AND, Time.}%
  \gdef\pandora{Pandora\xspace}%
  \xspace}
\def\theftanalyser{%
  the Fault Tree Analyser\footnote{\url{http://www.fault-tree-analysis-software.com}, accessed 2/feb/2016}%
  %~\cite{ALDSoftwareFTAnalyser}%
  \gdef\theftanalyser{the Fault Tree Analyser\xspace}%
}
\newcommand{\isabellehol}[1][]{%
  Isabelle/HOL{#1}\index{Isabelle/HOL}~2015\footnote{The 2002 tutorial is reported in~\cite{NPW2002}, but there is a newer version published with the tool itself.
  The tool and the tutorial are available on their website at \url{http://isabelle.in.tum.de}.}%
  \global\renewcommand{\isabellehol}[1][]{Isabelle/HOL{#1}\index{Isabelle/HOL}\xspace}\xspace %
}
%\AtEveryBibitem{%
%  \ifentrytype{online}{%
%    \clearfield{labelyear}%
%  }{%
%  }%
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATH
\newcommand{\sliceright}[2]{\ensuremath #1_{\left[..#2\right]}}
\newcommand{\sliceleft}[2]{\ensuremath #1_{\left[#2..\right]}}
\newcommand{\slice}[3]{\ensuremath #1_{\left[#2..#3\right]}}
\def\varop{\ensuremath\operatorname{\mathbf{var}}}
\newcommand{\var}[1]{\ensuremath\varop #1}
\def\xbeforeop{\ensuremath\rightarrow}
\newcommand{\xbefore}[2]{\ensuremath #1 \xbeforeop #2 }
\newcommand{\xbeforedef}[2]{\ensuremath \left\{ zs | \exists i \bullet \sliceright{zs}{i} \land \sliceleft{zs}{i}  \right\}}
\def\Tempotext{Tempo\xspace}
\def\tempotext{tempo\xspace}
\def\tempoop{\ensuremath\operatorname{\mathbf{tempo}}}
\newcommand{\tempo}[2][1-4]{\ensuremath\tempoop_{#1} #2}
\def\independenteventsop{\ensuremath\operatorname{\triangleleft\triangleright}}
\newcommand{\independentevents}[2]{\ensuremath #1 \independenteventsop #2}
\def\True{\ensuremath\operatorname{UNIV}}
\def\False{\ensuremath\operatorname{\left\{\right\}}}
\def\distinctop{\ensuremath\operatorname{distinct}}
\newcommand{\distinct}[1]{\ensuremath\distinctop #1}
\newcommand{\emptylist}{\ensuremath[]}
\newcommand{\nth}[2]{\ensuremath #1_{#2}}
\newcommand{\length}[1]{\ensuremath\left|#1\right|}
\newcommand{\fact}[1]{\ensuremath #1!}
\newcommand{\append}[2]{\ensuremath #1 \operatorname{\mathbf{@}} #2}
\def\listsetop{\ensuremath\operatorname{\mathbf{set}}}
\newcommand{\listset}[1]{\ensuremath\listsetop #1}
\def\dropop{\ensuremath\operatorname{drop}}
\newcommand{\drop}[2]{\ensuremath\dropop {#2} {#1}}
\def\takeop{\ensuremath\operatorname{take}}
\newcommand{\take}[2]{\ensuremath\takeop {#2} {#1}}
%\def\maxop{\ensuremath\operatorname{max}}
%\newcommand{\max}[1]{\ensuremath\maxop #1}
\def\algebraset{\ensuremath\operatorname{\mathbf{atf}}}
\def\tracetobool{\ensuremath\operatorname{\stackrel{\leadsto}{\text{\tiny B}}}}
\def\tracetofba{\ensuremath\operatorname{\stackrel{\leadsto}{\text{\tiny F}}}}
\def\tracetoalgebra{\ensuremath\operatorname{\stackrel{\leadsto}{\text{\tiny XB}}}}
\newcommand{\setsin}[1]{\ensuremath\left\{ #1 \right\}}
\newcommand{\listsin}[1]{\ensuremath\left[ #1 \right]}
\newcommand{\parsin}[1]{\ensuremath\left( #1 \right)}
\newcommand{\anglesin}[1]{\ensuremath\left\langle #1 \right\rangle}
\newcommand{\squaresin}[1]{\ensuremath\left[ #1 \right]}
\newcommand{\func}[2]{\ensuremath #1 \left( #2 \right)}
\newcommand{\highlight}[1]{\fcolorbox{red}{white}{$\displaystyle#1$}}
\newcommand{\highlightresult}[1]{\colorbox{green!50}{$\displaystyle#1$}}
%\def\dlists{\ensuremath\operatorname{\mathbf{dlists}}}
\def\union{\ensuremath\operatorname{\cup}}
\def\inter{\ensuremath\operatorname{\cap}}
\def\powersetop{\ensuremath\mathbb{P}}
\newcommand{\powerset}[1]{\ensuremath\powersetop\left(#1\right)}
\def\cartesian{\ensuremath\operatorname{\times}}
\def\ftcoherencyop{\ensuremath\operatorname{\Phi}}
\newcommand{\ftcoherency}[1]{\ensuremath\ftcoherencyop\parsin{#1}}
\newcommand{\replace}[2]{\ensuremath\squaresin{#1\middle/#2}}
\def\pand{\ensuremath\operatorname{<}}
\def\por{\ensuremath\operatorname{|}}
\def\sand{\ensuremath\operatorname{\&}}
\def\nibefore{\ensuremath\operatorname{\lhd}}
\def\ibefore{\ensuremath\operatorname{\unlhd}}
\def\simultaneous{\ensuremath\operatorname{\bigtriangleup}}
\def\probabilityop{\ensuremath \Pr}
\newcommand{\probability}[1]{\ensuremath \probabilityop\parsin{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeindex

\begin{document}
\selectlanguage{english}

\imprimircapa
\imprimirfolhaderosto*{}

\input{ficha-catalografica}

\input{folha-aprovacao}


%\frontmatter

%\frontpage

%\presentationpage

%\begin{fichacatalografica}
%	\FakeFichaCatalografica % Comment this line when you have the correct file
%     \includepdf{fig_ficha_catalografica.pdf} % Uncomment this
%\end{fichacatalografica}

%\banca

\begin{dedicatoria}
\vspace*{\fill}
I dedicate this thesis to Juliana, Luciana (pipoquinha), and Bianca (snowflake).
\vspace*{\fill}
\end{dedicatoria}

\begin{agradecimentos}

If I were afraid of the path, I wouldn't have gotten here.

Two men helped me to build this path far before I started my scholar journey: Roberto and Júnior.
My two grandfathers couldn't see how far I got.
My heart was with them all the time, but I was physically far away from them in their very last breath.
May God have them in his arms.

It is now ten years since I graduated.
I met professors Alexandre and Augusto still during the Computing Science undergrad course.
They have been present in my academic life ever since.
Their comments, instructions, talks, (even jokes), are what molded my path to here.
I have no words to express how much I thank them, specially Alexandre, who have guided me since my undergrad course.
%I hope this is the beginning of a healthy partnership for the improvement of science.

CNPq and FACEPE were keen to guarantee my existential needs.
The former with the trip to Newcastle upon Tyne, and the latter during the time I stayed in Recife, before and after the trip.

I thank to Sascha Romanovsky for accepting me as his advisee while I was a Research Assistant of the COMPASS project.
His comments, instructions, and knowledge were of great importance for this work.

My stay in Newcastle upon Tyne couldn't be as good as it was without the hospitality, useful discussions, and support of my colleagues at Newcastle University.
A big THANK YOU to John Fitzgerald, Zoe Andrews, Richard Payne, Claire Smith, Dee Carr, Claire Ingram, my shared office colleague Anirban Bhattacharyya, and all other staff members.

Still in Newcastle upon Tyne, I thank all friends my family and I made outside University.
Thanks to Kelechi Dibie and her family to welcome us for the Christmas' and new year's dinners.
They were our family abroad.

I thank all my family for their patience to have me away in several family reunions, due the time required to do this work.
In special, my two girls and my wife.

\end{agradecimentos}

\begin{epigrafe}

  \vspace*{\fill}
  \begin{flushright}
  \textit{‘‘Mathematical reasoning may be regarded
  rather schematically as the exercise of a combination of two facilities,
  which we may call intuition and ingenuity.\\
  (Alan Turing)}
  \end{flushright}

\end{epigrafe}

%\begin{epigraph}[]{Alan Turing}
% quotes from: http://www.brainyquote.com/quotes/authors/e/edsger_dijkstra.html
% http://www.brainyquote.com/search_results.html?q=boole
% http://www.azquotes.com/author/14856-Alan_Turing
%Mathematical reasoning may be regarded rather schematically as the exercise of a combination of two facilities, which we may call intuition and ingenuity.
%\end{epigraph}

%%
%%
%% Mapeamento inglês - português
%%
%% fault - falha
%% error - erro
%% failure - defeito

\begin{resumo}[Resumo]
\begin{otherlanguage*}{brazil}
A modelagem de falhas é essencial na antecipação de falhas em sistemas críticos.
Tradicionalmente, Árvores de Falhas Estáticas são empregadas para este fim, mas Árvores de Falhas Temporais e Dinâmicas têm ganhado evidência devido ao seu maior poder para modelar e detectar propagações complexas de falhas que levam a um defeito.

Em um trabalho anterior, mostramos uma estratégia baseada na álgebra de processos CSP e modelos Simulink para obter rastros (sequências) de falhas que levam a um defeito.
A partir dos rastros de falhas nós descartamos a informação de ordenamento para obter expressões de estrutura  para Ávores de Falhas Estáticas.
Ao contrário de descartar tal informação de ordenamento, poderíamos usá-la para obter expressões de estrutura para Árvores de Falhas Temporais ou Dinâmicas.

No presente trabalho, apresentamos uma álgebra temporal de falhas (com noção de propagação de falhas) para analisar defeitos em sistemas e provamos que ela é de fato uma álgebra Booleana.
Isso permite herdar as propriedades de álgebras Booleanas, leis e técnicas de redução existentes, as quais são muito benéficas para a modelagem e análise de falhas.
Com expressões na álgebra temporal de falhas nós permitimos a verificação de propriedades de segurança (\emph{safety}) baseadas em Árvores de Falhas Estáticas, Temporais ou Dinâmicas.
Nós ilustramos nosso trabalho com alguns estudos de caso simples, mas reais, fornecidos pelo nosso parceiro industrial, a EMBRAER.

Isabelle/HOL foi utilizado para a mecanização das provas dos teoremas da álgebra temporal de falhas.

\vspace{\onelineskip}
\noindent
\textbf{Palavras-chave}: Simulink, CSP, FDR, Fault Tree Analysis, Temporal Fault Trees, Dynamic Fault Trees, Isabelle/HOL, Pandora, Fault Injection
\end{otherlanguage*}
\end{resumo}


%\begin{keywords}
%Simulink, CSP, FDR, Fault Tree Analysis, Temporal Fault Trees, Dynamic Fault Trees, Pandora, Fault Injection
%\end{keywords}

\begin{resumo}
Fault modelling is essential to anticipate failures in critical systems.
Traditionally, Static Fault Trees are employed to this end, but Temporal and Dynamic Fault Trees have gained evidence due to their enriched power to model and detect intricate propagation of faults that lead to a failure.

In previous work, we showed a strategy based on the process algebra CSP and Simulink models to obtain fault traces that lead to a failure.
From the fault traces we discarded the ordering information to obtain structure expressions for Static Fault Trees.
Instead of discarding such an ordering information, it could be used to obtain structure expressions of Temporal or Dynamic Fault Trees.

In this work we present an algebra of temporal faults (with a notion of fault propagation) to analyse systems' failures, and prove that it is indeed a Boolean algebra.
This allows us to inherit Boolean algebra's properties, laws and existing reduction techniques, which are very beneficial for fault modelling and analysis.
With expressions in the algebra of temporal faults we allow the verification of safety properties based on Static, Temporal or Dynamic Fault Trees.
We illustrate our work on simple but real case studies, some supplied by our industrial partner EMBRAER.

Isabelle/HOL was used to mechanize the theorems proofs of the algebra of temporal faults.

\vspace{\onelineskip}
\noindent
\adnote{Adicionar MSC2010 06E25, 68M15, 68Q60, 93A30}
%\begin{keywords}
\textbf{Keywords}: Simulink, CSP, FDR, Fault Tree Analysis, Temporal Fault Trees, Dynamic Fault Trees, Isabelle/HOL, Pandora, Fault Injection
%\end{keywords},
\end{resumo}

% List of figures
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage

% List of tables
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage

% List of acronyms
% Acronyms manual: http://linorg.usp.br/CTAN/macros/latex/contrib/acronym/acronym.pdf
%\input{acronyms}
%\listofacronyms

\acresetall
\pdfbookmark[0]{\listadesiglasname{}}{acro}
\printacronyms[name={\listadesiglasname{}},heading=chapter*,exclude-classes={gate}]
\acresetall
\setcounter{table}{0}
\cleardoublepage

\pdfbookmark[0]{Fault tree gates}{ftgates}
\printacronyms[name={\Acl*{FT} gates},heading=chapter*,include-classes={gate}]
\acresetall
\setcounter{table}{0}
\cleardoublepage


% Summary (tables of contents)
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\acresetall
\cleardoublepage

%\mainmatter
\textual

\chapter{Introduction}
\label{chap:intro}

\adnote{use all figure captions before figures (ABNT)}
\adnote{fix table lines (ABNT)}

The development process of critical control systems is based essentially on the rigorous execution of guides and regulations~\cite{ANAC2011,FAA1993,FAA2007,SAE1996b}.
Specialized agencies (like FAA, EASA and ANAC in the aviation field) use these guides and regulations to certify such systems.

Safety is a system's attribute that plays a crucial concern on critical systems and it is the responsibility of the safety assessment process.
To employ such a process, dependable systems taxonomy and safety assessment techniques must be well defined and understood.
Clarification of concepts of dependable systems can be surprisingly difficult when systems are complex, because the determination of possible causes or consequences of failure can be a very subtle process~\cite{ALR+2004}.

ARP-4761~\cite{SAE1996b} defines several techniques to perform safety assessment.
One of them is \ac{FTA}\index{Fault Tree Analysis}.
It is a deductive method that uses trees to model faults and their dependencies and propagation.
In such trees, the premises are the leaves (basic events) and the conclusions are the roots (top events).
Intermediary events use gates to combine basic events and each kind of gate has its own combination semantics definition.
\Acp{FT} that use only \ac{OR} and \ac{AND} gates are called \emph{coherent \aclp{FT}}~\cite{Andrews2001,AB2003,Oliv2006,CCR2008,Vaurio2016}\index{Fault Tree!coherent}.
They combine the events as \emph{at least one shall occur} and \emph{all shall occur}, respectively.
To analyse \acp{FT}, their structures are abstracted as Boolean\index{Boolean Algebra} expressions called \emph{structure expressions}\index{structure expression}.
The analysis of coherent \acp{FT} uses a well-defined algorithm based on the Shannon's method\index{Binary Decision Diagrams!Shannon's method} to obtain \acp{MCS} from the structure expressions\index{structure expression}, and a general formula to calculate the probability of top events.
The \acp{MCS} are obtained by reducing structure expressions to a normal form, in which each term is a combination of variables (basic events) with conjuctive (\ac{AND}) gates, and the terms are combined as disjunctive (\ac{OR}) gates.
These minimal terms are also called \emph{prime implicants} or \emph{minterms}.
The Shannon's method\index{Binary Decision Diagrams!Shannon's method} originated a formalism to reduce structure expressions called \ac{BDD}\index{Binary Decision Diagrams}.
Another approach to reduce structure expressions is to use a mathematical model---called \acf{FBA}---that uses sets of sets to represent Boolean expressions.

Besides the traditional \ac{OR} and \ac{AND} gates, the \FThandbook defines other gates.
For example the \ac{PAND} gate, which considers the order of occurrence of events.
Although the \FThandbook defines these new gates, there is no algorithm to perform the analysis of trees that contain such new gates.
This and the need of analysis of dynamic aspects of increasingly complex systems motivated the introduction of two new kinds of \aclp{FT}: \acp{DFT} and \acp{TFT}.
These variant trees can capture sequential dependencies of fault events in a system.
The difference from \ac{TFT} to \ac{DFT} is that \acp{TFT} use temporal gates directly, while \ac{DFT} does not---\acp{DFT} gates are an abstraction of temporal gates.
To differentiate the \aclp{FT} as defined in the \FThandbook from the other two, we will call them \acp{SFT}.

The work reported in~\cite{WP2009} aims at performing the full implementation of the \FThandbook, adding temporal gates to its \pandora methodology.
It was this implementation that introduced the new concept of \acp{TFT}, cited previously.
In such trees, events ordering is well-defined and an algebraic framework was proposed to reduce structure expressions\index{structure expression} to obtain \acp{MCSeq} and perform probabilistic analysis.
Reducing expressions is also desirable to check for tautologies, for example.

\Acp{DFT} introduce very different gates to capture dynamic configurations of systems: \ac{CSp}, \ac{FDEP}, and \ac{SEQ}.
The semantics of the first is to add ``backup'' events, so the gate is active if the primary event and all spares are active.
The second adds basic events dependency from a trigger event.
The third forces the occurrence of events in a particular order.
There is also \iac{WSp} gate that is slightly different from the \ac{CSp} gate.
They differ on the nature of sparing, whether fast (warm, always-on) or slow (cold, stand-by).
The readiness of the backup system in \iac{WSp} gate is higher than in \iac{CSp} gate.
The work reported in~\cite{MRL2011} shows an algebraic framework to compositionally reduce \ac{DFT} gates to order-based gates and perform probabilistic analysis of structure expressions\index{structure expression}. Thus, despite some limitations for spare gates~\cite{MRL2014}, the structure expressions\index{structure expression} used in \acp{TFT} and \acp{DFT} can be formulated in terms of a generic order-based operator.

\begin{sloppypar}
The \ac{NOT} operator is absent in the algebras reported in~\cite{WP2009,Walker2009,Merle2010,MRL2011b}.
There is no consensus about the relevance of its use:
\begin{alineasinline}
  \item it can be misleading, generating non-coherent analysis~\cite{Oliv2006}, or
  \item it can be essential in practical use~\cite{Andrews2001}.
\end{alineasinline}
Our concern is that the decision of the relevance of its use should not be due to the choice of events-occurrence representation.
The algebra created in this work defines the \ac{NOT} operator and allows its use, as we show in \cref{chap:strategy}.
\end{sloppypar}

\begin{sloppypar}
\Ac{hiphops} is a set of methods and tools to analyse \acp{FT}.
The semi-automatic generation of \acp{FT} has architectural models and failure expressions as inputs.
The failure expressions are in fact structure expressions of components or subsystems.
These expressions are annotated in components and subsystems and describe how they fail.
The tool combines these expressions with regard to the architecture to generate \acp{FT}.
The work reported in~\cite{WP2008} shows a strategy to use the semi-automatic \ac{FT} generation of \ac{hiphops} with \pandora to generate structure expressions of \acp{TFT}.
\end{sloppypar}

In previous work~\cite{Didier2012,DM2012}, we proposed a systematic hardware-based faults identification strategy to obtain failure expressions as defined in \acifused{hiphops}{\acs{hiphops}}{\acscite{hiphops}} for \acp{SFT}.
%
We considered faults in components or subsystems, but if we obtain failure expressions of a whole system, they are in fact structure expressions\index{structure expression} of \iac{FT}.
%
Our strategy throws away the ordering information of the fault event sequences to generate failure expressions for components or subsystems for \acp{SFT}.
%
%Using our strategy as input for \ac{hiphops} we obtain a failure expression of a fault tree.
%
We focused on hardware faults because we assume that software does not fail as a function of time (wear, corrosion, etc).
%
We inherited this view from our industrial partner (\EMBRAER), which assumes that functional behaviour is completely analysed by functional verification~\cite{SP2011}.
%
We followed industry common practices using \simulink diagrams~\cite{Nise1992} as a starting point.
%
The work reported in~\cite{DM2012} was based on \ac{CSPm} to allow an automatic analysis using the model checker \acs{FDR}.
%
Thus, our strategy required the translation from \simulink to \ac{CSPm}~\cite{JMS+2011}.
%
It then runs \acs{FDR} to obtain several counter-examples (which are fault traces) ending in failures.
%
For two case studies provided by our industrial partner, \EMBRAER, we showed that our automatically created failure expressions match with the engineer's provided ones or are better (a weaker proposition).

\section{Research questions}

Both \ac{TFT} and \ac{DFT} lack a first-order logic mathematical model like the one defined for \ac{SFT}.
For \acp{SFT}, mathematical models to reduce structure expressions are either based on set inclusion, with \ac{FBA}, or through tree search, with \ac{BDD}\index{Binary Decision Diagrams}.
Both are efficient.
One important concern on employing \ac{FTA} is whether \iac{FT} indeed represents a system behaviour.
The work reported in~\cite{MCS+1999} exposes this concern for \acp{DFT}, and the \ac{hiphops} framework---related to \acp{SFT} and \acp{TFT}---aims at getting this issue sorted out.
Our contribution to this issue for \ac{SFT} is shown in~\cite{DM2012,Didier2012}.

The mathematical model for \ac{TFT} has a discontinuity between two activation states:
\begin{alineasinline}
  \item non-occurrence, and
  \item occurrence some time later.
\end{alineasinline}
Such a discontinuity has some drawbacks as, for example, the impossibility to use \ac{NOT} gates, and handling the specific case of non-occurrence with zeros in \acp{TTT}.
The reduction of structure expressions in \ac{TFT} is based on a combination of:
\begin{alineasinline}
  \item algebraic reduction---which can unfortunately result in an infinite application of rules---,
  \item modularisation of independent subtrees (subtrees not always are independent), and
  \item \ac{DT}---which are limited to seven basic events, due to exponential growth.
\end{alineasinline}


\begin{sloppypar}
Most mathematical models~\cite{LHT2013,CSD2000,BRM+2005} for \ac{DFT} are based on the formalisation of \ac{DTMC} or \ac{CTMC} because \acp{DFT} were initially conceived to be a visual representation of such models.
As both \ac{DTMC} and \ac{CTMC} are state-based, they experience the state-space explosion problem.
The works reported in~\cite{BKK+2003,BHH+2003,SAE1996b} show techniques to overcome this problem, but the reduction can be infeasible because it depends on systems' models particularly, whether they are independent or not.
\end{sloppypar}

There are other approaches, however.
For instance, a modified version of \ac{BDD}\index{Binary Decision Diagrams} to tackle events ordering, called \acf{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential}, to reduce structure expressions, and the work reported in \cite{BRM+2005}, which proposes a conversion of \ac{DFT} into \ac{DBN} to perform probabilistic analysis.

The approach to tackle events ordering with \ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential}~\cite{XTD2012} has two kinds of nodes: terminals and non-terminals (terminals are nodes with basic events, and non-terminals are nodes with two events and an operator).
Although demonstrated in~\cite{Bryant1986} that these unconventional nodes (non-terminals) generate correct and efficient Boolean analysis, the analysis is still dependent on the order-related operators because the relation of terminals and non-terminals is not established directly (non-terminals are seen as an independent node in~\cite{XTD2012}).
For example, the occurrence of $A \rightarrow B$ is related to the occurrence of $A$ and $B$, but this relation is obtained in a further step, not in the \ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential}.

The approach using the construction of \acp{DBN}~\cite{BRM+2005} is automatic and handles time slices as $t + \Delta t$, which implies a notion of events ordering as well.
As it is focused in probabilistic analysis, qualitative analysis is not directly supported.

The works reported in~\cite{Merle2010,XTD2012} show that \acg{DFT} operators can be converted into order-related operators, simplifying \ac{DFT} analysis.
Although the mathematical model presented in~\cite{Merle2010} establishes a denotational semantics for order-related operators, it lacks a formal method for expression reduction based on such a model.
It defines, instead, several algebraic laws to reduce expressions and an algorithm to minimize the structure function.

\begin{sloppypar}
\Ac{hiphops} proposes a hierarchical approach to model systems and perform \ac{FTA} (and \ac{FMEA}).
Although there is a tool to model and analyse systems using \ac{hiphops}, \acp{FT} construction is based on an algorithm, without proofs for soundness or completeness.
\end{sloppypar}

%The work reported in~\cite{AH2015} shows the formalisation of probabilistic analysis of \ac{SFT} and uses the same concept of date-of-occurrence shown in \adnote{cite Merle work}.

From the exposed in this section, our research question is:
\begin{rqenum}[series=researchquestion]
  \item Is there a mathematical model to analyse \acp{TFT} and \acp{DFT} that is set-based and similar to \ac{FBA}?\label{question:mathematical-model}
\end{rqenum}
%
Also, does such a model:
%
\begin{rqenum}[resume*=researchquestion]
  \item have the capacity of representing events ordering similar to \ac{TFT} and \ac{DFT}\label{question:ordering-representation}?
  \item represent systems behaviour by construction\label{question:gap}?
  \item allow both qualitative and quantitative analyses as supported by \ac{TFT} and \ac{DFT}\label{question:analyses}?
  \item perform reduction of structure expressions to a normal form at least as efficiently as current approaches\label{question:efficiency}?
\end{rqenum}

%
%In this work we propose a theory that answers \cref{question:mathematical-model,question:ordering-representation,question:gap,question:analyses}. 
%\Cref{question:efficiency} is left as a future work.

\section{Proposed solution}

%In this work we present an algebra, called \acf{algebra}, defined  denota
\adnote{Continue from here: what's denotational semantics?}

In this work we present an algebra, called \acf{algebra}, to analyse acceptance criteria of \acp{FT} with ordering of fault events (\ac{TFT} and \ac{DFT}).
The laws of \ac{algebra} are given in a denotational semantics based on sets of lists of distinct elements.
\Theac{algebra} aims at answering the \cref{question:mathematical-model,question:ordering-representation}.
The analysis of acceptance criteria is a decision problem and we use first-order logic and \isabellehol as verification tool.
Indeed, \ac{algebra} is part of a bigger strategy the relates fault injection on nominal models, fault modelling, \ac{FTA}, and fault tolerance patterns.
In \cref{fig:strategy-overview} the strategy starts in the top (green) node and ends in the bottom (red) node.
Fault events are either extracted from a nominal model with injected faults (\cref{fig:strategy-overview}, path A), or modelled using a proposed notation, called \ac{activation} (\cref{fig:strategy-overview}, path B).
We depict traditional \ac{FTA} in path C to compare to our strategy and because we still need part of the traditional \ac{FTA} to obtain the acceptance criteria, which are the expected properties of system's \acp{FT}.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.9]{StrategyOverview}
  \caption{Strategy overview}
  \label{fig:strategy-overview}
\end{figure}

System and fault modelling is an essential step towards safety analysis.
Architectural modelling is the first step of the strategy and can be executed either in a graphical tool, or as requirements in natural language.
For example, our work reported in~\cite{APR+2013,ADP+2013} uses fault modelling in \ac{SysML} to verify fault tolerance of \acp{SoS}.

The ``Faults injection'' block in \cref{fig:strategy-overview}, path A, is obtained from part of our work reported in~\cite{DM2012,Didier2012}.
It starts with \simulink modelling, converts the model to \ac{CSPm} and then obtains fault event sequences.
The fault event sequences are then mapped to \theac{algebra}, which have a denotational semantics based on sets of lists.
As fault names are obtained directly from components and subsystems in a \simulink model, \theac{activation} (in the ``Fault Modelling'' group) allows them to be modified or complemented.
\Theac{activation} also allows reasoning about faults that are not modelled in \simulink as, for example, common cause or environmental faults.
Path A aims at answering the \cref{question:gap}.
Given the flexibility of the \ac{activation} notation, it can be used directly (path B) to model faults formally, reasoning about basic fault events and top-event failures, which are related to~\ref{question:ordering-representation}.
Each predicate in \ac{activation} generates an expression in \theac{algebra}, which are reduced to obtain a canonical form to obtain \acp{MCSeq} and to calculate top-events probability, which is related to~\ref{question:mathematical-model}.
%Paths A and B aim at answering the \ref{question:gap}.

\Theac{FTA} has associated non-functional system requirements which are in fact acceptance criteria for \acp{FT}.
Once acceptance criteria are modelled as expressions in \ac{algebra}, we formally check whether they are accepted by system models' expressions.
The acceptance criteria can be either qualitative or quantitative.
An example of qualitative acceptance criteria is: ``\iac{FT} cannot have \ac{MCS} with less than three basic events''.
A quantitative acceptance criteria example is: ``the top-level event probability shall be less than $10^{-8}$''.
The acceptance criteria analysis aims at answering the \ref{question:analyses}.

\section{Contributions}

The main contributions of this work are:

\begin{contrenum}[series=contributions]
  \item Define a denotational and algebraic model to express fault events order with \theac{algebra}---see \cref{chap:strategy};
  %\item Formally verify \acg{FT} (\ac{TFT} and \ac{DFT}) acceptance---to do;
  \item From \simulink models, obtaining fault event sequences and mapping to \ac{algebra}---partially done, see \cref{chap:strategy};
  \item Reason about fault modelling in \ac{activation}, to obtain formal expressions of critical failures (top-event failures)---see discussion in~\cref{sec:activation};
  \item Illustrate the application of the laws on a real case study, provided by our industrial partner, \EMBRAER---see \cref{chap:case-study}.
  \item Define a new operator to express order explicitly and proving that the resulting algebra---(\ac{algebra}) using this operator and Boolean\index{Boolean Algebra} operators---is a conservative extension of the Boolean algebra\index{Boolean Algebra} (also published in~\cite{DM2016})---see \cref{chap:strategy};
  \adnote{When accepted, add work submitted to ISF}
  %\item Generalise laws in~\ac{algebra} in terms of abstract properties, similar to healthiness conditions in \theac{UTP}---to do.
\end{contrenum}

We use \isabellehol, theories in \isabellehol{'s} library, and a theory in the AFP library \cite{JM2005} to prove all theorems presented in this work.
%We omit the proofs in the paper, but they are available in Online Resource 1.\todo{publish theory files online: ``Specialized format such as .pdb (chemical), .wrl (VRML), .nb (Mathematica notebook), and .tex can also be supplied.''}

\section{Thesis organization}

This thesis is organized as follows: in \cref{chap:basic-concepts,chap:analysis} we show the concepts and tools used as basis for this work.
\Cref{chap:strategy} presents our strategy, \cref{chap:case-study} the case study and the application of the proposed strategy, and we present our conclusions and future work in \cref{sec:conclusion}.
The contributions presented in this work are summarized in terms of proved results.
To facilitate the understanding of the presented strategy, the effort to build laws and theirs (mechanized) proofs are shown in \cref{app:formal-proofs-isabelle-hol}.

\isabellehol{'s} theory files with all proofs are available at \algebraurl.

\chapter{Basic concepts}
\label{chap:basic-concepts}

Means to dependability\index{Dependability}\amnote{Está muito filosófico isto. É assim mesmo ou seja, não há uma definição para dependebilidade?} \adnote{Eu explico dependabilidade a seguir.} are obtained by modelling and analysing a system.
It is strongly related to fault modelling, which depends on the kinds of analyses we want to perform.
%For instance, in \aclp{FT}, even if a fault can be repaired, it is considered as a non-repairable fault.
\Acp{FT} are present in several stages of systems' modelling.
We introduce dependability\index{Dependability} and fault modelling in \cref{sec:dependability}.

\Iac{SFT} is a snapshot\footnote{Whether a top event indeed causes a catastrophic or major failure is out of the scope of this thesis; we consider that, if it is possible that such failure occur, then it will.} of a faults topology of a system, subsystem or component.
%\acp{TFT} and \acp{DFT} uses sequences of fault events because they consider a time relation on fault events.
The time relation of fault events in \acp{TFT} and \acp{DFT} allows the analysis of different configurations (or snapshots) of a system, subsystem or component.
We discuss these time relations in \cref{sec:time-relations}.

\section{Systems, dependability\index{Dependability}, and fault modelling\index{fault modelling}}
\label{sec:dependability}

\begin{sloppypar}
Computing systems are characterized by five properties: functionality, performance, cost, dependability\index{Dependability}, security.
The work reported in~\cite[p. 289--302]{Sommerville2011} explain these properties---including dependability\index{Dependability}---with a focus on software.
Hardware and software are connected, as software faults may cause a failure in a software-controlled hardware, and hardware faults may send incorrect data, causing a failure in the software.
\end{sloppypar}

The work reported in~\cite{ALR+2004} summarizes all concepts of and related to dependability\index{Dependability} for computing systems that contain software and hardware.
In the following, we show these concepts and highlight those used in this work.

\subsection{Systems}

Before introducing systems' dependability\index{Dependability}, we first describe what a system is and its characteristics.
A \emph{system} is an entity that interacts with other systems (software and hardware as well), users (humans), and the physical world.
These other entities are the \emph{environment} of the given system, and its \emph{boundary} is the frontier between the system and its environment.

The \emph{function} of a system is what the system is intended to do, and its \emph{behaviour} is what the system does to implement its function.\amnote{Você continua muito filosófico aqui. Quero ver para onde vamos (uso)...} \adnote{Isso faz parte do contexto para quando mencionar os termos eles terem sido introduzidos.}
The \emph{total state} of a system are the means to implement its function and is defined as the set of the following states: computation, communication, stored information, interconnection, and physical condition.
The \emph{service} delivered by a system is its behaviour as it is perceived by its boundary.
A system can both provide and consume services.

The \emph{structure} of a system is how it is composed: a system is composed of components, and each component is another system, etc.
This concept of hierarchical compositionality in systems is what originated the concept of \ac{SoS} and is the object of analysis in \ac{hiphops}.
Such a recursion (of a system containing other systems) stops when a component---or a constituent system---is considered to be atomic.
A system is the total state of its atomic components.

\subsection{Dependability}
\index{Dependability}

The concepts that create the basis for dependability\index{Dependability} are:
\begin{alineasinline}
  \item threats to,
  \item attributes of, and
  \item means to attain.
\end{alineasinline}

\emph{Threats to dependability}\index{Dependability!threats to} are the so-called \emph{fault-error-failure} chain.
A failure is a service deviation perceived on systems' boundary.
An error is the part of the total state of a system that leads to subsequent service failure.
Depending on how a system tolerate internal errors, many errors may not reach system's boundary.
Finally, a fault is what causes an error.
In this case, we say that the fault \emph{occurred} (the fault is active).
Otherwise, the fault is dormant, and has not occurred (yet).
A \emph{degraded} mode of a system is when there are active faults, so some functions of the system are inoperative, but the system still delivers its service.

There are two acceptable definitions of dependability\index{Dependability} reported in~\cite{ALR+2004}.
One is more general, difficult to measure: ``the ability to deliver service that can justifiably be \emph{trusted}''.
A more precise definition that uses the definition of service failure is: ``the ability to avoid service failures that are more frequent and more severe than is acceptable''.
This definition has two implications about system's requirements: there should be defined how it can fail, and what are the acceptable severity and frequency of its failures.

The following systems' dependability attributes\index{Dependability!attributes of} enlightens such requirements:
\begin{description}
  \item[Availability:] the readiness for correct service;
  \item[Reliability:] continuity of correct service;
  \item[Safety:] absence of catastrophic consequences on the environment (other systems, users, and the physical world).
  Safety can be verified using \acp{FT}, which is part of the objective of this work;
  \item[Integrity:] absence of improper systems alterations;
  \item[Maintainability:] ability to be modified and repaired.
\end{description}
%
A system description should mention all or most of these attributes, at least the first three of them.

The implementation of these attributes requires a deep analysis of system's models.
The \emph{means to attain dependability}\index{Dependability!means to attain} are summarized as follows:

\begin{description}
  \item[Prevention] is about avoiding incorporating faults during development.
  \item[Tolerance] deals with usage of mechanisms to still deliver a---possibly degraded---service even in the presence of faults.
  \item[Removal] is about detecting and removing (or reducing severity of) failures from a system, both in the development and production stages.
  \item[Forecasting] is about predicting likely faults so they can removed, or tackling their effects.
\end{description}

\begin{sloppypar}
The intersection of the current work with dependability\index{Dependability} is in fault removal during development and fault tolerance (analysis).
Following the taxonomy presented in~\cite{ALR+2004}, there are some techniques for fault removal, summarized as follows:
\begin{alineas}
  \item Static verification:
  \begin{subalineas}
    \item Structural model:
    \begin{description}
      \item[Static analysis:] Range from inspection or walk-through, data flow analysis, complexity analysis, abstract interpretation, compiler checks, vulnerability search, etc.
      \item[Theorem proving:] Check properties of infinite state models.
    \end{description}
    \item Behaviour model:
    \begin{description}
      \item[Model checking:] Usually the model is a finite state-transition model (\acp{PN}, finite state automata).
      Model-checking verifies all possible states on a given system's model.
    \end{description}
  \end{subalineas}
  \item Dynamic verification:
  \begin{subalineas}
    \item Symbolic inputs:
    \begin{description}
      \item[Symbolic Execution:] It is the execution with respect to variables (symbols) as inputs.
    \end{description}
    \item Actual inputs:
    \begin{description}
      \item[Testing:] Selected input values are set on system's inputs and their outputs are compared to expected values.
      The verification outcomes are observed faults, in case of hardware testing or software mutation testing, and criteria-based, in case of software testing.
    \end{description}
  \end{subalineas}
\end{alineas}
\end{sloppypar}


Verification methods are often used in combination.
For example, symbolic execution may be used to obtain testing patterns, test inputs can be obtained by model-checking as in~\cite{CBC+2015}, faults can be used as symbolic inputs, and system behaviour can be observed using model-checking as in~\cite{DM2012,Didier2012} (This technique is called fault injection; see also~\cite{AAL+1996}).

The techniques to attain fault tolerance are summarized as follows:
\begin{description}
  \item[Error detection:] is used to identify the presence of an error.
  It can be a concurrent or a preemptive detection.
  Concurrent detection takes place during normal service, while preemptive detection takes place while normal service is suspended.
  \item[Recovery:] transforms a system state that contains errors into a state without them. The behaviour of the system upon recovery is equivalent to the normal behaviour.
  Techniques range from rollback to a previously saved state without errors, error masking, isolation of faulty components, to reconfiguration using spare components.
\end{description}

In this work, we use a combination of:
\begin{alineasinline}
  \item fault-injection,
  \item theorem proving, and
  \item symbolic execution.
\end{alineasinline}
We use these methods to obtain an erroneous behaviour of the system which is compared to the system dependability attributes\index{Dependability!attributes of} (safety).
We explain how these methods are combined in \cref{chap:strategy}.

\subsection{Fault Modelling}

Fault modelling plays an important role in reasoning about the fault-error-failure chain.
They are the initial steps to perform the verification of a system, starting in the architectural model to reason about the critical failures, which are (in general) the top-events in \acp{FT}.

\Ac{SysML} is a profile for \ac{UML} that provides features to model structure and behaviour of systems.
The works reported in~\cite{APR+2013,ADP+2013} define several structural and behavioural views in \ac{SysML} to model the fault-error-failure chain and fault tolerance.
Fault, error, failures, and fault propagation have structural views, which are related to behavioural views to describe fault activation and recovery.
These works map \ac{SysML} to two formal languages---\ac{CML} and \ac{CSP}, respectively---to verify fault tolerance.

In~\cite{SAE1996b} the safety assessment process for civil airborne systems and equipment describes development cycles and methods to ``clearly identify each failure condition''.
The methods that involve failure identification are:
\begin{alineasinline}
  \item \ac{SFT},
  \item \ac{DD},
  \item \aca{DTMC}, and
  \item \ac{FMEA}.
\end{alineasinline}
The first three are top-down methods, that start with undesired failure conditions and moves to lower levels to obtain more detailed conditions that causes the top-level event.
\Acp{DD} are an alternative method of representing the data in \ac{SFT}.
\Ac{FMEA} is a bottom-up method that identifies failure modes of a component and determines the effects on the upper level.
We detail \ac{SFT} in \cref{sec:static-fault-trees}.

\Acp{DFT} are an extension of \acp{SFT} and models dynamic behaviour of system faults.
Similarly to the relation of \acp{SFT} and \acp{DD}, the work reported in~\cite{DP2009} demonstrates the relation of \acp{DFT} to \acp{DRBD}.
As the models (\ac{DFT} and \ac{DRBD}) are equivalent, this work sticks to \ac{DFT} due to the amount of work already published.
We detail \acp{DFT} in \cref{sec:dynamic-fault-trees}.

\section{Time relation of fault events}
\label{sec:time-relations}

The most general case for time relations\index{time relations}\index{order!time relations} is to consider that each fault event has a continuous time duration.
They are the basis on how fault events discretisation are defined.
In \cref{fig:time-relations} we show all possibilities of event relations in a continuous time line (from $A$ to $B$; the converse relation is similar):

\begin{description}
  \item[a.] $A$ starts and ends before $B$ starts;
  \item[b.] $A$ starts before and ends after $B$ has started, but before $B$ has ended;
  \item[c.] $A$ starts before $B$ and ends after $B$ has ended ($A$ contains $B$);
  \item[d.] $A$ and $B$ start at the same time, but $A$ ends before $B$;
  \item[e.] $B$ starts after $A$, but they end at the same time;
  \item[f.] $A$ and $B$ start and end at the same time;
  \item[g.] $A$ starts before $B$ and ends when $B$ starts.
\end{description}

Although the occurrence of fault events has at least seven possibilities, what really matters when analysing systems is when a fault is \emph{detected}.
Considering that fault detection corresponds to the start of a fault event, from \cref{fig:time-relations} we clearly identify which event comes first: $A$ comes before $B$, except in the cases (d) and (f), where they start exactly at the same time.
If fault events are independent (they are not susceptible to have a common cause) then the probability of them starting at the same time is very low.
In \cref{chap:strategy} we abstract event relations in continuous time as an \emph{exclusive before} relation, based on fault \emph{detection} (it is similar---at least implicitly---to what is reported in~\cite{WP2009,MRL2011}).


\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{time-relations}
  \caption{Relation of two events with duration}
  \label{fig:time-relations}
\end{figure}

\chapter{Analysis and tools}
\label{chap:analysis}

Structure expressions\index{structure expression} are used to analyse \aclp{FT}.
In general, a structure expression\index{structure expression} comes from gates semantics and basic events.
Basic events become variables and gates become operators (a gate may become one or more operators).
In \cref{sec:fault-trees} we explain \acp{SFT}, \acp{TFT}, \acp{DFT}, and their respective structure expressions\index{structure expression}.

\Acp{FBA} and \acp{BDD}\index{Binary Decision Diagrams} are the basis to analyse structure expressions.
Also, we were inspired by \ac{FBA} concepts to create our \acl{algebra} (\cref{chap:strategy}).
We explain \acp{BDD}\index{Binary Decision Diagrams} and derived techniques in \cref{sec:structure-expressions-analysis}, and \acp{FBA} in \cref{sec:fba}.

The use of the Boolean\index{Boolean Algebra} operator \emph{NOT}:
\begin{alineasinline}
  \item can be misleading, generating non-coherent \aclp{FT}, or
  \item can be essential in practical use.
\end{alineasinline}
We discuss such cases in \cref{sec:not-operator}.

To reuse a nominal model to analyse faults we need fault injection.
In \cref{sec:faults-injection} we explain how we used \simulink and \ac{CSPm} to inject faults and obtain failure expressions from a nominal model.

Finally, in \cref{sec:isabelle} we present basic usage of Isabelle/HOL\index{Isabelle/HOL} and \ac{Isar}, which were essential to carry out the proofs presented in this thesis.

\section{\Acl*{FTA} and structure expressions}
\label{sec:fault-trees}

\Ac{FTA} was introduced in the \FThandbook~\cite{VGR+1981} with \aclp{SFT}.
\Ac{FTA} is a deductive method that investigates what are the possible causes of an unwanted event.
The method starts with the top-level event as the unwanted event and the combination of lower-level events that can cause it.
Events are combined using gates, and each gate has a well defined semantics.
It continues until basic (atomic) events are reached.
\Iac{SFT} represents, in a single view---very often considering faults outside of the boundaries of a system---, different states in which a particular failure is active in a system.
The most traditional gates are \ac{AND} and \ac{OR}, which are equivalent to Boolean\index{Boolean Algebra} operators.
These gates are also called coherent gates\index{coherent gates} because they construct coherent trees (see \cref{sec:not-operator} about the use of \ac{NOT} gates).
%A Boolean expression represents the structure of \iac{SFT}.
%Qualitative and quantitative analysis are evaluated on these Boolean expressions, that are referred to as \emph{structure expressions}.
The \FThandbook shows other gates as, for example, the \ac{PAND} gate, but the \ac{FTA} with these gates is not well defined.
\Acg{SFT} gates and analysis are detailed in \cref{sec:static-fault-trees}.

\Acp{TFT} were created aiming at fully implementing the \FThandbook.
The \ac{PAND}\adnote{Eles são mencionados no FT handbook. Yannis viu a oportunidade de explorá-lo, assim como Dugan, com as \acp{DFT}.} gate was first defined for \acp{SFT}, but its analysis was left open in the handbook.
The semantics (and analysis) of \acp{TFT} is defined in terms of a denotational semantics based on \emph{sequence values}\index{Temporal Fault Tree!sequence value} to express ordering of events, thus tackling \acg{PAND} order.
We explain \acp{TFT} and the sequence values in \cref{sec:temporal-fault-trees}.

\begin{sloppypar}
With component and system design evolution, \acp{DFT} were created to tackle dynamic behaviour: fault-tolerance-related components (\ac{CSp}), functional dependency (\ac{FDEP}), and analysis of particular order of occurrence of faults (\ac{SEQ}).
\Acg{SFT} gates are still present as \acg{DFT} gates.
We explain them and \acg{DFT} analysis in \cref{sec:dynamic-fault-trees}.
\end{sloppypar}

The structure of \iac{FT} (or the structure of \iac{MCS}, explained further) is represented with a formula.
The variables represent occurrences of basic events.
Unary and binary relation symbols capture the semantics of gates.
A formula with these characteristics is called \emph{structure expression}\index{structure expression} or \emph{structure function}\index{structure expression!function} (as the expression depends on the variables).
The semantics of a structure expression is that the top-level event occurs if some combination of basic events occur.

\begin{sloppypar}
The results obtained from the \acp{FTA} are shown in the \FThandbook.
We summarize them as:
%
\begin{alineas}
  \item Qualitative
  \begin{description}
    \item[\Acp{MCS}\index{Fault Tree Analysis!minimal cut set}:]
    Smallest combinations of components failures causing system failure.
    They are obtained from the reduction of structure expressions to a normal form.
    For example, in \acp{SFT}, structure expressions\index{structure expression} are reduced to \ac{DNF}.
    Each term in a reduced \ac{DNF} is \iac{MCS}.
    \item[Importances\index{Fault Tree Analysis!qualitative importance}:]
    Qualitative rankings on contributions to system failure.
    A single fault causing a catastrophic failure is usually unacceptable.
    Ranking \acp{MCS} is the same as ordering them in ascending order of their size (smaller first).
  \end{description}
  \item Quantitative
  \begin{description}
    \item[Numerical probabilities\index{Fault Tree Analysis!numerical probability}:]
    Probabilities of system and \acg{MCS} failures.
    A system failure probability is obtained by assigning probabilities to basic events and then calculating it accordingly to gates' semantics.
    \Acg{MCS} failure probability is the calculation of the probability of the occurrence of \emph{all} basic events of a specific \ac{MCS}.
    \item[Importances\index{Fault Tree Analysis!quantitative importance}:]
    Quantitative rankings on contributions to system failure.
    Ranking \acp{MCS} is the same as ordering them in descending order of some unreliability formula (higher first).
    These formulas used to calculate importance vary.
    The most common are:
    \begin{alineasinline}
      \item system unavailability, and
      \item system failure occurrence rate.
    \end{alineasinline}
    \item[Sensitivity evaluation\index{Fault Tree Analysis!sensitivity evaluation}:]
    Modifying characteristics of components and evaluate their impact.
    For a particular event in a tree, a higher and a lower failure probability value are assigned.
    If system's unavailability is not changed, then such an event is not important---the system is not sensitive to such an event.
  \end{description}\end{alineas}
\end{sloppypar}

As stated in~\cite{SVD+2002}, there are other uses of \ac{FTA}.
One of great importance is using it to minimize and optimize resources, which has been object of study in \ac{hiphops}~\cite{APS+2011}.
Through importance measures\index{importance measure}, \ac{FTA} not only identifies what is important but also what is unimportant.
This removes components without impacting the overall failure probability, which is related to the quantitative importance\index{Fault Tree Analysis!quantitative importance} and sensitivity evaluation\index{Fault Tree Analysis!sensitivity evaluation}.

\begin{sloppypar}
In important stages of critical systems, \ac{FTA} plays an essential role.
At least three dependability means\index{Dependability!means to attain} can be achieved using \acp{FT}:
%
\todo{Improve the relations of dependability and FTA}
\begin{description}
  \item[Removal.]
  \Iac{FTA} calculates if the probability of failure of a subsystem.
   If such a probability is higher than a certain maximum reference, such a subsystem should be removed or left to be incorporated in combination with a more reliable component.
  \item[Tolerance.]
  \Iac{FTA} indicates whether a single fault---or fewer combinations than expected---could lead to a catastrophic failure.
  In this case, a system should have replication, or stages of fault detection and error handling.
  Also, the probability of failure of the chosen fault tolerance method can be evaluated.
\end{description}
\end{sloppypar}

In \cref{sec:static-fault-trees,sec:temporal-fault-trees,sec:dynamic-fault-trees} we briefly show \acpg{FT} symbology and means to analyse \acp{FT}.
We will detail its structure expressions extraction because they are a common means to perform both qualitative and quantitative analysis.

\subsection{\Aclp*{SFT}}
\label{sec:static-fault-trees}

\Acg{SFT} gates and structure expressions were used as basis for other kinds of tree, as in \acp{TFT} and \acp{DFT}.
We explain their symbology and semantics in this section.

The \FThandbook shows traditional symbols for gates and events.
Basic events are usually drawn as rectangle (for the text) and a circle below it, as shown in \cref{fig:sft-example-ald-software}, or as a circle with the text of the basic event, as shown in \cref{fig:sft-example-traditional-gates}.
Top-level and intermediary events are drawn as a rectangle (for the text) and a gate below it, as shown in \cref{fig:sft-example-traditional-gates,fig:sft-example-ald-software}.
When \iac{FT} becomes too large, transfer in and out symbols can be used.
They are usually drawn as triangles with a letter or a number.
\Cref{fig:sft-example-traditional-gates} depicts traditional gates as specified in the \FThandbook, and \cref{fig:sft-example-ald-software} shows \iac{FT} using \theftanalyser{}---a free commercial tool.
In this work, to keep a visual identity with other \acp{FT}, and to avoid symbols confusion, we use gates symbols as shown in~\cref{fig:sft-gates}.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[1]{sft-example-ald-software}
  \caption{\Ac{SFT} symbols using a free commercial tool}
  \label{fig:sft-example-ald-software}
\end{figure}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.9]{sft-symbols-ft-handbook}
  \caption{\acs{SFT} symbols as in the \FThandbook}
  \label{fig:sft-example-traditional-gates}
\end{figure}

\begin{figure}[htb]
  \centering
  \subcaptionbox{Basic event\label{fig:sft-basic-event}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.2]{ft-symbol-basic-event}
    }%
  \subcaptionbox{Intermediary event\label{fig:sft-intermediary-event}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.2]{ft-symbol-top-or-intermediary}
    }
  \subcaptionbox{\ac{AND} gate\label{fig:sft-and-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-and-gate}
    }
  \subcaptionbox{\ac{OR} gate\label{fig:sft-or-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-or-gate}
    }
  \subcaptionbox{\ac{NOT} gate\label{fig:sft-not-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-not-gate}
    }
  \subcaptionbox{Transfer symbol\label{fig:sft-transfer}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.15]{ft-symbol-transfer}
    }
  \caption{\ac{SFT} gates}
  \label{fig:sft-gates}
\end{figure}

Structure expressions\index{structure expression} in \ac{FTA} are defined in terms of set theory, using symbols for fault events occurrence.
%, using what is called of generative sets.
If a fault event symbol is in a set, then it means that this fault has occurred.
A set is a combination of fault events that causes the occurrence of the top-level event of a tree.
A structure expression\index{structure expression} of a tree is denoted by a set of sets of fault event combinations.
The \ac{OR} gate becomes the union operator between sets and the \ac{AND} gate, the intersection.
For example, if a system contains fault events \emph{a}, \emph{b}, and \emph{c}, \aclp{FT} for this system contain at most all these three events.
%The occurrence of a single event $a$ may be associated with the occurrence (or not) of the other events in any order.
The occurrence of the fault event $a$ is denoted by a set of sets $A$, which contains the following sets:
%
\begin{alineas}
  \item\label{item:fta-only-a-occurs} $\left\{a\right\}$: only \emph{a} occurs;
  \item\label{item:fta-a-and-b-occur} $\left\{a,b\right\}$: \emph{a} and \emph{b} occur in any order;
  \item\label{item:fta-a-and-c-occur} $\left\{a,c\right\}$: \emph{a} and \emph{c} occur in any order;
  \item\label{item:fta-all-occur} $\left\{a,b,c\right\}$: all three events occur in any order.
\end{alineas}
All sets of $A$ contain the fault event $a$.
Similarly, the sets of sets $B$---that represents the occurrence of $b$---contains all sets that contain the fault event $b$ (it includes the set $\setsin{a,b,c}$, for example).
%
%Fault event \emph{a} occurs in all possibilities.
%As these are sets, they represent combinations and not permutations.
%Combination $\left\{a,b,c\right\}$ represents the same as $\left\{b,a,c\right\}$, $\left\{c,b,a\right\}$, etc.
%Let the set that contains these sets be $A$.
%Similarly, let $B$ be the set of sets that contain the fault event $b$.

The \acl{FT} in \cref{fig:ex-fault-tree1} contains only two events and the resulting structure expression\index{structure expression} for this \ac{FT} is the expression $A \inter B$ ($TOP$), where $A$ and $B$ are the sets of sets that contain $a$ and $b$, respectively.
The resulting combinations for $TOP$ are $\left\{a,b\right\}$ and $\left\{a,b,c\right\}$ (fault events \emph{a} and \emph{b} occur in all possibilities).

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.45]{ex-fault-tree1}
  \caption{Very simple example of a \acl{FT}}
  \label{fig:ex-fault-tree1}
\end{figure}

After obtaining structure expressions\index{structure expression}, the next step is to reduce the expressions to a canonical form to obtain the \emph{\acp{MCS}}\index{Minimal Cut!Sets}, which are the sets that contain the minimum and sufficient events to activate the top-level failure.
%That is, \acp{MCS}\index{Minimal Cut!Sets} are the smallest sets of fault event that, if all occur, cause the top-level failure to occur.
Probabilistic analysis is then performed on these events to obtain the overall probability of occurrence of the top-level event.
The \FThandbook shows an algorithm based on Shannon's method\index{Binary Decision Diagrams!Shannon's method} to reduce structure expressions\index{structure expression} to obtain minimal cut sets\index{Minimal Cut!Sets}.
%BDDs are essentially the diagrams of Shannon's method.
The Boolean\index{Boolean Algebra} expression of the tree shown in \cref{fig:ex-fault-tree1} is $TOP = A \wedge B$.
A technique called \ac{BDD}\index{Binary Decision Diagrams}---which derives from Shannon's method\index{Binary Decision Diagrams!Shannon's method}---is explained in \cref{sec:bdd}.

\subsection{\Aclp*{TFT}}
\label{sec:temporal-fault-trees}

There are at least two versions of \acp{TFT}.
One is described in~\cite{Palshikar2002} and use a more traditional style of temporal logic (a variation of \ac{LTL}).
The other version is called \pandora and is the one we refer to in the following.

\Acp{TFT} express ordering of events by directly focusing on ordering relationships rather than different states of a system. Basically they extend \acg{SFT} \ac{PAND} gates, allowing analysis of \ac{FT} with such gates.
It is simpler to express than \ac{DFT}, but lacks the fault-tolerance-related gate of \acp{DFT} (which we show in \cref{sec:dynamic-fault-trees}).

\begin{sloppypar}
Structure expressions\index{structure expression} are also present in \acp{TFT}~\cite{WP2009,Walker2009,WP2010}, through the \pandora methodology.
These expressions use the \ac{SFT} operators \ac{OR} and \ac{AND}, and three new operators related to events ordering: \acf{PAND}, \ac{POR}, and \ac{SAND}.
The semantics of the \ac{PAND} in \acp{TFT} is similar to the semantics of the \ac{PAND} described in the \FThandbook.
To avoid ambiguous expressions, the semantics in \acp{TFT} is stated in terms of natural numbers, using a \emph{sequence value} function.
For every possible combination of events ordering, it assigns a sequence value to each fault event.
For example, if event A occurs before event B, then the sequence value of A is lower than the sequence value of B, and one formula to express this is $A \pand B$.
\end{sloppypar}

An invariant on sequence values is that there are no gaps for assigned values.
For example, if faults A and B occur at the same time and there are only these two events, then they should both be assigned value $1$.
On the other hand, if A occurs before B, then the assigned values are 1 and 2, respectively.
Value zero means that the event is not active on the combination.
Similar to Boolean's\index{Boolean Algebra} truth tables, the \pandora methodology defines \acp{TTT}.
They represent formula values for every combination of events.
\Cref{tbl:tft-operators} shows the \ac{TTT} of all \ac{TFT} operators accordingly to the semantics described in terms of a sequence value function $S$ as follows:
%
\begin{subequations}
  \begin{align}
    S\parsin{A \land B} &=
    \begin{cases}
      \max \parsin{S\parsin{A}, S\parsin{B}} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0\\
      0 &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \lor B} &=
    \begin{cases}
      \min \parsin{S\parsin{A}, S\parsin{B}} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0\\
      \max \parsin{S\parsin{A}, S\parsin{B}}, &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \pand B} &=
    \begin{cases}
      S\parsin{B} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0 \land S \parsin{A} < S \parsin{B}\\
      0 &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \por B} &=
    \begin{cases}
      S\parsin{A} &\quad \text{if } S \parsin{A} < S \parsin{B} \lor S \parsin{B} = 0\\
      0 &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \sand B} &=
    \begin{cases}
      S\parsin{A} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0 \land S \parsin{A} = S \parsin{B}\\
      0 &\quad\text{otherwise}\\
    \end{cases}
  \end{align}
\end{subequations}
%
\Cref{fig:tft-symbols} shows \ac{TFT}-specific symbols used in this work.
To illustrate \acp{TFT}, for the formula $\parsin{A \pand C} \lor \parsin{A \land B}$, we show:
\begin{alineasinline}
  \item the \ac{TFT} in \cref{fig:tft-small-example}, and
  \item its corresponding \ac{TTT} in \cref{tbl:ttt-small-example} (the column `\#' indicates the \ac{MCSeq} number).
\end{alineasinline}

\begin{table}
% table caption is above the table
\caption{\acs{TTT} of \acsg*{TFT} operators and sequence value numbers}
\label{tbl:tft-operators}
% For LaTeX tables use
\centering
\begin{tabular}{ccccccc}
\hline\noalign{\smallskip}
A & B & \ac{AND} & \ac{OR} & \ac{PAND} & \ac{POR} & \ac{SAND}  \\
\noalign{\smallskip}\hline\noalign{\smallskip}
0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 1 & 0 & 0 & 0\\
1 & 0 & 0 & 1 & 0 & 1 & 0\\
1 & 1 & 1 & 1 & 0 & 0 & 1\\
1 & 2 & 2 & 1 & 2 & 1 & 0\\
2 & 1 & 2 & 1 & 0 & 0 & 0\\
\noalign{\smallskip}\hline
\end{tabular}
\end{table}

\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{0.20\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-pand-gate}
    \caption{\acs*{PAND} gate}\label{fig:tft-pand-gate}
  \end{subfigure}
  \begin{subfigure}[b]{0.20\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-por-gate}
    \caption{\acs*{POR} gate}\label{fig:tft-por-gate}
  \end{subfigure}
  \begin{subfigure}[b]{0.20\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-sand-gate}
    \caption{\acs*{SAND} gate}\label{fig:tft-sand-gate}
  \end{subfigure}
  \caption{\acs*{TFT}-specific gates}
  \label{fig:tft-symbols}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.55]{tft-small-example}
  \caption{\acs*{TFT} small example}
  \label{fig:tft-small-example}
\end{figure}

\begin{table}
  \caption{\acs*{TTT} of a simple example}
  \label{tbl:ttt-small-example}
  \centering
  {\scriptsize
  \begin{tabular}{ccccccc}
  \hline\noalign{\smallskip}
  \# & A & B & C & $A \pand C$ & $A \land B$ & $\parsin{A \pand C} \lor \parsin{A \land B}$ \\
  \noalign{\smallskip}\hline\noalign{\smallskip}
  01 & 0 & 0 & 0 & 0 & 0 & \textbf{0}\\
  02 & 0 & 0 & 1 & 0 & 0 & \textbf{0}\\
  03 & 0 & 1 & 0 & 0 & 0 & \textbf{0}\\
  04 & 0 & 1 & 1 & 0 & 0 & \textbf{0}\\
  05 & 0 & 1 & 2 & 0 & 0 & \textbf{0}\\
  06 & 0 & 2 & 1 & 0 & 0 & \textbf{0}\\
  07 & 1 & 0 & 0 & 0 & 0 & \textbf{0}\\
  08 & 1 & 0 & 1 & 0 & 0 & \textbf{0}\\
  09 & 1 & 0 & 2 & 2 & 0 & \textbf{2}\\
  10 & 1 & 1 & 0 & 0 & 1 & \textbf{1}\\
  11 & 1 & 1 & 1 & 0 & 1 & \textbf{1}\\
  12 & 1 & 1 & 2 & 2 & 1 & \textbf{1}\\
  13 & 1 & 2 & 1 & 0 & 2 & \textbf{2}\\
  14 & 1 & 2 & 2 & 2 & 2 & \textbf{2}\\
  15 & 1 & 2 & 3 & 3 & 2 & \textbf{2}\\
  16 & 1 & 3 & 2 & 2 & 3 & \textbf{2}\\
  17 & 2 & 0 & 1 & 0 & 0 & \textbf{0}\\
  18 & 2 & 1 & 0 & 0 & 2 & \textbf{2}\\
  19 & 2 & 1 & 1 & 0 & 2 & \textbf{2}\\
  20 & 2 & 1 & 2 & 0 & 2 & \textbf{2}\\
  21 & 2 & 1 & 3 & 3 & 2 & \textbf{2}\\
  22 & 2 & 2 & 1 & 0 & 2 & \textbf{2}\\
  23 & 2 & 3 & 1 & 0 & 3 & \textbf{3}\\
  24 & 3 & 1 & 2 & 0 & 3 & \textbf{3}\\
  25 & 3 & 2 & 1 & 0 & 3 & \textbf{3}\\
  \noalign{\smallskip}\hline
  \end{tabular}
  }
\end{table}

From structure expressions in order-sensitive \acp{FT} (\ac{TFT} and \ac{DFT}), \acp{MCSeq} are obtained.
Several approaches represent \acg{MCSeq} ordering differently.
For the best of our knowledge they are introduced in the work~\cite{TD2004} similarly as \ac{MCS}, allowing set elements with arrows (``$\rightarrow$'') to represent order.

For \acp{TFT}, in the work~\cite{Walker2009} \acp{MCSeq} are represented as \iac{DNF} using \ac{AND} and the temporal operators (\ac{PAND}, \ac{POR}, and \ac{SAND}) as doublets (a single temporal relation)---which are the minimal terms---or prime implicants---in the \ac{DNF}.
In a doublet, the expression is a product (of \ac{AND}) of temporal operators, and each temporal operator contains \emph{exactly} two events.
The conversion to doublets uses the temporal laws as shown in~\cite{Walker2009}.
For example, the expression $\parsin{X \sand Y} \por Z$ is a temporal relation (\ac{POR}) of a temporal relation (\ac{SAND}).
To extract \acp{MCSeq} it needs to be converted to $\squaresin{X \sand Y} \land \squaresin{X \por Z} \land \squaresin{Y \por Z} $ (the square brackets is the doublets notation and it is the direct application of the \emph{Temporal Distributive Law}~\cite[p. 120]{Walker2009}).

The normal form for \ac{TFT} is similar to \ac{SFT}: it is \iac{DNF} with temporal operators (\ac{PAND}, \ac{POR}, \ac{SAND}) in the minimal terms.
The reduction of \ac{TFT} structure expressions is achieved using \ac{DT}\adnote{Cite dependency tree}.
In \iac{DT}, if all children of a tree node are true, then the node is also true.
Conversely, if a node is true, then all its children are also true.
An issue with \acp{DT} is that they grow exponentially.
Accordingly to the work~\cite{WP2010}, it is already infeasible to deal with seven fault events in TFTs.
Although there is a solution, it is based on a mixed application of \acp{DT}, modularisation of independent subtrees, and algebraic laws~\cite{WP2009}.
We show \acp{DT} in~\cref{sec:dependency-trees}.
Some of these algebraic laws are:
%
\begin{subequations}
\begin{align}
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} &= X \land Y & \text{Conjunctive Completion Law}\label{law:tft-conjunctive-completion-law}\\
  \parsin{X \por Y} \lor \parsin{X \sand Y} \lor \parsin{Y \por X} &= X \lor Y & \text{Disjunctive Completion Law}\\
  \parsin{X \por Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} &= X & \text{Reductive Completion Law 1st}\\
  \parsin{X \land Y} \lor \parsin{X \por Y}  &= X & \text{Reductive Completion Law 2nd}
\end{align}
\end{subequations}

\subsection{\Aclp*{DFT}}
\label{sec:dynamic-fault-trees}

\begin{sloppypar}
\Aclp{DFT} were designed with the goal of analysing complex systems with dynamic redundancy management and complex fault and recovery mechanisms~\cite{DBB1992}.
The idea was to create easy-to-use and less error-prone modelling tools than using \acp{DTMC}---or simply \emph{\acap{DTMC}}---directly.
So, since the very beginning, \acp{DFT} were intended to be evaluated using \acap{DTMC}.
\Cref{fig:dft-original-symbols} depicts the original gate symbols as shown in~\cite{DBB1992,Boyd1992}.
In this work, we use gates symbols as depicted in \cref{fig:dft-symbols}.
The informal semantics of them are:
%
\begin{description}
  \item[\Ac{FDEP}:]
  When the trigger event occurs, the dependent events are forced to occur.
  Timing in this gate between trigger event and dependent events occurrences can be at the same time (like in \acg{TFT} \ac{SAND} gate), or in a small amount of time, thus implying an order of occurrence, depending on the kind of dependency.
  \item[\Ac{CSp}:]
  It is a specific gate to handle spare components.
  It is important to note that connected inputs are not components---they are fault events of connected components.
  If the i\emph{th} input is already active (fault has occurred), then it is expected that the input $\parsin{i+1}$\emph{th} is not, following the specified order.
  The output becomes true after all connected inputs become true.
  A spare event can be connected to more than one \ac{CSp} gate, representing the spare unit connection to one or more components.
  \item[\ac{PAND}:]
  The same as in \ac{TFT}: when the connected input events occur in the specified order, it outputs true.
  \item[\Ac{SEQ}:]
  The connected events \emph{shall} occur in the specified order.
  It is different from the \ac{PAND} gate, because the latter \emph{detects} the specified order.
  The usage of this gate is usually associated with \ac{FDEP}.
\end{description}
\end{sloppypar}

\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{.32\linewidth}
    \centering
      \includegraphicsaspectratio[1]{dft-original-fdep-symbol}
    \caption{\acs*{FDEP} gate}\label{fig:dft-original-fdep-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.45\linewidth}
    \centering
      \includegraphicsaspectratio[1]{dft-original-csp-symbol}
    \caption{\acs*{CSp} gate}\label{fig:dft-original-csp-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.20\linewidth}
    \centering
      \includegraphicsaspectratio[1]{dft-original-seq-symbol}
    \caption{\acs*{SEQ} gate}\label{fig:dft-original-seq-symbol}
  \end{subfigure}%
  \caption{\acspg*{DFT} original gates symbols}
  \label{fig:dft-original-symbols}
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{.3\linewidth}
    \centering
      \includegraphicsaspectratio[0.7]{ft-symbol-fdep-gate}
    \caption{\acs*{FDEP} gate}\label{fig:dft-fdep-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphicsaspectratio[1]{ft-symbol-csp-gate}
    \caption{\acs*{CSp} gate}\label{fig:dft-csp-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.3\linewidth}
    \centering
      \includegraphicsaspectratio[0.8]{ft-symbol-seq-gate}
    \caption{\acs*{SEQ} gate}\label{fig:dft-seq-symbol}
  \end{subfigure}%
  \caption{\acpg*{DFT} gates symbols}
  \label{fig:dft-symbols}
  %
  %\legend{Source: \cite{DBB1992,Boyd1992}}
\end{figure}


There are several means to analyse \acp{DFT} qualitative and quantitatively.
The works reported in~\cite{Merle2010,MRL+2010,MRL2011,MRL2014} use structure expressions to perform both qualitative and quantitative analysis, and the work reported in~\cite{MRL2014} summarizes other approaches.
We increment their summary (\cref{tbl:dft-conversion-te-probability}) and categorize them as:
%
\begin{alineas}
  \item
  Finding \acp{MCSeq} (qualitative analysis) is obtained by replacing \ac{DFT} gates with \ac{SFT} gates, using the text as its logical constraints.
  \Acp{MCS} in the \ac{SFT} are expanded using timing constraints from the texts into \ac{MCSeq}.
  In this case, the behaviour of spare events cannot be correctly taken into account;
  \item
  Quantitative analysis consists in converting \iac{DFT} to a well-defined formalism to calculate the probability of its top-level event.
  \Cref{tbl:dft-conversion-te-probability} shows the conversion, the calculation, and where the method is explained.
\end{alineas}

\begin{table}[t]
  \caption{\Ac{DFT} conversion to calculate probability of top-level event}
  \label{tbl:dft-conversion-te-probability}
  \centering
  \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } p{6cm} p{3.5cm} p{5.5cm} }
  %\begin{tabularx}{\linewidth}{XXX}
  \hline\noalign{\smallskip}
  \textbf{Conversion} & \textbf{Calculation} & \textbf{Explained in}\\
  \hline\noalign{\smallskip}\hline\noalign{\smallskip}
  Automaton-like structure & \ac{CTMC} & \cite{CSD2000}\\
  %
  \hline\noalign{\smallskip}
  \Ac{BN} & Inference algorithm (model-specific) & \cite{BRM+2005}\\
  %
  \hline\noalign{\smallskip}
  \Ac{SWN} (a kind of \ac{CPN}) & \ac{CTMC} & \cite{BR2004} \\
  %
  \hline\noalign{\smallskip}
  \Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} (a modified version of \ac{BDD}\index{Binary Decision Diagrams}) & model-specific & \cite{TXD2011,XTD2012} \\
  \hline\noalign{\smallskip}
  \end{tabular*}
  %\end{tabularx}
\end{table}

%Structure expressions\index{structure expression} are also used in \acp{DFT}.
In~\cite{Merle2010,MRL+2010,MRL2011} fault events occur in a specific time and are instantaneous (similar to detected faults), stated through a ``date-of-occurrence'' function.
As the ``date-of-occurrence'' function is stated in continuous time, the probability of two events occurring at the same time is negligible.
In fact, useful information is obtained from the possibilities of relation in time of the occurrence of the events.
\Ac{DFT} gates' algebraic model is summarized in \cref{tbl:merle-dft-algebraic-model}.
Structure expressions\index{structure expression} are written with an algebra that has operators \ac{OR} and \ac{AND}, and three new operators to express events ordering:
\begin{alineasinline}
  \item \ac{NIBefore},
  \item \ac{SIMLT}, and
  \item \ac{IBefore}.
\end{alineasinline}
The \ac{NIBefore} and the \ac{SIMLT} operators are similar to \ac{TFT}'s \ac{POR} and \ac{SAND} operators, respectively.
The \ac{IBefore} is a composition of \ac{NIBefore} and \ac{SIMLT} operators.
\Cref{tbl:date-of-occurrence-for-operators} summarizes the date-of-occurrence function for all operators.
An infinite value means the event never occurs.

\Acp{MCSeq} are extracted from canonical form of structure expressions written in \iac{DNF}.
Minimal terms are products of variables and \ac{NIBefore} operators (the other operators can be written as combinations of \ac{NIBefore}).
The reduction of \ac{DFT} structure expressions\index{structure expression} uses algebraic laws as, for example:
\begin{subequations}
\begin{align}
%a \lor \parsin{a \nibefore b} &= a\\
%\parsin{a \nibefore b} \lor b &= a \lor b\\
%a \land \parsin{a \nibefore b} &= a \nibefore b\\
%a \lor \parsin{a \simultaneous b} &= a\\
%a \land \parsin{a \simultaneous b} &= a \simultaneous b\\
\parsin{a \nibefore b} \lor
  \parsin{a \simultaneous b} \lor
  \parsin{b \nibefore a} &= a \lor b\\
%
\parsin{a \land \parsin{b \nibefore a}} \lor
  \parsin{a \simultaneous b} \lor
  \parsin{b \land \parsin{a \nibefore b}} &= a \land b\\
%
\parsin{a \ibefore b} \land \parsin{b \ibefore a} &= a \simultaneous b
\end{align}
\end{subequations}

\begin{table}
  \caption{Algebraic model of \ac{DFT} gates with inputs $A$ and $B$}
  \label{tbl:merle-dft-algebraic-model}
  \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c p{5.9cm} p{7.8cm} }
  \hline\noalign{\smallskip}
  \textbf{Gate} & \textbf{Algebraic model of gate's output} & \textbf{Note}\\
  \hline\noalign{\smallskip}\hline\noalign{\smallskip}
  %
  \ac{FDEP} & $A_T = T \lor A$ and $B_T = T \lor B$ & $A_T$ and $B_T$ replace $A$ and $B$ on the resulting expression\\
  %
  \hline\noalign{\smallskip}
  \ac{CSp} &
    $\parsin{B_a \land \parsin{A \nibefore B_a}} \lor
    \parsin{A \land \parsin{B_d \nibefore A}}$ & $A$ is the active input, and $B$ is the spare. Subscripts $a$ and $d$ represent component's state---\emph{active} and \emph{dormant}, respectively, which are used on the failure distribution formulas\\
  %
  \hline\noalign{\smallskip}
  \ac{PAND} & $B \land \parsin{A \ibefore B}$ & No distinction of active or dormant states.\\
  %
  \hline\noalign{\smallskip}
  \end{tabular*}
\end{table}

\begin{table}
  \caption{Date-of-occurrence\index{Dynamic Fault Tree!Date-of-occurrence function} function for operators defined in \cite{Merle2010}}
  \label{tbl:date-of-occurrence-for-operators}
  \centering
  \begin{tabularx}{\textwidth}{ccXXX}
    \hline\noalign{\smallskip}
    \textbf{Operator} &
      \textbf{Expression} &
      \textbf{Value if \smallskip\smallskip} $\mathbf{\func{d}{a} < \func{d}{b}}$ &
      \textbf{Value if \smallskip\smallskip} $\mathbf{\func{d}{a} = \func{d}{b}}$ &
      \textbf{Value if \smallskip\smallskip} $\mathbf{\func{d}{a} > \func{d}{b}}$\\
    \hline\noalign{\smallskip}\hline\noalign{\smallskip}
    \ac{OR} &
      $\func{d}{a \lor b}$ & $\func{d}{a}$ & $\func{d}{a}$ & $\func{d}{b}$\\
    \ac{AND} &
      $\func{d}{a \land b}$ & $\func{d}{b}$ & $\func{d}{a}$ & $\func{d}{a}$\\
    \ac{NIBefore} &
      $\func{d}{a \nibefore b}$ & $\func{d}{a}$ & $+\infty$ & $+\infty$\\
    \ac{SIMLT} &
      $\func{d}{a \simultaneous b}$ & $+\infty$ & $\func{d}{a}$ & $+\infty$\\
    \ac{IBefore} &
      $\func{d}{a \ibefore b}$ & $\func{d}{a}$ & $\func{d}{a}$ & $+\infty$\\
    \hline\noalign{\smallskip}
  \end{tabularx}

\end{table}

%The work reported in~\cite{TXD2011,XTD2012} shows the top-level events probability calculation for \acp{DFT} by converting them to a simplified version, using only order-based operators.
%Such a simplified version, which is based on a modified \ac{BDD}\index{Binary Decision Diagrams} that includes an order-based operator, creates Sequential BDDs\index{Binary Decision Diagrams!Sequential} that are used to perform the probabilistic analysis.

\begin{sloppypar}
\Cref{fig:dft-example} shows an example of \ac{DFT} extracted from~\cite{MRL2014}.
It is \iac{HCAS}, which is divided in four modules: trigger, CPU unit, motor section, and pumps.
The trigger is divided in two components, CS and SS.
The failure of any CS or SS, triggers a CPU unit failure.
The primary CPU (P) has a warm\footnote{Warm spare gates only differ from \ac{CSp} on the activation time.} spare (B).
The motor module fails if both M and MC fail.
In order for the pumps unit to fail, all three pumps need to fail, and the left-hand side spare gate needs to fail before (or at the same time as) the right-hand side spare gate (\ac{PAND} gate\footnote{Although the original example uses a \ac{PAND} gate, accordingly to the informal description, \iac{SEQ} gate would fit better.}).
The top-level event structure expression is:
\begin{align}
SYSTEM =& CS \lor SS \lor \parsin{M \land MC} \lor \\
  &\parsin{P \land \parsin{B_d \nibefore P}} \lor \parsin{B_a \land \parsin{P \nibefore B_a}} \lor \nonumber\\
  &\parsin{BP_a \land \parsin{P2 \nibefore P1} \land \parsin{P1 \nibefore BP_a}} \lor
  \parsin{P2 \land \parsin{P1 \nibefore BP_a} \land \parsin{BP_a \nibefore P2}}\nonumber
\end{align}
\end{sloppypar}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.65]{dft-example-mrl2014}
  \caption{\acs*{DFT} example}
  \label{fig:dft-example}
\end{figure}

\section{Structure expressions analysis}
\label{sec:structure-expressions-analysis}

In this section we detail the non-state-based methods to analyse structure expressions.
%As \acp{DFT} originally employs \ac{DTMC} analysis, the methods to analyse are generally state-based
%\todo{cite all dft works that are state-based}.
Another common approach to analyse \iac{FT} is to perform structure expression analysis based on algebraic laws.
Boolean\index{Boolean Algebra} laws are well-known and are used for \acp{SFT}, temporal laws~\cite{Walker2009,WP2010} for \acp{TFT}, and the works reported in~\cite{Merle2010,MRL2011} show laws for \acp{DFT}.
An issue with algebraic laws is that, in some cases, the expression needs to be expanded before it gets reduced, so reduction automation is not trivial without a theorem prover.
For example, the following \acg{TFT} structure expression needs to be expanded \cite{WP2010} before it gets reduced:
\begin{align*}
  \parsin{X \land Y} & \lor \parsin{\parsin{X \pand Y} \land Z} &\\
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} & \lor \parsin{\parsin{X \pand Y} \land Z} & \text{by \cref{law:tft-conjunctive-completion-law}}\\
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} & &\\
  X \land Y & & \text{by \cref{law:tft-conjunctive-completion-law}}
\end{align*}
%
A denotational semantics to Boolean\index{Boolean Algebra} expressions---and consequently to \ac{SFT}---is given by \acp{FBA} (\cref{sec:fba}).

There are several works with state-based analysis for \acp{FT} (\ac{SFT}, \ac{TFT}, and \ac{DFT}).
We show some of them in \cref{sec:ft-state-based-analysis}.

\subsection{State-based and temporal logic analysis}
\label{sec:ft-state-based-analysis}

The work reported in~\cite{STR2002} shows a formal approach to analyse \ac{SFT} using \ac{ITL}.
Instead of tackling basic events ordering (as in \ac{PAND}), it considers a causal relation over a gate, as for example, a relation of a basic event and a higher-level intermediary event.

For \acp{TFT}, the works reported in~\cite{MPW2010,MWP2012} show an inverse solution.
They map \acp{FSM}\adnote{Cite FSM} to \pandora logic, then verify system properties.
They show that such a mapping simplifies expressions reduction, thus improving performance on the analysis.

Although there is formal modelling for \acp{DFT}, they do not implement a direct modelling of the \ac{DFT} itself.
Instead, most of the works propose a formal modelling of a state-based approach.
The work reported in~\cite{CSD2000} shows a formal model of \acap{DTMC} in \theac{Z} and each \ac{DFT} element (basic events and gates).
The analysis uses a quantifier on states of the resulting \aca{DTMC} automaton.
The work reported in~\cite{GD1997} shows a methodology to perform a modular analysis of \acp{DFT} based on \ac{BDD}\index{Binary Decision Diagrams} and \aca{DTMC}.
As \ac{DFT} extends \ac{SFT}, it identifies subtrees that are purely \ac{SFT} and uses \ac{BDD}\index{Binary Decision Diagrams}, otherwise.
It performs \aca{DTMC} analysis.
Still on the state-based approaches, the work reported in~\cite{SLD2011} maps \acp{DFT} to \ac{HLPN} to analyse false alarms.

%The work reported in~\cite{LR1998} uses a formal approach using \ac{FSM} to generate fault trees automatically from system models.

In the following we show specific methods that are designed to reduce structure expressions.
In essence, the methods are very similar.
Structure expressions for \acp{SFT} can be reduced using \acp{BDD} (\cref{sec:bdd}), \acp{TFT} can be reduced using \acp{DT} (\cref{sec:dependency-trees}), \acp{MCSeq} of \acp{DFT} can be obtained using \ac{ZBDD} (\cref{sec:zbdd}), and the works reported in~\cite{TXD2011,XTD2012} show the analysis of standby systems (\ac{CSp} gates) using \acp{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} (\cref{sec:sbdd}).

\subsection{\Aclp*{BDD}\index{Binary Decision Diagrams}}
\label{sec:bdd}

\Acp{BDD}\index{Binary Decision Diagrams} are directed acyclic graphs that represent a Boolean\index{Boolean Algebra} expression.
They are still referred to as \ac{BDD}\index{Binary Decision Diagrams}, but the more spread version is the \ac{ROBDD}, which is an optimisation.
There are two ways to generate \iac{BDD}\index{Binary Decision Diagrams} for an expression:
\begin{alineasinline}
  \item derive a diagram from the truth-table, or
  \item expand the paths based on Shannon's method\index{Binary Decision Diagrams!Shannon's method} (described in the \FThandbook).
\end{alineasinline}

To demonstrate the expressiveness of \iac{BDD}, \cref{fig:bdd-diagram-for-a-truth-table} shows a diagram for a truth table with three variables (\cref{tbl:bdd-truth-table-with-three-variable}).
In a node, when a path is chosen, the variable of the node assumes the edge value.
For example, the top-level node variable of \cref{fig:bdd-diagram-for-a-truth-table} is $A$.
Following the right-hand side of the node, all leaf nodes correspond to the lines of the truth table that $A$ has ``0'' values (the first four lines).
The symbol nodes are replaced by the values assumed by a specific formula.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{bdd-diagram-for-a-truth-table}
  \caption{A diagram for a truth table}
  \label{fig:bdd-diagram-for-a-truth-table}
\end{figure}

\begin{table}[t]
  \caption{Truth table for a formula outputs with three variables (A, B, and C)}
  \label{tbl:bdd-truth-table-with-three-variable}
  \centering
  {\footnotesize
  \begin{tabular}{cccc}
    \hline\noalign{\smallskip}
    \textbf{A} & \textbf{B} & \textbf{C} & \textbf{Formula}\\
    \hline\noalign{\smallskip}\hline\noalign{\smallskip}
    0 & 0 & 0 & a \\
    0 & 0 & 1 & b \\
    0 & 1 & 0 & c \\
    0 & 1 & 1 & d \\
    1 & 0 & 0 & e \\
    1 & 0 & 1 & f \\
    1 & 1 & 0 & g \\
    1 & 1 & 1 & h \\
    \hline\noalign{\smallskip}
  \end{tabular}
  }
\end{table}

Following Shannon's method\index{Binary Decision Diagrams!Shannon's method}, we choose a variable and build the lower level \ac{BDD}\index{Binary Decision Diagrams} assuming the edge value for the chosen variable.
In the remainder of the path, the variable's value is unchanged.
For example, the expression $A \lor \parsin{\lnot B \land C}$ has value ``0'' in the lines $a$ and $c$, and value ``1'' in the other lines.
By choosing the variable $A$ first, then $B$ and $C$, the resulting \ac{BDD}\index{Binary Decision Diagrams} with the binary values nodes (called sink nodes ``false'' and ``true'') for this formula is depicted in \cref{fig:bdd-diagram-for-example-expression}.
Starting from the top-level node $A$, the formula expressed by the \ac{BDD}\index{Binary Decision Diagrams} is true if $A$ assumes value true.
If $A$ is false, and $B$ is false, the expression is only true if $C$ is true.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.25]{bdd-diagram-for-example-expression}
  \caption{\Iacs{BDD} for the expression $A \lor \parsin{\lnot B \land C}$}
  \label{fig:bdd-diagram-for-example-expression}
\end{figure}

\Cref{fig:bdd-diagram-for-example-expression} is \iac{ROBDD}.
To be considered \iac{ROBDD}, the \ac{BDD}\index{Binary Decision Diagrams} must meet the following constraints~\cite{BRB1990}:
%
\begin{alineas}
  \item the variables are assigned a constant ordering;
  \item every path to sink nodes visit the input variables in ascending order;
  \item each node represents a distinct logic function.
\end{alineas}
%
The size of \iac{ROBDD}, for a given expression, depends on the chosen variables ordering.
The work reported in~\cite{Rudell1993} shows initial findings on variable ordering, and the work reported in~\cite{KH2014} shows heuristics to improve the performance for optimal order search.

For \acp{SFT} the evaluation of \iac{BDD} is the calculation of the probability of the paths ending in \emph{true}.
For example, the probability of the expression in \cref{fig:bdd-diagram-for-example-expression} is obtained from the formula: $\probability{A \lor \parsin{\lnot A \land \lnot B \land C}}$. Note that the formula in the probability calculation is different from the formula that originated the diagram.

\subsection{\Acl*{DT}}
\label{sec:dependency-trees}

\Acf{DT} is a hierarchical acyclic graph of expressions that shows all possible cut sequences for any given set of events.
It is a graphical view of a \ac{TTT}.
At the top of \iac{DT} are the variables, that is, the single events that occur in an expression.
On the lower levels are the increasingly complex expressions.
Each node represents \iac{MCSeq}.
\Cref{fig:simple-dependency-tree} shows \iac{DT} with all nodes for variables $X$ and $Y$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{simple-dependency-tree}
  \caption{\acs*{DT} for variables $X$ and $Y$}
  \label{fig:simple-dependency-tree}
\end{figure}

The reduction of a structure expression is given by the activation (true values) of nodes.
If a node is active (true), then all child nodes are also active; the converse is also true: if all node's children are active, then it is also active.
The reduced expression is given by the \ac{DNF} created with the expressions of higher active level nodes.
To reduce the formula $\parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z}$, given on the beginning of this section, we create the \ac{DT} depicted in \cref{fig:dependency-tree-reduction}.
Nodes marked as ``1'' are those \acp{MCSeq} given directly by the formula.
Nodes marked as ``2'' are child nodes of the ``1'''s nodes, and so forth.
The node of the expression $\parsin{\parsin{X \pand Y} \land Z}$ is a grandchild of $X \land Y$ and thus it is not necessary.
The final expression is obtained by the active higher level node, which is $X \land Y$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.7]{dependency-tree-reduction}
  \caption{\acs*{DT} for the formula $\parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z}$}
  \label{fig:dependency-tree-reduction}
\end{figure}

\subsection{\Aclp*{ZBDD}\index{Zero-suppressed Binary Decision Diagrams}}
\label{sec:zbdd}

The work reported in~\cite{TD2004} proposes \acl{ZBDD}, which is a variant of \ac{BDD}\index{Binary Decision Diagrams}, and uses set manipulations (union, intersection, difference, and product) to obtain \acp{MCSeq} of \acp{DFT}.

To reduce \iac{BDD} to \iac{ZBDD}, the nodes that have the ``true'' (`1') path pointing to the ``false'' (`0') sink node are removed, and the parent node is connected directly to the ``false'' subgraph of the removed node.
\Cref{fig:zbdd-example} shows an example of \ac{ZBDD} for the combination set $\setsin{a,b}$, as shown in~\cite{TD2004}.
The idea of the reduction is to remove irrelevant variables and nodes.
The irrelevant variables are set to ``false''.
The method obtains the \acp{MCSeq} by navigating the paths to sink node ``true''.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.7]{bdd-zbdd-example}
  \caption{\acs*{ZBDD} example of combination set $\setsin{a,b}$}
  \label{fig:zbdd-example}
\end{figure}

Although the work reported in~\cite{TD2004} shows \theac{ZBDD}, the final solution does not use them directly. Instead, it defines a hierarchical manipulation of \ac{DFT} to obtain the \acp{MCSeq} when traversing the \iac{DFT}.
The order-related operators in \iac{DFT} are replaced by a new event, which takes ordering into account.
The idea is to transform the \ac{DFT} into \iac{SFT}, in a very similar way as the one shown in~\cite{TXD2011}.
Finally, the \acp{MCSeq} are obtained using set manipulation with elements that are basic events alone or order-related operators.
These order-related operators are event-to-event only, so they cannot be combined with other sets.

The use of sets in~\cite{TD2004} is very related to our \ac{algebra}.
We use sets of sequences to define the \ac{algebra}, but keep the analysis with set operators.
In \ac{algebra} we do not create new events that represent an order-related operator.
Our order-related operator has a set-based semantics that can be combined with other non-order-related (Boolean\index{Boolean Algebra}) operators.

\subsection{\Aclp*{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential}}
\label{sec:sbdd}

\Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} is an extension of \ac{BDD}\index{Binary Decision Diagrams} to tackle ordering of events in \acp{DFT} for \ac{CSp} and \ac{WSp} gates.
Ordering of events in \ac{CSp} gates~\cite{XTD2012} is slightly different compared to \ac{WSp}~\cite{TXD2011}.
A backup system in \ac{CSp} gets activated slower than in \ac{WSp}, which implies that there are less failure possibilities in \ac{CSp}, but its the readiness is lower than in \ac{WSp}.
\Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} adds a new node kind that contains a binary operation of fault events, which allows to express the ordering of events.
One kind of operation expresses the slowness of the relation of the fault events of \ac{CSp}, and another one expresses the readiness of the \ac{WSp}.
The latter semantics is similar to the semantics of \ac{PAND} and \ac{IBefore} (combined with \ac{AND}) gates.

\Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} creation has two steps:
\begin{alineasinline}
  \item \ac{CSp} or \ac{WSp} \ac{DFT} conversion, and \label{item:sbdd-creation-spare}
  \item \ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} model generation.\label{item:sbdd-model-generation}
\end{alineasinline}
In \ref{item:sbdd-creation-spare}, it is a \ac{DFT}-to-\ac{DFT} conversion.
\Ac{CSp} and \ac{WSp} gates are converted to a new, but equivalent \ac{DFT} without \ac{CSp} and \ac{WSp} gates, where the operations appear as basic events and are combined using other gates.
In \ref{item:sbdd-model-generation}, the \ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} model is created.
The model may contain nodes that are contradictory as, for example, nodes that assumes that an event $A$ is false and a binary operation that contains $A$ is true.
This step ends when all contradictions are removed.
The evaluation is similar to \acg{BDD}: each path ending in true is a minimal term in the \ac{DNF} that may contain one of the binary operations and individual events.


\section[Free Boolean Algebras]{\Aclp*{FBA}}
\label{sec:fba}
\index{Boolean Algebra!Free}

Another means to analyse \acp{SFT} is to use \iac{FBA} to perform set-theoretical operations (intersection, difference, etc.) to reduce expressions.
In this section we briefly present the \ac{FBA} theory and its elements.

Instead of using an axiomatic definition of a Boolean\index{Boolean Algebra} algebra, we follow its set-theoretical definition, as shown in~\cite[pp. 254--258]{Stoll1979} and~\cite[pp. 8--11]{GH2009}.
This definition represents a Boolean\index{Boolean Algebra} algebra as an algebra of sets and does not rely on axioms (which can be misleading, case there is an unfounded axiom).

\begin{definition}[Boolean Algebra]
\label{def:boolean-algebra}
A Boolean algebra is defined as a triple $\anglesin{B, \inter, -}$, where $B$ is a set with at least two elements, $\inter$ is the intersection (also called meet or \emph{infimum}) and $-$ is the complement (also called negation).
\end{definition}
%
\noindent The other Boolean elements (union, $\bot$, and $\top$) are derived from the previous two operators:
\begin{description}
  \item[$\union$] is the union (also called join or \emph{supremum}): $A \union B = -(-A \inter -B)$
  \item [$\bot$] is the bottom (also called zero): $\bot = A \inter -A$
  \item [$\top$] is the top (also called unit): $\top = -\bot$
\end{description}

\begin{sloppypar}
\Iacl{FBA} is defined from a set $E$ of generators.
A generator can be represented as a proposition in statement calculus~\cite[p. 274]{Stoll1979}.
For example, ``valve A is stuck closed'' and ``motor M is malfunctioning'' are valid statements.
A \acl{FBA} is constructed from $\powerset{E}$, where $\powersetop$ is the power set\index{Power Set}.
Note that if $E$ has $n$ symbols, $\powerset{E}$ has $2^{n}$ elements, called \emph{atoms}\index{Boolean Algebra!atoms} of a finite Boolean algebra.
For the two statements above, the atoms\index{Boolean Algebra!atoms} are:
\begin{alineas}
  \item ``Valve A is stuck closed'' and ``motor X is malfunctioning''
  \item ``Valve A is stuck closed'' and ``motor X is \emph{not} malfunctioning''
  \item ``Valve A is \emph{not} stuck closed'' and ``motor X is malfunctioning''
  \item ``Valve A is \emph{not} stuck closed'' and ``motor X is \emph{not} malfunctioning''
\end{alineas}
Such a Boolean\index{Boolean Algebra} algebra has $2^{2^{n}}$ formulas~\cite[p. 261]{GH2009}.
For example, if $E = \setsin{a,b}$, then $\powerset{E} = \setsin{ \setsin{}, \setsin{a}, \setsin{b}, \setsin{a,b} }$, hence the Boolean\index{Boolean Algebra} algebra generated by $E$ contains sixteen ($2^{2^{2}}$) formulas:
$\setsin{}$,
$\setsin{\setsin{}}$,
$\setsin{\setsin{}, \setsin{a}}$,
$\setsin{\setsin{}, \setsin{b}}, \ldots$,
$\setsin{\setsin{a}, \setsin{a,b}}, \ldots$,
$\setsin{\setsin{b}, \setsin{a,b}}, \ldots$,
$\setsin{\setsin{}, \setsin{a}, \setsin{b}, \setsin{a,b}}$.
\end{sloppypar}

The Boolean\index{Boolean Algebra} algebra $B$ can be inductively defined using some constructs.
%
\begin{definition}[Inductive \acl*{FBA}]
\label{def:inductive-fba}
Let $s$ be a statement, then:
%
\begin{subequations}
\begin{align}
\var s = \setsin{X | s \in X} & \implies \var s \in B & \text{(variable)}\\
X \in B & \implies -X \in B                           & \text{(complement)}\\
X \in B \land Y \in B & \implies X \inter Y \in B     & \text{(intersection)}
\end{align}
\end{subequations}
%
\end{definition}

The characterisation of a ``free'' Boolean\index{Boolean Algebra} algebra comes from that, for some valuation function $a$, some of the formulas evaluates to ``1''.
Given a function $p:B \cartesian \setsin{0,1} \rightarrow B$, such that:
%
\begin{equation}
p\parsin{i,j} =
\begin{cases}
  i & \quad j = 1\\
  -i & \quad j = 0
\end{cases}
\end{equation}

\begin{lemma}[Free generators (valuation)]
\label{lem:boolean-algebra-free-generators-valuation}
Let $F$ be a finite set, such that $F \subseteq E$, and $a: F \rightarrow \setsin{0,1}$, a necessary and sufficient condition for a set $E$ of generators of a Boolean\index{Boolean Algebra} algebra B to be free is then:
%
\begin{equation}
\bigwedge_{i \in F} p\parsin{i, a \parsin{i}} \neq 0
\end{equation}
\end{lemma}
%\begin{proof}
%See~\cite[p. 258]{GH2009}.
%\end{proof}


Essentially, \cref{lem:boolean-algebra-free-generators-valuation} states that there is no relation between generators, such as $a = -b$.

\begin{lemma}[Free generators (algebraic)]
Let $i$ and $j$ be statements, such that $i,j \in E$, hence from \cref{def:inductive-fba,lem:boolean-algebra-free-generators-valuation} it is necessary and sufficient that:
%
\begin{subequations}
\begin{align}
\var i = \var j & \iff i = j\\
\var i & \neq - \var j\\
-\var i & \neq \var j
\end{align}
\end{subequations}
%
\end{lemma}
%
%\begin{proof}
%See~\cite[p. 4]{Huffm2010}
%\end{proof}

\section[Using the NOT operator in static fault trees]{Using the \ac{NOT} operator in \aclp*{SFT}}
\label{sec:not-operator}

Although the \FThandbook introduces several gates, the vast majority of \ac{SFT} analyses would fit in \acp{FT} with only \ac{AND} and \ac{OR} gates (coherent \acp{FT})\index{Fault Tree!coherent}.
Qualitative analysis requires the reduction of the structure expression of \acp{FT} and, when \ac{NOT} gates are present (non-coherent \acp{FT}\index{Fault Tree!non-coherent}), such a reduction can cause the interpretation of failure expression to be misled~\cite{Andrews2001,Oliv2006,AB2003,CCR2008,Vaurio2016}.
The work reported in~\cite{Oliv2006} shows three funny examples of this kind of problem, and the works reported in~\cite{Andrews2001,Oliv2006,CCR2008} show how to solve it using \acp{BDD}.
In the following we show:
\begin{alineasinline}
  \item the second example presented in~\cite{Oliv2006}, which highlights the problem when using \ac{NOT} gates (\cref{sec:non-coherent-misleads-example}), and
  \item the second example presented in~\cite{Andrews2001}, which defends the usefulness of \ac{NOT} gates in a multitasking system (\cref{sec:non-coherent-usefulness}).
\end{alineasinline}

Negated events in a non-coherent analysis are in fact the working state of a component.
The failure probability contribution of a negated basic event is close to $1$.
The problem with non-coherent \acp{FT} is that its analysis can cause impossible situations.
The general formula to identify coherency is given in~\cite{Andrews2001,CCR2008} in terms of a structure function\index{structure expression!function}.

\begin{definition}[\ac{FT} Coherency]
\label{def:ft-coherency}
Let $\ftcoherency{x}:B^n \rightarrow B^1$ be a binary function of a vector of binary variables, such that $x = \squaresin{x_1, x_2,\ldots,x_n}$, representing the states of $n$ system's components.

A binary structure function $\ftcoherency{x}$ is coherent if all the following hold:
\begin{alineas}
  \item $\ftcoherency{x}$ is monotonic (non-decreasing) in each variable;
  \item Each $x_i$ is relevant, which means that $\ftcoherency{x}\replace{x_i}{1} \neq \ftcoherency{x}\replace{x_i}{0}$ for some vector $x$.
\end{alineas}%
\end{definition}%
%
\noindent where $B^1 = \setsin{0,1}$, $B^n = B^{n-1} \cartesian B^1$, $x_i = 1$ implies that component $i$ failed, and $\ftcoherency{x} = 1$ implies the system failed.
For $y = \squaresin{y_1,y_2,\ldots,y_n}$, monotonicity of $\ftcoherencyop$ means that for \emph{all} $i$, $x_i \ge y_i$ ($y_i = 1 \implies x_i = 1$), and for \emph{some} $i$, $x_i > y_i$ ($x_i = 1$ and $y_i = 0$).
Variable replacement ($\replace{a}{b}$) is as usual:
$x\replace{x_i}{a} = \squaresin{x_1, \ldots, x_{i-1}, a, x_{i+1}, \ldots, x_n}$

\subsection{Non-coherent \acl*{FT} misleads}
\label{sec:non-coherent-misleads-example}

In this section we illustrate---with the second example detailed in~\cite{Oliv2006}---how non-coherent \ac{FT} misleads.

A college student who wants to visit her mother in another city has two options: wake up early ($x_3$) and take ride with a friend ($x_1$), or wake up late ($\lnot x_3$) and take the metro ($x_2$).
The top-event failure is ``visit mother'' with expression $S = \parsin{x_1 \land x_3} \lor \parsin{x_2 \land \lnot x_3}$.
Its \acl{FT} is depicted in \cref{fig:non-coherent-ft-example}.
It is clear that the structure function is non-coherent in $x_3$ accordingly to \cref{def:ft-coherency}: $\ftcoherency{1,1,x_3}\replace{x_3}{1}=\ftcoherency{1,1,x_3}\replace{x_3}{0}$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.55]{non-coherent-ft-example}
  \caption{Non-coherent \ac{FT} college student's example}
  \label{fig:non-coherent-ft-example}
\end{figure}

The problem with this tree is the interpretation of the qualitative results.
One of the possibilities in this scenario is that the college student would take a ride \ac{AND} take the metro ($x_1 \land x_2$).
Quantitatively, the analysis of the probabilities shows that this result is not negligible, but its interpretation is impossible.

\subsection[Usefulness of NOT gates in FTA]{Usefulness of \ac{NOT} gates in \ac{FTA}}
\label{sec:non-coherent-usefulness}

In this section we show the second example detailed in~\cite{Andrews2001}.

The gas detection system\index{gas detection system} depicted in \cref{fig:gas-detection-system} has two sensors $D_1$ and $D_2$ which are used to detect a leakage in a confined space.
When a leakage is detected, these sensors send a signal to the logic control unit $LU$, which performs three tasks:
%
\begin{alineas}
  \item shuts-down the main system (process isolation) by de-energizing relay $R_1$;
  \item informs the operator of the leakage by lamp and siren $L$;
  \item deactivates all possible ignition sources, which is the interruption of power supply by de-energizing relay $R_2$.
\end{alineas}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.45]{gas-detection-system}
  \caption{Gas detection system}
  \label{fig:gas-detection-system}
\end{figure}

The system\index{gas detection system} is in fail state if it does not perform one of these three tasks.
The \acl{FT} that represents this generic failure is depicted in \cref{fig:ft-generic-failure-gas-detection-system}.
$G_1$, $G_2$, and $G_3$ are subtrees that represents the three tasks ``Operator not informed'', ``Process shut-down fails'', and ``Power supply not isolated'', respectively.
All three tasks will fail if their respective main component fails ($L$, $R_1$, and $R_2$) or there is no signal from $LU$ ($LU$ fails or both $D_1$ and $D_2$ fail).
The structure expressions for the subtrees are:
%
\begin{align*}
  G_1 & = L \lor LU \lor \parsin{D_1 \land D_2}\\
  G_2 & = R_1 \lor LU \lor \parsin{D_1 \land D_2}\\
  G_3 & = R_2 \lor LU \lor \parsin{D_1 \land D_2}
\end{align*}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[1]{ft-generic-failure-gas-detection-system}
  \caption{\ac{FT} for a generic failure in the gas detection system}
  \label{fig:ft-generic-failure-gas-detection-system}
\end{figure}

Analysing in more detail, there are different degrees of system failure.
There are eight outcomes (given the three tasks) and the most critical one is when both process shut-down ($G_2$) and power supply isolation ($G_3$) fail keeping energized upon a leakage, and the operator is not informed ($G_1$), but the operator information system is working (lamp and siren are off, but they are operational).
The coherent \ac{FT} of this outcome is depicted in \cref{fig:outcome-4-coherent-ft}.
The minimal cut sets obtained from this will be: $\setsin{R_1, R_2}$, $\setsin{D_1, D_2}$, and $\setsin{LU}$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{outcome-4-coherent-ft}
  \caption{\emph{Coherent} \ac{FT} for the most critical outcome of the gas detection system}
  \label{fig:outcome-4-coherent-ft}
\end{figure}

Quantification of the coherent \ac{FT} will overestimate the probability of the critical outcome unless the part of the system that is working (lamp and siren $L$, $LU$, and sensors $D_1$ and $D_2$) is taken into account.
The non-coherent \ac{FT} with the working part is shown in \cref{fig:outcome-4-non-coherent-ft}.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.65]{outcome-4-non-coherent-ft}
  \caption{\emph{Non-coherent} \ac{FT} for the most critical outcome of the gas detection system}
  \label{fig:outcome-4-non-coherent-ft}
\end{figure}

If the operator \emph{can} be informed, then cut sets $\setsin{D_1, D_2}$ and $\setsin{LU}$ could not have occurred (see \cref{fig:ft-generic-failure-gas-detection-system}), thus the correct qualitative analysis should consider only cut set $\setsin{R_1,R_2}$.
Reducing the expressions of the non-coherent \ac{FT} (\cref{fig:outcome-4-non-coherent-ft}), we obtain the structure expression: $\lnot L \land \lnot LU \land R_1 \land R_2 \land \parsin{\lnot D_1 \lor \lnot D_2}$.
{The approximation for this expression, removing the negated events, gives the cut set $\setsin{R_1,R_2}$, which gives a correct quantitative analysis.}\amnote{Isto poderia ser argumentado pro exemplo anterior? Seria legal ter o mesmo exemplo e pontos de vista distintos (não coerente e coerente).} \adnote{Eu apenas reportei o exemplo. Essa análise foi o autor do exemplo quem fez. Se der vou acrescentar para a outra, não deve ser muito complicado... preciso de mais tempo apenas para analisar com calma.}

%The examples of the usefulness of NOT gates in \ac{FTA} are one of the following, but not limited to: (i) generally, when the probability of negated events are close to $1$, (ii) exclusive states systems as, for example, non-repairable phased mission systems.

%Here we show the example of a simplified electric network (\cref{fig:simplified-electric-network-diagram}), presented in~\cite{CCR2008}.
%Two loads, pumps, $P_1$ and $P_2$ are supplied through circuits $CP_1$ and $CP_2$ by two external lines $D_1$ and $D_2$ through bars $B_1$ and $B_2$.
%The bars can be connected by switch $I$.
%Failures in $B_1$ and $B_2$ are not considered.
%In normal conditions, $I$ is open and is automatically closed in case of a failure of a line.

%\begin{figure}[t]
%  \centering
%  \includegraphicsaspectratio[0.3]{simplified-electric-network-diagram}
%  \caption{Simplified Electric Network}
%  \label{fig:simplified-electric-network-diagram}
%\end{figure}

%Suppose we need to calculate the following probabilities:
%\begin{description}
%  \item[$TOP_1$] = $P_1$ unavailable \emph{or} $P_2$ unavailable;
%  \item[$TOP_2$] = $P_1$ unavailable \emph{and} $P_2$ unavailable;
%  \item[$TOP_3$] = $P_1$ unavailable \emph{and} $P_2$ \emph{available};
%  \item[$TOP_4$] = Only one pump unavailable given only one electric line available.
%\end{description}

%We can construct two independent fault trees, $TP_1$ and $TP_2$, for the unavailability of $P_1$ and $P_2$ as: $TP_1 = P_1 \lor CP_1 \lor \parsin{D_1 \land \parsin{I \lor D_2}}$ and $TP_2 = P_2 \lor CP_2 \lor \parsin{D_2 \land \parsin{I \lor D_1}}$.
%$TOP_1$ and $TOP_2$ generate coherent fault trees, using $TP_1$ and $TP_2$.

\section{Systems' nominal model and faults injection}
\label{sec:faults-injection}

Control system modelling using \simulink block diagrams~\cite{MathWorks2010} is recommended in~\cite{Nise1992} and have been used by our industrial partner.
%We follow this recommendation in this work.
It is a complementary tool of \matlab~\cite{MathWorks2010c}.
% ## TODO: melhorar essa frase
In fact, it works as a graphical interface to \matlab.
A \simulink model has blocks and connections between these blocks, named signals.
Each block has inputs and outputs and an internal behaviour expressed by its mathematical formula, which defines a function of the inputs for each output.
There are many predefined blocks in the tool.
It is also possible to create new blocks or use subsystems that encapsulate other blocks.
A simulation adds extra parameters to a block diagram, like elapsed time and time between states.
The elapsed time of a simulation is an abstraction for the quantity of possible simulation states and the time between states is related to the lowest common denominator of the sample time.
Some components define different sample times, depending on their mode of operation.
Usually, the value for this property is set to \textsim{auto}, allowing \simulink to choose a proper value automatically.

% \begin{figure*}[!t] \centering
%     \includegraphicsaspectratio[0.8]{acsBlockDiagrams}
%     \caption{\textpt{Diagrama em blocos do ACS fornecido pela
%     \EMBRAER.}\texten{Block diagram of the ACS provided by \EMBRAER}}
%     \label{fg:acsBlockDiagrams}
% \end{figure*}
\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio{acsBlockDiagrams}
  \caption{Block diagram of the ACS provided by \EMBRAER (nominal model)}
  \label{fg:acsBlockDiagrams}
\end{figure}

Nowadays, control systems are usually composed of an electromechanical part and a processor.
\Cref{fg:acsBlockDiagrams} shows the components of a feedback system~\cite{AM2008} which was provided by \EMBRAER.
In this system, the feedback behaviour is given by the \textsim{Controller} (1), \textsim{Actuator} (2) and \textsim{Sensor} (3). A command is received by the \textsim{Controller}, which sends a signal to the \textsim{Actuator} to start its movement.
The \textsim{Sensor} detects the actual position of the \textsim{Actuator} and sends it back to the \textsim{Controller}, which adjusts the given command to achieve the desired position. This loop (feedback) continues until the desired position given by the original command is reached.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.6]{blockDiagramMonitorInternals}
  \caption{Internal diagram of the monitor component (\cref{fg:acsBlockDiagrams}~(A)).}
  \label{fg:blockDiagramMonitorInternals}
\end{figure}

\Cref{fg:blockDiagramMonitorInternals} shows the internal elements of the monitor component (\cref{fg:acsBlockDiagrams}~(A)), which is used as case study in \cref{chap:case-study} to illustrate our
strategy.
The outputs of the hardware elements are annotated with \textsim{HW}, which are the two power sources and an internal component of the monitor (switch command).

%\adnote{Verificar se as frases tiradas da introdução se adequam melhor aqui.}
%As hardware components are susceptible to fault injection, this strategy consists of: (i) a process that represents the nominal behaviour (without fault injection), (ii) a process that represents the erroneous behaviour with all possibilities of faults, due to fault injection, and (iii) an observer process to compare the nominal behaviour with the erroneous behaviour.
%To create failure expression, we abstract the fault traces by not considering events ordering.

To perform a formal verification in a \simulink system model we use a model-checking tool, \theac{FDR}.
It is a refinement checker for formal models written in \ac{CSPm}.
To verify a refinement, it takes two specifications:
\begin{alineasinline}
  \item a specification with more abstract properties, and
  \item an implementation with more concrete properties.
\end{alineasinline}
If a refinement does not hold (the implementation fails to refine the specification), \theac{FDR} shows counter-examples as traces of events.
The \ac{CSPm} language is suitable to model concurrent behaviour and is very expressive to model systems' states.
The work reported in~\cite{JMS+2011} translates a \simulink model to the \ac{CSPm} language.
%
The resulting \ac{CSPm} code (implementation) is then used to check if it meets functional requirements also encoded in \ac{CSPm} (specification).

In our previous work, reported in~\cite{DM2012}, we modified such a translation to perform fault injection using hardware annotations allowing a subsystem or part to ``break'' randomly.
%
We designed \iac{CSPm} process to act as an observer (specification), watching outputs of the nominal version and comparing to the outputs of the ``breakable'' version (with injected faults---the implementation) of the system.
%
When the \ac{CSPm} process of the model and the observer are loaded into the \acs{FDR} model-checker, counter-examples are generated for each output that differs from the nominal model, thus obtaining a \emph{sequence} of injected faults combinations that leads to the unexpected output, which are indeed \emph{fault traces}.

In what follows, injected faults and the top-level failure have generic names based on the names of the \simulink model blocks.
It is out of the scope of~\cite{DM2012} to define event names.

For the \simulink model shown in~\cref{fg:blockDiagramMonitorInternals}, some representative fault traces are:

\begin{snippetcspm}[1]
TRACE 1:
failure.Hardware.N04_RelationalOperator.1.EXP.B.true
failure.Hardware.N04_RelationalOperator.1.ACT.B.false
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 2:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.true
failure.Hardware.N04_RelationalOperator.1.ACT.B.false
out.1.OMISSION

TRACE 3:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 4:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
out.1.OMISSION

TRACE 5:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
out.1.OMISSION

TRACE 6:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 7:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true

TRACE 8:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
\end{snippetcspm}
%
where \verb$N04$ is the subsystem name of the monitor in the \simulink diagram, \verb$MonIn1$ (first input of the monitor), \verb$MonIn2$ (second input of the monitor), and \verb$RelationalOperator$ (switcher controller) are the names of the hardware components in the \simulink diagram.

We only show eight counter-examples, but \acs{FDR} generates a total of 64 counter-examples for this system.
The other counter-examples are similar to the traces shown with different internal events.

To reuse \ac{hiphops}, which is based on \acp{SFT}, we ``remove'' the ordering information of the traces to generate a failure expression.
Each fault trace is abstracted as a conjunction (\ac{AND} combination of the inner events, thus losing the ordering information), and the several conjunction-based fault events are combined using \acp{OR} (disjunctions).
The result of the combination is a Boolean\index{Boolean Algebra} expression that represents the conditions that cause an undesirable output, the failure expression of the model.
With the \ac{algebra} proposed in this work we do not ``remove'' the ordering information, so we are able to use this information to generate or perform \ac{DFT} and \ac{TFT} analyses (\acp{TFT} have order-related operators, and it is shown in \cite{Merle2010,MRL2011b,MRL2011} that \acp{DFT} can be expressed by order-related operators).

If the failure expression is obtained for a whole system, it is indeed the structure expression\index{structure expression} of a \acl{FT} for a general failure as the top-level event.
Although it is possible to obtain the failure expression for a larger system, it may be impractical due to state-space explosion in \ac{CSPm} model analysis.
Thus it should be used for components and subsystems or small systems following \ac{hiphops} compositional structure.
%
%failure expression is used as the input of the strategy presented in~\cite{MJG+2010}.
Using failure expression as subsystem annotations in~\cite{PMS+2001}, it is possible to obtain structure expressions\index{structure expression} for a larger system.
It is worth noting that the goal of the work reported in~\cite{DM2012} was to connect with \ac{hiphops}, which is based on static \aclp{FT}.
But we already knew that we had a richer fault modelling information than that presented in~\cite{DM2012} because we abstracted traces (which already capture fault events ordering) to create propositions (any fault events order combination).
%In the works reported in~\cite{APR+2013,AFP+2013,AIP+2014}, fault modelling was used to verify if a system model is fault tolerant with respect to undesirable critical failures.
%The faults were explicitly modelled, and the analysis starts after the preliminary analysis of faults.
%Instead of modelling faults directly in a model, it is possible to inject faults without explicit fault modelling.
%This allows the system to break in hardware parts.

%Each injected fault appears on the trace as two events: the expected (\verb$EXP$) value of the nominal system and the actual (\verb$ACT$) value used on the breakable system.
%For example, in \verb$TRACE 1$, the expected output of the switcher (\verb$N04_RelationalOperator$) is true, but the actual value is false.

To show how these traces become failure expression, let us abbreviate fault names as:
%
\begin{snippetcspm}[2]
A = failure.Hardware.N04_MonIn1.1
B = failure.Hardware.N04_MonIn2.1
S = failure.Hardware.N04_RelationalOperator
\end{snippetcspm}
%
So, for each trace, we obtain an expression:
\begin{align*}
\mathtt{TRACE\,1} &= S \land B\\
\mathtt{TRACE\,2} &= B \land S\\
\mathtt{TRACE\,3} &= A \land B\\
\mathtt{TRACE\,4} &= B \land A\\
\mathtt{TRACE\,5} &= A \land S\\
\mathtt{TRACE\,6} &= A \land S \land B\\
\mathtt{TRACE\,7} &= A \land B \land S\\
\mathtt{TRACE\,8} &= B \land A \land S
\end{align*}

And we combine them as a single Boolean\index{Boolean Algebra} expression:
%
$\mathtt{TRACE\,1} \lor \mathtt{TRACE\,2} \lor \mathtt{TRACE\,3} \lor \mathtt{TRACE\,4} \lor \mathtt{TRACE\,5} \lor \mathtt{TRACE\,6} \lor \mathtt{TRACE\,7} \lor \mathtt{TRACE\,8}$, %
which by a traditional Boolean reduction strategy results in:
%
\[(A \land B) \lor (S \land (A \lor B))\]

\begin{sloppypar}
The above expression is exactly the same failure expression provided by \EMBRAER if we use the following association (\cref{tbl:acsAnnotations}):
\begin{align*}
A &= \text{LowPower-In1}\\
B &= \text{LowPower-In2}\\
S &= \text{SwitchFailure}
\end{align*}
\end{sloppypar}

\begin{table}[t]
\renewcommand{\arraystretch}{1.3}
\caption{Annotations table of the ACS provided by \EMBRAER}
\label{tbl:acsAnnotations}
\centering
\begin{tabularx}{\linewidth}{|c|c|c|X|}
\hline
\bfseries Component & \bfseries Deviation & \bfseries Port & \bfseries Annotation \\
\hline
PowerSource & LowPower & Out1 & PowerSourceFailure\\
\hline
Monitor & LowPower & Out1 & (SwitchFailure AND (LowPower-In1 OR LowPower-In2)) OR (LowPower-In1 AND LowPower-In2) \\
\hline
Reference & OmissionSignal & Out1 & ReferenceDeviceFailure OR LowPower-In1\\
\hline
\end{tabularx}
\end{table}

Note that when we combine each fault with \ac{AND} gates, we lose the information about order\footnote{In our previous work we designed the observer to ignore order as well, by making similar traces---with different ordering---the same size. Here we modified the observer specification to make similar traces with different sizes.}: $S \land B$ and $B \land S$ are equal, due to the commutative law of Boolean expressions.

Our strategy finds fault combinations $S$ and $B$ (in the sense of $S$ occurring before $B$) as well as $B$ and $S$ (in the sense of $B$ occurring before $S$) but abstracts this ordering information obtaining $B$ and $S$, which is equivalent to $S$ and $B$ in Boolean\index{Boolean Algebra} Algebra.
%
If $A$ fails before $S$, the system fails because it should switch to $B$, but the switcher is in a faulty state.
%
On the other hand, if $S$ fails before $A$, the switcher fails because it inadvertently switched to $B$ when $A$ was still operational.
%
When $A$ fails, nothing changes and the output of the system is obtained from $B$.

We also employed the strategy proposed in the work~\cite{DM2012} in another case study and obtained a weaker failure expression (that is, our expression considers more cases).
The failure expression provided by the engineers of our industrial partner was stronger because they considered that one component has a very low probability of failure and removed it from the failure analysis.
Although acceptable, it may cause incorrect analysis.
Our strategy avoids this kind of issue by being completely systematic.

\section{Isabelle/HOL}
\label{sec:isabelle}

%To generate the file:
%Start an Isabelle session (Cygwin terminal in Windows)
%Go to dir isabelle-hol-basic
%Run isabelle build -D .
\input{isabelle-hol-basic/output/document/Basic}

\adnote{Use BA1993 to minimise the gap between systems models and fault trees. Also: MCS+1999}
\adnote{Write the problem: simple mathematical notation for all fault trees. Include direct DFT-to-ATF mapping.}

\chapter{A free algebra to express structure expressions of ordered events}
\label{chap:strategy}

\todo{Explain the interaction of (i) fault-injection, (ii) theorem proving, and (iii) symbolic execution.}
\todo{dizer que nossa abordagem usa a abordagem similar à de expressões de estrutura, mas que tem o objetivo de dar uma semântica denotacional baseada em conjuntos}

Recall from \cref{sec:time-relations,sec:fault-trees} that fault events are independent on one another if the events are not susceptible to a common cause.
The set-theoretical abstraction of structure expressions\index{structure expression} for \acp{SFT}~\cite[pp. VI-11]{VGR+1981} is very close to \iac{FBA}\index{Boolean Algebra!Free}, where each generator in \acp{FBA}\index{Boolean Algebra!Free} corresponds to a fault event symbol in \aclp{FT}.
In \acp{FBA}\index{Boolean Algebra!Free}, as generators are ``free'', they are independent on one another and Boolean\index{Boolean Algebra} formulas are written as a set of sets of possibilities, which are similar to the structure expressions\index{structure expression} of \acp{SFT}.
%This is equivalent to the disjunctive normal form, where each set is a minterm (conjunction) and the formula itself is the disjunction of minterms.

We showed in \cref{sec:fault-trees} that there is an omnipresence of order-based operators to analyse \acp{TFT} and \acp{DFT}.
And that each approach describes a new algebra based on different representations of events ordering with similar theorems to reduce expressions to a canonical form.

From the need to tackle events ordering and from the ordering information we had from fault injection that we developed in~\cite{DM2012}, we defined a lists-based algebra, called \acf{algebra}, to express and analyse systems considering events ordering.
We also provide a mapping from fault traces~\cite{DM2012} (from \ac{CSPm} models) to this algebra.
The order-specific operations are expressed with a new operator ($\xbeforeop$) that we call \ac{XBefore} (or exclusive before).

The set of sets for \acp{FBA}\index{Boolean Algebra!Free} are the denotational semantics for Boolean\index{Boolean Algebra} algebras.
We use the concept of generators to propose the \ac{algebra} with a denotational semantics of a set of lists without repetition (distinct lists).
The choice of lists is because this structure inherently associates a generator to an index, making implicit the representation of order.
These lists are composed by non-repeated elements (distinct lists) because the events in \aclp{FT} are non-repairable, thus they do not occur more than once.

This list representation is different from the Sequence Number function used in~\cite{WP2009,Walker2009}, but is related to the concept that there should be no gaps between consecutive events occurrence.
It is different because order 0 (zero) in~\cite{WP2009,Walker2009} means non-occurrence.
It may cause a discontinuity because 0 to 1 is different of 1 to 2.
In \acp{FBA}\index{Boolean Algebra!Free} the non-occurrence of an event is just the absence of the event.
Thus we use the same representation of non-occurrence in \ac{algebra} to avoid this discontinuity.

%The work reported in~\cite{MRL2011,Merle2010} uses continuous time and the relations of events is obtained from a ``date-of-occurrence'' function.
%It is related to the detection of an event as discussed in~\cref{sec:time-relations,sec:structure-expressions} and the useful information is in fact the order of occurrence of the events, not the date-of-occurrence itself.


%In our previous work, we used this technique of using fault injection to reuse a nominal model without explicit fault modelling, obtaining Boolean expressions of systems' failures, as we showed in \cref{sec:faults-injection}.
%The drawback of this approach is that fault events ordering information is lost because it is not relevant on the Boolean expressions extraction.

%We show reduction laws relating the XBefore operator to traditional Boolean operators.
%It is important to note that we support a NOT operator in our algebra.

%\usepackage{graphics} is needed for \includegraphics
%\begin{figure}[t]
%\begin{center}
  %\includegraphics[width=0.5\textwidth]{strategy}
%  \caption{Strategy overview}
%  \label{fig:overview}
%\end{center}
%\end{figure}

%It is defined as a set of all sets of distinct lists, called $\algebraset$.
%Then we show that all Boolean operators takes elements from and into $\algebraset$.

%We now show the \ac{algebra} as a set of all possible formulas.
In the following we show the definitions and laws of our proposed \ac{algebra}.
To avoid repetition, let $S$, $T$ and $U$ be sets of distinct lists.
A list $xs$ is distinct if it has no repeated element.
So, if $x$ is in $xs$, then it has a unique associated index $i$ and we denote it as $x = \nth{xs}{i}$.
Furthermore, as we follow \iac{FBA}\index{Boolean Algebra!Free} characterisation, we also need to show that the generators are independent.

The \ac{algebra} form a free algebra, similarly to \acp{FBA}\index{Boolean Algebra!Free}.
\emph{Infimum} and \emph{Supremum} are defined as set intersection ($\inter$) and union ($\union$) respectively.
The order within the algebra is defined with set inclusion ($\subseteq$).

To distinguish the permutations that are not defined in \ac{FBA}\index{Boolean Algebra!Free}, we need a new operator.
We give the definition of \ac{XBefore} ($\xbeforeop$) in terms of list concatenation, similar to the work reported in~\cite{DM2015}:
%
\begin{equation}
\label{def:xbefore-append}
\xbefore{S}{T} =
  \setsin{
    zs | \exists xs, ys \bullet \parsin{\listset{xs}} \inter \parsin{\listset{ys}} = \{\}
      \land xs \in S \land ys \in T \land zs = \append{xs}{ys}
  }
\end{equation}
%
where the $\listset{}$ function returns the set of the elements of a list, and $\append{}{}$ concatenates two lists.

In some cases it is more intuitive to use the \ac{XBefore} definition in terms of lists slicing because it uses indexes explicitly.
%\Cref{thm:xbefore} shows that the two definitions are equivalent.
Lists slicing is the operation of taking or dropping elements, obtaining a sublist.
In slicing, the starting index is inclusive, and the ending is exclusive.
Thus the first index is 0 and the last index is the list length.
For example, the list $\slice{xs}{i}{\length{xs}}$ is equal to the $xs$ list, where $\length{xs}$ is the list length.
We use the following notation for list slicing:
%
\begin{subequations}
\begin{align}
\slice{xs}{i}{j} &= \text{starts at $i$ and ends at $j-1$}\label{def:slice}\\
\sliceright{xs}{j} &= \slice{xs}{0}{j}\label{def:slice-right}\\
\sliceleft{xs}{i} &= \slice{xs}{i}{\length{xs}}\label{def:slice-left}
\end{align}
\end{subequations}

List slicing and concatenation are complementary: concatenating two consecutive slices results in the original list:
\begin{equation}
\label{law:slice-append}
\forall i \bullet \append{\sliceright{xs}{i}}{\sliceleft{xs}{i}} = xs
\end{equation}

There is an equivalent definition of \ac{XBefore} with concatenation using lists slicing:
%
\begin{equation}
\label{def:xbefore-slice}
\xbefore{S}{T} =
  \setsin{
    zs | \exists i \bullet \sliceright{zs}{i} \in S \land \sliceleft{zs}{i} \in T
  }
\end{equation}

A variable in \ac{algebra} is defined by one generator, and denotes its occurrence:
%
\begin{equation}
\label{def:var}
\var{x} =
  \setsin{
    zs | x \in zs
  }
\end{equation}

The following expressions are sufficient to define the \ac{algebra} in terms of an inductively defined set ($\algebraset$):
%
\begin{subequations}
\label{def:algebraset}
\begin{align}
\var x & \in \algebraset & \text{Variable}\label{def:algebraset-var}\\
S \in \algebraset \implies -S & \in \algebraset & \text{Complement, Negation}\label{def:algebraset-compl}\\
S \in \algebraset \land T \in \algebraset \implies S \inter T & \in \algebraset & \text{Intersection, \emph{Infimum}}\label{def:algebraset-inf}\\
S \in \algebraset \land T \in \algebraset \implies \xbefore{S}{T} & \in \algebraset & \text{\ac{XBefore}}\label{def:algebraset-xbefore}\\
\intertext{Following the definitions, the expressions below are also valid for $\algebraset$:}
\True &\in \algebraset & \text{Universal set, True}\label{def:algebraset-true}\\
\False &\in \algebraset & \text{Empty set, False}\label{def:algebraset-false}\\
S \in \algebraset \land T \in \algebraset \implies S \union T &\in \algebraset & \text{Union, \emph{Supremum}}\label{def:algebraset-sup}
\end{align}
\end{subequations}

The following expressions are valid for generators $a$ and $b$ and are sufficient to show that the generators are independent:
%
\begin{subequations}
\label{eqs:generators-independence}
\begin{align}
&\var a \subseteq \var b \iff a = b\label{eqs:generators-independence-subseteq-eq}\\
&\var a = \var b \iff a = b\\
&\var a \not\subseteq - \var b\\
&\var a \neq -\var b\label{eqs:generators-independence-subseteq-neq-compl} \\
&- \var a \not\subseteq \var b\\
&- \var a \neq \var b\label{eqs:generators-independence-subseteq-compl-neq}
\end{align}
\end{subequations}

Expressions \eqref{def:algebraset-var} to \eqref{def:algebraset-sup} and \eqref{eqs:generators-independence-subseteq-eq} to \eqref{eqs:generators-independence-subseteq-compl-neq} implies that the \ac{algebra} without the \ac{XBefore} operator \eqref{def:xbefore-append} forms a Boolean\index{Boolean Algebra} algebra based on sets of lists.
And this is also equivalent to \iac{FBA}\index{Boolean Algebra!Free} with the same generators.

In our previous work~\cite{DM2015} we stated a relation of \ac{XBefore} and \emph{supremum}, provided the operands are variables \eqref{def:var}.
Now we generalise this relation in terms of abstract properties of the operands of the \ac{XBefore}.
We name these properties as \emph{temporal properties}.
%and show them in \cref{sec:temporal-properties}.

\section{Temporal properties (\emph{\tempotext})}
\label{sec:temporal-properties}

Temporal properties give a more abstract and less restrictive shape on the \ac{XBefore} laws.
These properties avoid the requirement that every operand of \ac{XBefore} should be a variable \eqref{def:var}.
%The properties are: $\tempo[1]{}$ (\cref{def:tempo1}), $\tempo[2]{}$ (\cref{def:tempo2}), $\tempo[3]{}$ (\cref{def:tempo3}), and $\tempo[4]{}$ (\cref{def:tempo4}).

The first temporal property is about disjoint split.
If the first part of a list is in a given set, then every remainder part is not.
So, if a generator is in the beginning of a list, it must not be at the ending (and vice-versa).
%
%\todo{Explain temporal properties with respect to Figure 1 about relation of events? At least make it clearer.}
%
\begin{subequations}
\begin{align}
\tempo[1]{S} &= \forall i, j, zs \bullet
  i \le j \implies
  \lnot \left(
    \sliceright{zs}{i} \in S \land \sliceleft{zs}{j} \in S
  \right)\label{def:tempo1}\\
\tempo[2]{S} &= \forall i, zs \bullet
  zs \in S \iff
  \sliceright{zs}{i} \in S \lor \sliceleft{zs}{i} \in S\label{def:tempo2}\\
\tempo[3]{S} &= \forall i, j, zs \bullet
  j < i \implies
  \left(
    \slice{zs}{j}{i} \in S \iff \sliceright{zs}{i} \in S \land \sliceleft{zs}{j} \in S
  \right)\label{def:tempo3}\\
\tempo[4]{S} &= \forall zs \bullet zs \in S \iff (\exists i \bullet \slice{zs}{i}{\left(i+1\right)} \in S)\label{def:tempo4}
%\intertext{Replace $\tempo[4]{S}$ by (less restrictive):}
%&= \forall zs \bullet zs \in S \iff \exists i,j \bullet i < j \land \slice{zs}{i}{j} \in S
\end{align}
\end{subequations}

The second temporal property is about belonging to one sublist in the beginning or in the end.
If a generator is in a list, then it must be at the beginning or at the ending.
%
%\begin{definition}[\Tempotext 2, belongs to one sublist in the beginning or at the ending]
%\label{def:tempo2}
%Let $S$ be a set of distinct lists:
%\end{definition}
%

The third temporal property is about belonging to one sublist in the middle.
If a generator belongs to a sublist between $i$ and $j$, then it belongs to the sublist that starts at first position and ends in $j$ and to the sublist that starts at $i$ and ends at the last position (both sublists contain the sublist in the middle).
%
%\begin{definition}[\Tempotext 3, belongs to the middle of a sublist]
%\label{def:tempo3}
%Let $S$ be a set of distinct lists:
%\end{definition}
%

Finally, if a generator belongs to a list, then there is a sublist of size one that contains the generator.
%
%\begin{definition}[\Tempotext 4, belongs to one sublist of size one]
%\label{def:tempo4}
%Let $S$ be a set of distinct lists:
%\end{definition}
%

Variables have all four temporal properties. For a generator $x$, the following is valid:
%
\begin{equation}
\label{law:var-tempo}
\tempo[1]{\left(\var{x}\right)} \land
\tempo[2]{\left(\var{x}\right)} \land
\tempo[3]{\left(\var{x}\right)} \land
\tempo[4]{\left(\var{x}\right)}
\end{equation}

\begin{sloppypar}
In our previous work~\cite{DM2015} we used set difference to specify the \ac{XBefore} operator.
Provided $\tempo[1]{S}$ and $\tempo[1]{T}$, \ac{XBefore} in~\cite{DM2015} is equivalent to \eqref{def:xbefore-append}:
%
\begin{equation}
\label{law:old-xbefore}
\xbefore{S}{T} = \left\{ zs | \exists xs, ys \bullet xs \in S-T \land ys \in T-S \land \distinct{zs} \land zs = \append{xs}{ys}  \right\}
\end{equation}
\end{sloppypar}

Other expressions also meet one or more temporal properties:
\begin{subequations}
\begin{align}
\tempo[1]{S} \land \tempo[1]{T} & \implies \tempo[1]{\parsin{S \inter T}}\label{law:tempo1-inter}\\
\tempo[3]{S} \land \tempo[3]{T} & \implies \tempo[3]{\parsin{S \inter T}}\label{law:tempo3-inter}\\
\tempo[2]{S} \land \tempo[2]{T} & \implies \tempo[2]{\parsin{S \union T}}\label{law:tempo2-union}\\
\tempo[4]{S} \land \tempo[4]{T} & \implies \tempo[4]{\parsin{S \union T}}\label{law:tempo4-union}
\end{align}
\end{subequations}

\section{\acs*{XBefore} laws}
\label{sec:xbefore-laws}

We now show some laws to be used in the algebraic reduction of \ac{algebra} formulas.
The laws follow from the definition of \ac{XBefore}, from events independence, and from the temporal properties.

We use a normal form similar to the \ac{DNF} of Boolean\index{Boolean Algebra} algebra.
In \ac{DNF} each sub-expression is a minimal cut set\index{Minimal Cut!Sets} for \ac{SFT}.
In our normal form, also called \ac{DNF}, we allow \acp{AND}, \acp{NOT}, and \acp{XBefore} to be in the sub-expressions.
Each sub-expression is a set of minimal cut sequences\index{Minimal Cut!Sequences} for \ac{TFT} and \ac{DFT}.
The following formulas are in \ac{DNF}:
%
\begin{align*}
&\parsin{A \inter -B} \union \parsin{\parsin{\xbefore{A}{B}} \inter C}\\
&A \union B\\
&\xbefore{A}{B}\\
&A \inter B\\
&\xbefore{\xbefore{A}{B}}{C}
\end{align*}
%
The following formulas are \emph{not} in \ac{DNF}:
%
\begin{align*}
&-\parsin{A \union B}\\
&A \inter \parsin{B \union C}\\
&\xbefore{A}{\parsin{B \union C}}\\
&\xbefore{A}{\parsin{B \inter C}}
\end{align*}

\begin{sloppypar}
But to transform the last two formulas into \ac{DNF}, one can use Laws \eqref{thm:xbefore-sup-1},~\eqref{thm:xbefore-sup-2},~\eqref{thm:xbefore-inf-1} and~\eqref{thm:xbefore-inf-2}, for instance.
\end{sloppypar}

We define events independence ($\independenteventsop$) as the property that one operand does not imply the other.
For example, we need to avoid that the operands of \ac{XBefore} are $\var{a}$ and $\var{a} \union \var{b}$ (it results in $\False$, see \eqref{thm:xbefore-not-idempotent}).
%
\begin{equation}
\label{law:independent-events}
\independentevents{S}{T} = \forall i, zs \bullet
  \lnot \left(
    \slice{zs}{i}{\left(i+1\right)} \in S \land
    \slice{zs}{i}{\left(i+1\right)} \in T
  \right)
\end{equation}

The absence of occurrences ($\False$, the empty set of $\algebraset$) is a ``0'' for the \ac{XBefore} operator.
%
\begin{subequations}
\begin{align}
\xbefore{\False}{S} =&
  \False &
  \text{left-false-absorb}
  \label{thm:xbefore-of-false-1}\\
%
\xbefore{S}{\False} =&
  \False &
  \text{right-false-absorb}
  \label{thm:xbefore-of-false-2}\\
%
\left(\xbefore{S}{T}\right) \union S =& S &
  \text{left-union-absorb}
  \label{thm:xbefore-sup-absorb-1}\\
%
\left(\xbefore{T}{S}\right) \union S =& S &
  \text{right-union-absorb}
  \label{thm:xbefore-sup-absorb-2}\\
%
\tempo[1]{S} \implies
  \xbefore{S}{S} =&
  \False &
  \text{non-idempotent}
  \label{thm:xbefore-not-idempotent}\\
%
\tempo[1]{S}\land\tempo[1]{T}\land \tempo[1]{U}\implies&\nonumber\\
  \xbefore{S}{(\xbefore{T}{U})} =&
  \xbefore{(\xbefore{S}{T})}{U} &
  \text{associativity}
  \label{thm:xbefore-associativity}
%
\end{align}
\end{subequations}
%
The \ac{XBefore} is absorbed by one of the operands: if one of the operands may happen alone, thus the order with any other operand is irrelevant.
However, an event cannot come before itself, thus \ac{XBefore} is not idempotent.
The \ac{XBefore} but is associative.

To allow formula reduction we need the relation of \ac{XBefore} to the other Boolean\index{Boolean Algebra} operators.
First we use the \ac{XBefore} as operands of union and intersection.
%
\begin{subequations}
\begin{align}
\tempo[1]{S} \land \tempo[1]{T}\implies&\nonumber\\
  \parsin{\xbefore{S}{T}} \inter \parsin{\xbefore{T}{S}} =&
  \False &
  \text{inter-equiv-false}
  \label{thm:xbefore-inf-equiv-bot}\\
%
\tempo{S} \land \tempo{T} \land \independentevents{S}{T}\implies&\nonumber\\
  \parsin{\xbefore{S}{T}} \union \parsin{\xbefore{T}{S}} =&
  S \inter T &
  \text{union-equiv-inter}
  \label{thm:xbefore-sup-equiv-inf}
%
\end{align}
\end{subequations}
%
As the \ac{XBefore} is not symmetric, the intersection of symmetrical sets is empty.
The union of the symmetric is a partition of the intersection of the operands.

In our previous work~\cite{DM2015}, we stated that $S$ and $T$ had to be variables.
For example, of the form $\var{s}$ and $\var{t}$.
Now, each law requires that the operands satisfy some of the temporal properties, avoiding using variables explicitly.
%So, as variables satisfy all temporal properties and by \eqref{thm:xbefore-sup-equiv-inf}, our theorem ``Exclusive before \emph{supremum}'' is still valid.

Boolean\index{Boolean Algebra} operators are used as operands of the \ac{XBefore} in the following laws.
%
\begin{subequations}
\begin{align}
\xbefore{\left(S \union T\right)}{U} =&
  \parsin{\xbefore{S}{U}} \union \parsin{\xbefore{T}{U}} &
  \text{left-union-dist}
  \label{thm:xbefore-sup-1}\\
%
\xbefore{S}{\left(T \union U\right)} =&
  \parsin{\xbefore{S}{T}} \union \parsin{\xbefore{S}{U}} &
  \text{right-union-dist}
  \label{thm:xbefore-sup-2}\\
%
\tempo{S} \land \tempo{T} \land \independentevents{S}{T} & \implies\nonumber \\
  \xbefore{\left(S \inter T\right)}{U} =&
  \parsin{\xbefore{\xbefore{S}{T}}{U}} \union \nonumber\\
  &\parsin{\xbefore{\xbefore{T}{S}}{U}} &
  \text{left-inter-dist}
  \label{thm:xbefore-inf-1}\\
%
\tempo{T} \land \tempo{U} \land \independentevents{T}{U} & \implies \nonumber\\
  \xbefore{S}{\left(T \inter U\right)} =&
  \parsin{\xbefore{S}{\xbefore{T}{U}}} \union \nonumber\\
  &\parsin{\xbefore{S}{\xbefore{U}{T}}} &
  \text{right-inter-dist}
  \label{thm:xbefore-inf-2}\\
%
\tempo[2]{S} \implies S \inter \parsin{\xbefore{T}{U}} =&
  \parsin{\xbefore{\parsin{S \inter T}}{U}} \union \nonumber\\
  &\parsin{\xbefore{T}{\parsin{S \inter U}}} &
  \text{unordered}
  \label{thm:and_xbefore_equiv_or_xbefore}
\end{align}
\end{subequations}
%
\ac{XBefore} is distributive over union.
On the other hand, the intersection is related to order.
Thus it is not distributive with \ac{XBefore}.
Finally, the intersection of an event with an \ac{XBefore} states that such an event can occur in any order within the events in the \ac{XBefore}.

The law name, unordered, of \eqref{thm:and_xbefore_equiv_or_xbefore} is clearer if we expand \eqref{thm:and_xbefore_equiv_or_xbefore} with \eqref{thm:xbefore-inf-1} and ~\eqref{thm:xbefore-inf-2}:
%
%\begin{subequations}
\begin{align}
\tempo{S} \land \tempo{T} \land \nonumber\\
  \tempo{U} \land \independentevents{S}{T} \land \independentevents{S}{U} & \implies \nonumber\\
  S \inter \parsin{\xbefore{T}{U}} = &
  \parsin{\xbefore{\xbefore{S}{T}}{U}} \union \nonumber\\
  & \parsin{\xbefore{\xbefore{T}{S}}{U}} \union \nonumber\\
  & \parsin{\xbefore{\xbefore{T}{U}}{S}} &
  \text{expanded-unordered}
  \label{thm:and_xbefore_equiv_or_xbefore_expanded}
%\\
%
%\tempo[2]{S} \implies S \inter \parsin{\xbefore{S}{T}} =& \xbefore{S}{T} &
%  \text{left-inter-absorb}
%  \label{thm:xbefore-inf-absorb-1}\todo{Prove this in Isabelle}\\
%
%
%\tempo[2]{S} \implies S \inter \parsin{\xbefore{T}{S}} =& \xbefore{T}{S} &
%  \text{right-inter-absorb}
%  \label{thm:xbefore-inf-absorb-2}\todo{Prove this in Isabelle}
\end{align}
%\end{subequations}
%
%From \eqref{thm:xbefore-not-idempotent} and~\eqref{thm:and_xbefore_equiv_or_xbefore}, intersection and \ac{XBefore} also have an absorption law.

\section{Propositions}
\label{sec:propositions}

In this section we discuss the theorems and definitions the still need to be proved.
We present them as propositions.

Soundness and completeness of the \ac{algebra} is given in terms of the algebraic form and its denotational semantics (\cref{sec:soundness-completeness-algebra}).
The \ac{activation} is defined in terms of a logic that is solved by decision and some output value (\cref{sec:activation}).

\subsection{Soundness and completeness of \acs*{algebra}}
\label{sec:soundness-completeness-algebra}

%Soundness: if it is wrong, we cannot prove
%Completeness: everything that is right can be proved

Given the semantics of a formula of~\ac{algebra}, there is always a set of sequences that represents exactly the formula.
To guarantee the completeness we show that for every set of sequences there is a corresponding formula in \ac{algebra}.

\begin{proposition}[Soundness and completeness of \ac{algebra}]
\amnote{Está de acordo com os livros de lógica?}
\adnote{Não tive muito tempo para pensar, mas sim. Eu olhei o significado de ambos e montei a proposição.}
Let $F$ be the set of all formula in \ac{algebra}, and $SS$ be the set of all sets of sequences:
%
\begin{subequations}
  \begin{align}
    \forall f \in F \ldotp \exists S \in SS \ldotp f & = S & \text{Soundness}\\
    \forall S \in SS \ldotp \exists f \in F \ldotp f & = S & \text {Completeness}
  \end{align}
\end{subequations}
\end{proposition}
%
The equality in the proposition is set-based, thus, in both cases, $f \subseteq S \land S \subseteq f$.

\subsection{\acs*{activation} concepts}
\label{sec:activation}

The \acf{activation} is used to model systems faults.
When reasoning about faults, engineers analyse component by component, defining its outputs in the presence of each possible fault.
The \ac{activation} is nothing more than this: the outputs of the components in the presence of (some combination of) faults.
To ensure that all possibilities are considered (those that the engineer reasoned about them), the formula that results from the output conditions shall be a \emph{tautology}.
For example, if the engineer defines that a component produces as outputs:
\begin{alineasinline}
  \item $A$ if $F_1$ occurs, and
  \item $B$ if $F_2$ occurs,
\end{alineasinline}
then there should be an output for condition $\lnot F_1 \land \lnot F_2$, and $A$ and $B$ must converge when both $F_1$ and $F_2$ occur.
By convergence, an initial idea is that $A = B$ in this case.
To connect components and to generate \acp{FT}, we ask questions to the \ac{activation} formulas: we define \emph{predicates}.

A nominal value is required to handle the conditions that do not result in a failure.
Recall from previous example, if $F_1$ and $F_2$ do not occur, then the system should be in a normal state, and its output is signalled as nominal with some nominal value.
Nominal values are used to analyse value-based failures.
In general, failure outputs do not have an associated value.

In some cases a degraded state can be an undesired state, as for example, if one wants to check the probability of operating in high-cost conditions.
For these situations, the output values are signalled as degraded, but they have an associated value.

To connect components, instead of using a fixed condition like $F_1$ and $F_2$, we use a predicate.
For example: if an omission is detected in the first input, the output of this component is $A$; the component outputs $B$ if $F_1$ occurs, and it outputs its nominal value, otherwise.

To obtain a fault tree from \ac{activation} we define a predicate over a whole \ac{activation} formula of a system.
For example: what are the conditions that generate and output \emph{omission}?

The underlying conditions in \ac{activation} can be in Boolean\index{Boolean Algebra} algebra or in \ac{algebra}.
In any case, soundness and completeness in \ac{activation} is given in terms of the underlying algebra: given a formula in \ac{activation}, any predicate generates a valid expression in the underlying algebra, and there exists a formula and a predicate for any expression in the underlying algebra.

\begin{proposition}[Soundness and completeness of \ac{activation}]
Let $F$ be the set of all formulas in \ac{activation}, $G$ be the set of all formulas in its underlying algebra, and $P$ a predicate over output values of \ac{activation}, then:
%
\begin{subequations}
  \begin{align}
    \forall f \in F \ldotp \exists g \in G \ldotp P\parsin{f} & \equiv g & \text{Soundness} \\
    \forall g \in G \ldotp \exists f \in F, P \ldotp P\parsin{f} & \equiv g & \text{Completeness}
  \end{align}
\end{subequations}
\end{proposition}

\chapter{Case study}
\label{chap:case-study}

\EMBRAER provided us with the \simulink model of an Actuator Control System (depicted in \cref{fg:acsBlockDiagrams}).
The failure expression of this system (that is, for each of its constituent components) was also provided by \EMBRAER (we show some of them in \cref{tbl:acsAnnotations}).
In what follows we illustrate our strategy using the Monitor component.

A monitor component is a system commonly used for fault tolerance~\cite{ONB2002,KK2007}.
Initially, the monitor connects the main input (power source on input port 1) with its output.
It observes the value of this input port and compares it to a threshold.
If the value is below the threshold, the monitor disconnects the output from the main input and connects to the secondary input.
We present the \simulink model for this monitor in \cref{fg:blockDiagramMonitorInternals}.

%As we mentioned in~\cref{sec:faults-injection} we translated the monitor to \ac{CSPm} according to our strategy and modified the observer to make \acs{FDR} generate more counter-examples.

Now we show two contributions:
\begin{alineasinline}
  \item using only Boolean\index{Boolean Algebra} operators, thus ignoring ordering, we can obtain the same results obtained in~\cite{DM2012}, and
  \item we represent each of the fault traces reported in~\cite{DM2012} as a term in our proposed algebra of temporal faults.
\end{alineasinline}
Similarly to the association of fault events of \cref{tbl:acsAnnotations} in \cref{sec:faults-injection}, we associate the fault events as:
%
\begin{align*}
a &= \text{LowPower-In1}& A = \var a\\
b &= \text{LowPower-In2}& B = \var b\\
s &= \text{SwitchFailure}& S = \var s
\end{align*}

\section{Structure expressions with Boolean operators}
\index{structure expression}

In this section we show that the same result reported in~\cite{DM2012} in terms of static failure expression (or Boolean\index{Boolean Algebra} propositions) can be obtained with our Boolean\index{Boolean Algebra} operator without using \ac{XBefore}.
For each trace shown in \cref{sec:faults-injection}, a mapping function\footnote{In this work we do not show the mapping function from traces to \ac{algebra} (and the mapping function with \ac{XBefore} in \cref{sec:case-study-xbefore}).
The mapping rules follow the traces: \ac{XBefore} is obtained by the order of occurrence and the absence of an event is the complement ($-$).} ($\tracetobool$) generates the following sets of lists:
%
\begin{align*}
\text{\texttt{TRACE 1: }}&[s,b] \tracetobool S \inter B \inter -A & \setsin{\listsin{s,b},\listsin{b,s}}\\
\text{\texttt{TRACE 2: }}&[b,s] \tracetobool B \inter S \inter -A & \setsin{\listsin{s,b},\listsin{b,s}}\\
\text{\texttt{TRACE 3: }}&[a,b] \tracetobool A \inter B \inter -S & \setsin{\listsin{a,b},\listsin{b,a}}\\
\text{\texttt{TRACE 4: }}&[b,a] \tracetobool B \inter A \inter -S & \setsin{\listsin{a,b},\listsin{b,a}}\\
\text{\texttt{TRACE 5: }}&[a,s] \tracetobool A \inter S \inter -B & \setsin{\listsin{a,s},\listsin{s,a}}\\
\text{\texttt{TRACE 6: }}&[a,s,b] \tracetobool A \inter S \inter B & \setsin{\listsin{a,b,s},\listsin{a,s,b},\ldots,\listsin{s,b,a}}\\
\text{\texttt{TRACE 7: }}&[a,b,s] \tracetobool A \inter B \inter S & \setsin{\listsin{a,b,s},\listsin{a,s,b},\ldots,\listsin{s,b,a}}\\
\text{\texttt{TRACE 8: }}&[b,a,s] \tracetobool B \inter A \inter S & \setsin{\listsin{a,b,s},\listsin{a,s,b},\ldots,\listsin{s,b,a}}\\
\end{align*}

They represent the same faults shown in \cref{sec:faults-injection}.
Note that the negation in the formula is very simple to represent in \ac{algebra} (and \ac{FBA}\index{Boolean Algebra!Free}) because it is just the absence of the generator.

Combining the above sets with unions (ORs), we obtain the following formula set:
%
\[
\left\{ \listsin{s,b}, \listsin{b,s}, \listsin{a,b}, \listsin{b,a}, \listsin{a,s}, \listsin{s,a}, \listsin{a,b,s}, \listsin{a,s,b},\ldots,\listsin{s,b,a} \right\}
\]

If we use Boolean\index{Boolean Algebra} expression reduction instead, it results in the following expression in \ac{algebra} (and in \ac{FBA}\index{Boolean Algebra!Free}):
\[
(A \inter B) \union (S \inter (A \union B))
\]
%
which is equivalent to the set of sets above and is equivalent to \EMBRAER failure expression shown in \cref{tbl:acsAnnotations} (with \ac{AND} gates as $\inter$ and \ac{OR} gates as $\union$).
%
This shows that \ac{algebra} can represent (static) failure expression as in our previous work~\cite{DM2012}.

\section{Structure expressions with \acs*{XBefore}}
\label{sec:case-study-xbefore}
\index{structure expression}

Now, by using \ac{algebra} with the \ac{XBefore} operator and a mapping function ($\tracetoalgebra$), we can capture each possible individual sequences as generated by the work~\cite{DM2012}:
%
\begin{align*}
\text{\texttt{TRACE 1: }}&[s,b] \tracetoalgebra \parsin{\xbefore{S}{B}} \inter -A & \left\{[s,b]\right\}\\
\text{\texttt{TRACE 2: }}&[b,s] \tracetoalgebra \parsin{\xbefore{B}{S}} \inter -A & \left\{[b,s]\right\}\\
\text{\texttt{TRACE 3: }}&[a,b] \tracetoalgebra \parsin{\xbefore{A}{B}} \inter -S & \left\{[a,b]\right\}\\
\text{\texttt{TRACE 4: }}&[b,a] \tracetoalgebra \parsin{\xbefore{B}{A}} \inter -S & \left\{[b,a]\right\}\\
\text{\texttt{TRACE 5: }}&[a,s] \tracetoalgebra \parsin{\xbefore{A}{S}} \inter -B & \left\{[a,s]\right\}\\
\text{\texttt{TRACE 6: }}&[a,s,b] \tracetoalgebra \xbefore{\xbefore{A}{S}}{B} & \left\{[a,s,b]\right\}\\
\text{\texttt{TRACE 7: }}&[a,b,s] \tracetoalgebra \xbefore{\xbefore{A}{B}}{S} & \left\{[a,b,s]\right\}\\
\text{\texttt{TRACE 8: }}&[b,a,s] \tracetoalgebra \xbefore{\xbefore{B}{A}}{S} & \left\{[b,a,s]\right\}
\end{align*}

Using \ac{algebra} and combining each trace with \acp{OR} (unions), we obtain the following set:
%
\[
M_L =
  \left\{
    [a,b],[b,a],[b,s],[s,b],[a,s],
    [a,b,s],[a,s,b],[s,a,b]
  \right\}
\]

From the above traces, we also build \iac{algebra} expression by mapping each trace to an \ac{XBefore} expression, composing all resulting \ac{XBefore} expressions with ORs and reducing them using the \ac{XBefore} laws (\cref{sec:xbefore-laws}), resulting in an expression ($M_A$) that is equivalent to the above set of lists ($M_L \equiv M_A$).
The failure expression of the monitor\footnote{In the final formula, $\parsin{B \inter S \inter -A} \union \parsin{A \inter B \inter -S}$ is equivalent to $\parsin{B \inter \parsin{S \oplus A}}$. There is a typo in our previous work \cite{DM2015}. The expression was written with an OR ($\lor$) but it should an XOR ($\oplus$).} is:
%
\begin{align*}
M_A = & \parsin{\parsin{\xbefore{S}{B}} \inter -A} \union \parsin{\parsin{\xbefore{B}{S}} \inter -A} \union\\
  &\parsin{\parsin{\xbefore{A}{B}} \inter -S} \union \parsin{\parsin{\xbefore{B}{A}} \inter -S} \union\\
  & \parsin{\parsin{\xbefore{A}{S}} \inter -B} \union \\
  & \parsin{\xbefore{\xbefore{A}{S}}{B}} \union \parsin{\xbefore{\xbefore{A}{B}}{S}} \union \parsin{\xbefore{\xbefore{B}{A}}{S}} \\
%%
= &\parsin{B \inter S \inter -A} \union & \text{by \eqref{thm:xbefore-sup-equiv-inf}}\\
  & \parsin{B \inter A \inter -S} \union & \text{by \eqref{thm:xbefore-sup-equiv-inf}}\\
  & \parsin{\parsin{\xbefore{A}{S}} \inter -B} \union\\
  & \parsin{\xbefore{\xbefore{A}{S}}{B}} \union \parsin{\xbefore{\xbefore{A}{B}}{S}} \union \parsin{\xbefore{\xbefore{B}{A}}{S}}\\
%
= &\parsin{B \inter S \inter -A} \union \\
  & \parsin{B \inter A \inter -S} \union \\
  & \parsin{\parsin{\xbefore{A}{S}} \inter -B} \union \\
  & \parsin{\parsin{\xbefore{A}{S}} \inter B} & \text{by \eqref{thm:and_xbefore_equiv_or_xbefore_expanded}}\\
%
= &\parsin{B \inter S \inter -A} \union \parsin{B \inter A \inter -S} \union \parsin{\xbefore{A}{S}} & \text{by absorption}
\end{align*}

The semantics of the above expression is:
\begin{alineasinline}
  \item fault $b$ ($\var{b}$) occurs and fault $a$ ($\var{a}$) or fault $s$ ($\var{s}$) occurs (but not both $a$ and $s$), or
  \item fault $a$ occurs before fault $s$, which is more precise than the expression found without considering order of events.
\end{alineasinline}

\chapter{Conclusion}
\label{sec:conclusion}

In this work we presented a foundational theory to support a more precise representation of fault events as compared to our previous strategy for injecting faults~\cite{DM2012}.
%
The failure expression is essential for system safety assessment because it is used as basic input for building \aclp{FT}~\cite{PMS+2001,JMS+2011,GMS+2010}.
%
%We use \simulink as starting point because it is a standard tool in the control systems industry.
%
Furthermore, we still connect the strategy presented in~\cite{MJG+2010} with the works reported in~\cite{JMS+2011} (functional analysis) and in~\cite{GMS+2010,PMS+2001} (safety assessment) because our new algebra is at least a Boolean\index{Boolean Algebra} algebra.

\begin{sloppypar}
The work reported in~\cite{Walker2009,WP2009,WP2010} tackles simultaneity with ``nearly simultaneous'' events~\cite{EWG2013}.
But we consider instantaneous events, like the work reported in~\cite{MRL2014}, because we assume that simultaneity is probabilistically impossible.
\end{sloppypar}

\section{Status}

In \cref{fig:status-of-thesis} we show:
\begin{alineasinline}
  \item what was done in previous work and is used as input,
  \item what was done in the current work,
  \item what will be done in the next months (see \cref{tbl:tasks-schedule} for tasks schedule), and
  \item what will be done in future work, after the thesis' defence.
\end{alineasinline}
Many of the tasks shown in \cref{tbl:tasks-schedule} already started.
The \namecref{tbl:tasks-schedule} shows the estimated execution of the tasks by year's quarters.
The second quarter of 2016 is from April to June/2016, the third quarter is from July to September/2016, the fourth quarter, from October to December/2016, and we expected to defend the thesis by February/2017.


\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.9]{StrategyOverview-Status}
  \caption{Status of this thesis using the strategy overview (see \cref{fig:strategy-overview})}
  \label{fig:status-of-thesis}
\end{figure}

\begin{table}[htb]
\IBGEtab{%
  \caption{Tasks schedule}%
  \label{tbl:tasks-schedule}%
}{%
  \begin{tabular}{p{10.2cm}cccc}
    \toprule
    Task & 2nd & 3rd & 4th & 1st\\
    \midrule \midrule
    Qualification & $\bullet$ &  &  & \\
    \midrule
    Elaborate a theory for the \ac{activation} & $\bullet$ &  &  & \\
    \midrule
    Elaborate a theory for the acceptance criteria & $\bullet$ &  &  & \\
    \midrule
    Prepare a paper about \ac{activation} and acceptance criteria & $\bullet$ & $\bullet$ &  & \\
    \midrule
    Submit paper about \ac{activation} and acceptance criteria &  & $\bullet$ &  & \\
    \midrule
    Prove soundness and completeness theorems for the \ac{DNF} of \ac{algebra} &  & $\bullet$ & $\bullet$ & \\
    \midrule
    Define the mapping rules from traces to \ac{algebra} &  &  & $\bullet$ & \\
    \midrule
    Demonstrate the relations of \ac{NOT} and \ac{XBefore} and other operators &  &  & $\bullet$ & \\
    \midrule
    Define the conditions that cause non-coherent analysis with \ac{NOT} &  &  & $\bullet$ & \\
    \midrule
    Write the results in the thesis &  & $\bullet$ & $\bullet$ & \\
    \midrule
    Prepare thesis' defence &  &  & $\bullet$ & $\bullet$\\
    \midrule
    Defence &  &  &  & $\bullet$\\
    \bottomrule
  \end{tabular}%
}{%
}
\end{table}

\section{Next steps in this thesis}

The next steps in this thesis are the conclusion of the work-in-progress of the ``Fault Modelling'' and ``Automatic FTA'' blocks in \cref{fig:status-of-thesis}.
An initial version of the theory of the \ac{activation} is done.
The case study shown in this thesis is also modelled in \ac{activation}.
But we need to adapt the failure predicates to \theac{algebra}.
It may require a full refactoring of the theory of \ac{activation}.

We developed a small set of rules for the acceptance criteria verification, but we need to add more sophisticated rules, as for example, to consider phase and latency.
%In both cases, we will update the case studies.

We showed the \ac{DNF} for \ac{algebra}, but we did not demonstrate that every formula can be converted into \ac{DNF}.
The laws shown in this work should be sufficient for this demonstration.
Also, we did not show the mapping rules from traces to \ac{algebra} (with Boolean\index{Boolean Algebra} operators only \ac{AND} with \ac{XBefore}).
The mapping rules follow those for the traces: \ac{XBefore} is obtained by the order of occurrence and the absence of an event is the complement ($-$).

Although we do not use negation (\ac{NOT} operator) with \ac{XBefore} in our case study, it is part of \ac{algebra}, so it could be used.
As future work we will demonstrate the relations of \ac{NOT} and \ac{XBefore}, as we did for \ac{AND} and \ac{OR}.
We will also define laws to avoid the conditions that cause non-coherent analysis~\cite{Oliv2006}.
The issue with negated events comes up when both an event and its negation appear on the same tree.
One very restrictive solution to this issue is applying the \emph{generators independence} laws (\ref{eqs:generators-independence-subseteq-neq-compl}, \ref{eqs:generators-independence-subseteq-compl-neq}) on basic events of a tree, by actually considering a new event $ne$ in place of the negation of another event $e$ (for instance, $\var e$ and $\var ne = -\var e$).
We look forward to obtain a less restrictive law.


\section{Future work, out of the scope of this thesis}

%The distinct lists representation in our algebra does not allow obtaining minimal cut sequences\index{Minimal Cut!Sequences} directly from the formula, similar to \acp{FBA}\index{Boolean Algebra!Free}.
%The sets in \iac{FBA}\index{Boolean Algebra!Free} formula are already the minimal cut sets\index{Minimal Cut!Sets}.
%In our work, \ac{algebra} allows us to find minimal cut sequences\index{Minimal Cut!Sequences} (with XBefore) from the formulas in \ac{DNF} algebraically: each sub-expression is a minimal cut sequence\index{Minimal Cut!Sequences}.

Boolean\index{Boolean Algebra} formulas reduction can be achieved by:
\begin{alineasinline}
  \item application of Boolean laws,
  \item \ac{BDD}\index{Binary Decision Diagrams}, or
  \item \acp{FBA}\index{Boolean Algebra!Free}.
\end{alineasinline}
We used Boolean\index{Boolean Algebra} and \ac{XBefore} laws to reduce \ac{algebra} formulas.
%
The work reported in~\cite{TXD2011,XTD2012} uses Sequential BDDs\index{Binary Decision Diagrams!Sequential} to reduce formulas with order-based operators.
%
We plan to use similar concepts in a future work.

The work reported in~\cite{SAE1996b} states that \acp{DTMC} (\aca{DTMC}) is more appropriate to represent several states than \acp{SFT}.
Considering that \acp{DFT} were conceived as a visual representation of \acap{DTMC}, then we may say that \acp{DFT} can be used to represent several states.
Thus they are suitable to propose the architectural model modifications as shown in \cref{fig:strategy-overview,fig:status-of-thesis}.
The definition and the theory of ``Fault Modelling and Fault Tolerance Patterns'' and the automatic proposal of ``Architectural Model Modifications'' blocks are left as future work.


% References
\postextual
%\begin{references}
  \bibliography{references-jabref}
%\end{references}

% Appendix

%\theappendix
\begin{apendicesenv}
\partapendices

\chapter{Formal proofs in Isabelle/HOL}
\label{app:formal-proofs-isabelle-hol}

In the following we list all theorems and proofs concerning the laws presented in \cref{chap:strategy}.
The complete set of verifiable theory files is available at \algebraurl.
We list only those files created in our work.
Each theorem, proof or corollary is followed by its own proof.

The theory about lists of distinct elements---or simply \emph{distinct lists}---is available in~\cite{HL2016} (we used the 2015 version that is available with \isabellehol).

%\Cref{tbl:laws-theorems-slice} shows a mapping of the equations shown in~\cref{chap:strategy} and theorem names in the \isabellehol code presented in this \namecref{app:formal-proofs-isabelle-hol}.

%\begin{table}[htb]
%  \caption{Laws and theorems}%
%  \label{tbl:laws-theorems-slice}%
%  \begin{longtable}{p{8cm}ll}
%    \hline
%    Description & Def. or Law & Theorem name \\
%    \hline \hline
%    \endfirsthead
%    \multicolumn{3}{c}%
%    {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
%    \hline
%    Description & Def. or Law & Theorem name \\
%    \hline
%    \endhead
%    \hline \multicolumn{3}{r}{\textit{Continued on next page}} \\
%    \endfoot
%    \hline
%    \endlastfoot
%    & \Cref{def:xbefore-append} & \\
%    \hline
    %Definition of slice in distinct lists & \Cref{def:slice} & instantiation dlist, $l\dagger i..f$\\
%    \hline
%    Definition of slice-right & \Cref{def:slice-right} & slice\_right\\
%    \hline
%    Definition of slice-left & \Cref{def:slice-left} & slice\_left\\
%    \hline
    %Relation of slice and concatenation (appending) & \Cref{law:slice-append} &  slice\_append\\
%    \hline
    %Definition of \ac{XBefore} using slice & \Cref{def:xbefore-slice} &  dlist\_xbefore\_append\\
%    \hline
%    Variable definition & \Cref{def:var} & \\
%    \hline
%    & \Cref{def:algebraset-var} & \\
%    \hline
%    & \Cref{def:algebraset-compl} & \\
%    \hline
%    & \Cref{def:algebraset-inf} & \\
%    \hline
%    & \Cref{def:algebraset-xbefore} & \\
%    \hline
%    & \Cref{def:algebraset-true} & \\
%    \hline
%    & \Cref{def:algebraset-false} & \\
%    \hline
%    & \Cref{def:algebraset-sup} & \\
%    \hline
%    & \Cref{eqs:generators-independence} & \\
%    \hline
%    & \Cref{def:tempo1} & \\
%    \hline
%    & \Cref{def:tempo2} & \\
%    \hline
%    & \Cref{def:tempo3} & \\
%    \hline
%    & \Cref{def:tempo4} & \\
%    \hline
%    & \Cref{law:var-tempo} & \\
%    \hline
%    & \Cref{law:old-xbefore} & \\
%    \hline
%    & \Cref{law:tempo1-inter} & \\
%    \hline
%    & \Cref{law:tempo3-inter} & \\
%    \hline
%    & \Cref{law:tempo2-union} & \\
%    \hline
%    & \Cref{law:tempo4-union} & \\
%    \hline
%    & \Cref{law:independent-events} & \\
%    \hline
%    & \Cref{thm:xbefore-of-false-1} & \\
%    \hline
%    & \Cref{thm:xbefore-of-false-2} & \\
%    \hline
%    & \Cref{thm:xbefore-sup-absorb-1} & \\
%    \hline
%    & \Cref{thm:xbefore-sup-absorb-2} & \\
%    \hline
%    & \Cref{thm:xbefore-not-idempotent} & \\
%    \hline
%    & \Cref{thm:xbefore-associativity} & \\
%    \hline
%    & \Cref{thm:xbefore-inf-equiv-bot} & \\
%    \hline
%    & \Cref{thm:xbefore-sup-equiv-inf} & \\
%    \hline
%    & \Cref{thm:xbefore-sup-1} & \\
%    \hline
%    & \Cref{thm:xbefore-sup-2} & \\
%    \hline
%    & \Cref{thm:xbefore-inf-1} & \\
%    \hline
%    & \Cref{thm:xbefore-inf-2} & \\
%    \hline
%    & \Cref{thm:and_xbefore_equiv_or_xbefore} & \\
%    \hline
%    & \Cref{thm:and_xbefore_equiv_or_xbefore_expanded} & \\
%    \hline
%  \end{longtable}%
%\end{table}

This \namecref{app:formal-proofs-isabelle-hol} is organized as follows:
\begin{alineasinline}
  \item \cref{sec:theory-sliceable} presents the base lemmas and theorems for sliceable types;
  \item sublists (sliceable distinct lists) are shown in \cref{sec:theory-sliceable-dlist};
  \item algebraic definitions and laws of the \ac{algebra} are shown in \cref{sec:theory-algebra}, and
  \item proofs using the denotational semantics of sets of distinct lists are shown in \cref{sec:theory-algebra-dlist}.
\end{alineasinline}

\input{algebra/output/document/Sliceable}
\input{algebra/output/document/Sliceable_dlist}
\input{algebra/output/document/Temporal_Faults_Algebra}
\input{algebra/output/document/Temporal_Faults_Algebra_dlist}

\end{apendicesenv}

\phantompart
\printindex
\adnote{Verify indexes again (search again for words already in the index)}
\adnote{Add more indexes}
\adnote{Run ``makeindex main'' on this directory}
\cleardoublepage

%\listoftodos[Notes]
\end{document}
