-------------------------------------------------------------------------------
--  FormalLab                                                                --
--  Generated by Simulink 2 CSP Translator                                   --
-------------------------------------------------------------------------------

include "BlockLibrary.csp"


-- {- SAMPLING -}
-- FUNDAMENTAL_SAMPLE_TIME = 0 -- seconds
FUNDAMENTAL_SAMPLE_TIME = 0

STEP_SIZE = 0


MAX_SAMPLE_STEP = 1


-------------------------------------------------------------------------------
-- IDENTIFIERS
-- (Generated using a breadth first traversal of Simulink hierarchy)
-------------------------------------------------------------------------------


{-
   Library codes:
   L01 ~> Subsystems from Level 1
   L02 ~> Subsystems from Level 2
 -}
datatype LibraryId = L01 | L02


{-
   Subsystem codes:
   N01 ~> TwoBatteriesMonitor
   N02 ~> PowerSupply
   N03 ~> Battery
   N04 ~> Monitor
-}
datatype Namespace = N01 | N02 | N03 | N04


datatype BlockId = N01_PowerSupply | N01_Scope
                 | N02_Battery1 | N02_Battery2 | N02_Monitor | N02_PSOut
                 | N03_Step | N03_BatOut1
                 | N04_MonIn1 | N04_MonIn2 | N04_MonOut 
                 | N04_RelationalOperator | N04_Switch | N04_Threshold


channel cout, sig: ComponentType.BlockId.Int.T


-------------------------------------------------------------------------------
-- Abstracted values
-------------------------------------------------------------------------------

timeBattery1 = 3
timeBattery2 = 3
Vbattery1 = I.5
Vbattery2 = I.5
Vthreshold = I.3
--Tbattery1 = { Vbattery1 }
--Tbattery2 = { Vbattery2 }
Tbattery1 = { OMISSION, Vbattery1 }
Tbattery2 = { OMISSION, Vbattery2 }
Tthreshold = { Vthreshold }
--Tmonitor = union(union(Tbattery1, Tbattery2), Tthreshold)
--Tmonitor = { I.0, I.1, I.2, I.3, I.4, I.5 }
Tmonitor = { OMISSION, I.0, I.3, I.4, I.5 }

-------------------------------------------------------------------------------
-- Library L02 - Level 02 subsystems
-------------------------------------------------------------------------------

L02_S_Battery(chargedTime, voltage) = 
    let Step = 
            B_Step(chargedTime, voltage, I.0) 
            [[ out.1.xD <- cout.HW.N03_Step.1.xD | xD<-{ I.0, voltage } ]]
        Sig_N03_Step_1 = 
            Signal(cout.HW.N03_Step.1, sig.HW.N03_Step.1, { I.0, voltage })
        BatOut1 = 
            B_Outport(1, { I.0, voltage })(sig.HW.N03_Step.1)(Sampler__CONTINUOUS)            
        CS = 
        { 
            (Step, 	
                {| tick, cout.HW.N03_Step.1.xD | xD<-{ I.0, voltage } |}),
            (Sig_N03_Step_1,	
                {| tick, cout.HW.N03_Step.1.xD, sig.HW.N03_Step.1.xD 
                   | xD<-{ I.0, voltage } |}),
            (BatOut1,	
                {| tick, sig.HW.N03_Step.1.xD, out.1.xD 
                   | xD<-{ I.0, voltage } |}) 
        }
    within
        B_Subsystem(CS)

L02_S_Monitor(threshold) =
    let 
        MonIn1 = 
            B_Inport(1, Tbattery1)(cout.HW.N04_MonIn1.1)(Sampler__CONTINUOUS)
        Sig_N04_MonIn1_1 = 
            Signal(cout.HW.N04_MonIn1.1, sig.HW.N04_MonIn1.1, Tbattery1)
        MonIn2 = 
            B_Inport(2, Tbattery2)(cout.HW.N04_MonIn2.1)(Sampler__CONTINUOUS)
        Sig_N04_MonIn2_1 = 
            Signal(cout.HW.N04_MonIn2.1, sig.HW.N04_MonIn2.1, Tbattery2)
        Threshold = 
            B_Constant(threshold) 
            [[ out.1.xI <- cout.SW.N04_Threshold.1.xI | xI<-Tthreshold ]]
        Sig_N04_Threshold_1 = 
            Signal(cout.SW.N04_Threshold.1, sig.SW.N04_Threshold.1, Tthreshold)
        RelationalOperator = 
            B_GTE(<Tbattery1,Tthreshold>)(Sampler__CONTINUOUS) 
                [[ in.1.x1 <- sig.HW.N04_MonIn1.1.x1,
                   in.2.x2 <- sig.SW.N04_Threshold.1.x2,
                   out.1.xB <- cout.SW.N04_RelationalOperator.1.xB
                   | x1<-Tbattery1, x2<-Tthreshold, xB<-Tboolean ]]
        Sig_N04_RelationalOperator_1 = 
            Signal(cout.SW.N04_RelationalOperator.1, 
                   sig.SW.N04_RelationalOperator.1, Tboolean)
        Switch = 
            B_Switch__NZ(B)(<Tbattery1,Tboolean,Tbattery2>)(Sampler__CONTINUOUS) 
                [[ in.1.xB1 <- sig.HW.N04_MonIn1.1.xB1,
                   in.2.xB <- sig.SW.N04_RelationalOperator.1.xB,
                   in.3.xB2 <- sig.HW.N04_MonIn2.1.xB2,
                   out.1.xI <- cout.HW.N04_Switch.1.xI
                   | xB1<-Tbattery1, xB2<-Tbattery2, xB<-Tboolean, 
                     xI<-Tmonitor ]]
        Sig_N04_Switch_1 = 
            Signal(cout.HW.N04_Switch.1, sig.HW.N04_Switch.1, Tmonitor)
        MonOut = 
            B_Outport(1, Tmonitor)(sig.HW.N04_Switch.1)(Sampler__CONTINUOUS)
        CS = 
        { 
            (MonIn1,				        
                {| tick, in.1.xI, cout.HW.N04_MonIn1.1.xI | xI<-Tbattery1 |}),
            (Sig_N04_MonIn1_1,	            
                {| tick, cout.HW.N04_MonIn1.1.xI, sig.HW.N04_MonIn1.1.xI 
                   | xI<-Tbattery1 |}),
            (MonIn2,				        
                {| tick, in.2.xI, cout.HW.N04_MonIn2.1.xI | xI<-Tbattery2 |}),
            (Sig_N04_MonIn2_1,	            
                {| tick, cout.HW.N04_MonIn2.1.xI, sig.HW.N04_MonIn2.1.xI 
                   | xI<-Tbattery2 |}),
            (Threshold,			        
                {| tick, cout.SW.N04_Threshold.1.xI | xI<-Tthreshold |}),
            (Sig_N04_Threshold_1,	        
                {| tick, cout.SW.N04_Threshold.1.xI, sig.SW.N04_Threshold.1.xI 
                   | xI<-Tthreshold |}),
            (RelationalOperator,	        
                {| tick, sig.HW.N04_MonIn1.1.x1, sig.SW.N04_Threshold.1.x2, 
                   cout.SW.N04_RelationalOperator.1.xB
                   | x1<-Tbattery1, x2<-Tthreshold, xB<-Tboolean |}),
            (Sig_N04_RelationalOperator_1,	
                {| tick, cout.SW.N04_RelationalOperator.1.xB, 
                   sig.SW.N04_RelationalOperator.1.xB 
                   | xB<-Tboolean |}),
            (Switch,				        
                {| tick, sig.HW.N04_MonIn1.1.xB1, 
                   sig.SW.N04_RelationalOperator.1.xB,
                   sig.HW.N04_MonIn2.1.xB2, cout.HW.N04_Switch.1.xI
                   | xB1<-Tbattery1, xB2<-Tbattery2, 
                     xB<-Tboolean, xI<-Tmonitor |}),
            (Sig_N04_Switch_1,	            
                {| tick, cout.HW.N04_Switch.1.xI, sig.HW.N04_Switch.1.xI 
                   | xI<-Tmonitor |}),
            (MonOut,				        
                {| tick, sig.HW.N04_Switch.1.xI, out.1.xI
                   | xI<-Tmonitor |}) 
        }
    within
      B_Subsystem(CS)
      
      
-------------------------------------------------------------------------------
-- Library L02 - Observable component instances
-------------------------------------------------------------------------------

W_I_Battery1 = L02_S_Battery(timeBattery1, Vbattery1) 
               [[ out.1.xD <- cout.HW.N02_Battery1.1.xD | xD<-Tbattery1 ]]
W_I_Battery2 = L02_S_Battery(timeBattery2, Vbattery2) 
               [[ out.1.xD <- cout.HW.N02_Battery2.1.xD | xD<-Tbattery2 ]]
W_I_Monitor = L02_S_Monitor(I.3) 
               [[ in.1.xB1 <- sig.HW.N02_Battery1.1.xB1,
                  in.2.xB2 <- sig.HW.N02_Battery2.1.xB2,
                  out.1.xM <- cout.HW.N02_Monitor.1.xM
                  | xB1<-Tbattery1, xB2<-Tbattery2, xM<-Tmonitor ]]


-------------------------------------------------------------------------------
-- Library L01 - Level 01 subsystems
-------------------------------------------------------------------------------

L01_S_PowerSupply = 
    let 
        I_Battery1 = 
            L02_S_Battery(timeBattery1, Vbattery1) 
            [[ out.1.xD <- cout.HW.N02_Battery1.1.xD | xD<-Tbattery1 ]]
        Sig_N02_Battery1_1 = 
            Signal(cout.HW.N02_Battery1.1, sig.HW.N02_Battery1.1, Tbattery1)
        I_Battery2 = 
            L02_S_Battery(timeBattery2, Vbattery2) 
            [[ out.1.xD <- cout.HW.N02_Battery2.1.xD | xD<-Tbattery2 ]]
        Sig_N02_Battery2_1 = 
            Signal(cout.HW.N02_Battery2.1, sig.HW.N02_Battery2.1, Tbattery2)
        I_Monitor = 
            L02_S_Monitor(I.3) 
            [[ in.1.xB1 <- sig.HW.N02_Battery1.1.xB1,
               in.2.xB2 <- sig.HW.N02_Battery2.1.xB2,
               out.1.xM <- cout.HW.N02_Monitor.1.xM
               | xB1<-Tbattery1, xB2<-Tbattery2, xM<-Tmonitor ]]
        Sig_N02_Monitor_1 = 
            Signal(cout.HW.N02_Monitor.1, sig.HW.N02_Monitor.1, Tmonitor)
        PSOut = 
            B_Outport(1, Tmonitor)(sig.HW.N02_Monitor.1)(Sampler__CONTINUOUS)
        CS = 
        { 
            (I_Battery1, 	        
                {| tick, cout.HW.N02_Battery1.1.xD | xD<-Tbattery1 |}),
            (Sig_N02_Battery1_1,   
                {| tick, cout.HW.N02_Battery1.1.xD, sig.HW.N02_Battery1.1.xD 
                   | xD<-Tbattery1 |}),
            (I_Battery2, 	        
                {| tick, cout.HW.N02_Battery2.1.xD | xD<-Tbattery2 |}),
            (Sig_N02_Battery2_1,   
                {| tick, cout.HW.N02_Battery2.1.xD, sig.HW.N02_Battery2.1.xD 
                   | xD<-Tbattery2 |}),
            (I_Monitor, 	        
                {| tick, sig.HW.N02_Battery1.1.xB1, sig.HW.N02_Battery2.1.xB2,
                   cout.HW.N02_Monitor.1.xM 
                   | xB1<-Tbattery1, xB2<-Tbattery2, xM<-Tmonitor |}),
            (Sig_N02_Monitor_1,    
                {| tick, cout.HW.N02_Monitor.1.xD, sig.HW.N02_Monitor.1.xD 
                   | xD<-Tmonitor |}),
            (PSOut,		        
                {| tick, sig.HW.N02_Monitor.1.xI, out.1.xI | xI<-Tmonitor |}) 
        }
    within
        B_Subsystem(CS)

-------------------------------------------------------------------------------
-- Library L01 - Observable component instances
-------------------------------------------------------------------------------

W_I_PowerSupply = L01_S_PowerSupply 
                  [[ out.1.xD <- cout.HW.N01_PowerSupply.1.xD | xD<-Tmonitor ]]      



-------------------------------------------------------------------------------
-- SIMULINK MODEL
-------------------------------------------------------------------------------

M_TwoBatteriesMonitor =
    let 
        I_PowerSupply = 
            L01_S_PowerSupply 
            [[ out.1.xD <- cout.HW.N01_PowerSupply.1.xD | xD<-Tmonitor ]]
        Sig_N01_PowerSupply_1 = 
            Signal(cout.HW.N01_PowerSupply.1, 
                   sig.HW.N01_PowerSupply.1, Tmonitor)
        Scope = 
            B_Scope(Tmonitor) 
            [[ in.1.xD <- sig.HW.N01_PowerSupply.1.xD | xD<-Tmonitor ]]
        CS = 
        { 
            (I_PowerSupply,	        
                {| tick, cout.HW.N01_PowerSupply.1.xD | xD<-Tmonitor |}),
            (Sig_N01_PowerSupply_1,    
                {| tick, cout.HW.N01_PowerSupply.1.xD, 
                   sig.HW.N01_PowerSupply.1.xD | xD<-Tmonitor |}),
            (Scope,			        
                {| tick, sig.HW.N01_PowerSupply.1.xD, scope.1.xD 
                   | xD<-Tmonitor |}) 
        }
    within
      B_System(CS)

