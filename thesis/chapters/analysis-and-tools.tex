\chapter{Analysis and tools}
\label{chap:analysis}

Structure expressions\index{structure expression} are used to analyse \aclp{FT}.
In general, a structure expression\index{structure expression} comes from gates semantics and basic events.
Basic events become variables and gates become operators (a gate may become one or more operators).
In \cref{sec:fault-trees} we explain \acp{SFT}, \acp{TFT}, \acp{DFT}, and their respective structure expressions\index{structure expression}.

\Acp{FBA} and \acp{BDD}\index{Binary Decision Diagrams} are the basis to analyse structure expressions.
Also, we were inspired by \ac{FBA} concepts to create our \acl{algebra} (\cref{chap:algebra}).
We explain \acp{BDD}\index{Binary Decision Diagrams} and derived techniques in \cref{sec:structure-expression-analysis}, and \acp{FBA} in \cref{sec:fba}.

The use of the Boolean\index{Boolean Algebra} operator \emph{NOT}:
\begin{alineasinline}
  \item can be misleading, generating non-coherent \aclp{FT}~\cite{Oliv2006}, or
  \item can be essential in practical use~\cite{Andrews2001}.
\end{alineasinline}
We discuss such cases in \cref{sec:not-operator}.

In \cref{sec:probabilistic-analysis-non-coherent-tree} we show the probability calculation of \iac{FT} with an explicit \ac{NOT} operator.

To reuse a nominal model to analyse faults we need fault injection.
In \cref{sec:faults-injection} we explain how we used \simulink and \ac{CSPm} to inject faults and obtain failure expressions from a nominal model.

Finally, in \cref{sec:isabelle} we present basic usage of Isabelle/HOL\index{Isabelle/HOL} and \ac{Isar}, which were essential to carry out the proofs presented in this thesis.

\section[Fault Tree Analysis and structure expressions]{\Acl*{FTA} and structure expressions}
\label{sec:fault-trees}

\Ac{FTA} was introduced in the \FThandbook~\cite{VGR+1981} with \aclp{SFT}.
\Ac{FTA} is a deductive method that investigates what are the possible causes of an unwanted event.
The method starts with the top-level event as the unwanted event and the combination of lower-level events that can cause it.
Events are combined using gates, and each gate has a well defined semantics.
It continues until basic (atomic) events are reached.
\Iac{SFT} represents, in a single view---very often considering faults outside of the boundaries of a system---different states in which a particular failure (top event) is active in a system.
The most traditional gates are \ac{AND} and \ac{OR}, which are equivalent to Boolean\index{Boolean Algebra} operators.
These gates are also called coherent gates\index{coherent gates} because they construct coherent trees (see \cref{sec:not-operator} about the use of \ac{NOT} gates).
%A Boolean expression represents the structure of \iac{SFT}.
%Qualitative and quantitative analysis are evaluated on these Boolean expressions, that are referred to as \emph{structure expressions}.
The \FThandbook shows other gates as, for example, the \ac{PAND} gate, but the \ac{FTA} with these gates is not well defined.
\Acg{SFT} gates and analysis are detailed in \cref{sec:static-fault-trees}.

\Acp{TFT} were created aiming at fully implementing the \FThandbook.
The \ac{PAND} gate was first defined for \acp{SFT}, but its analysis was left open in the handbook.
The semantics (and analysis) of \acp{TFT} is defined in terms of a denotational semantics based on \emph{sequence values}\index{Temporal Fault Tree!sequence value} to express ordering of events, thus tackling \acg{PAND} order.
We explain \acp{TFT} and the sequence values in \cref{sec:temporal-fault-trees}.

\begin{sloppypar}
With component and system design evolution, \acp{DFT} were created to tackle dynamic behaviour: fault-tolerance-related components (\ac{CSp}), functional dependency (\ac{FDEP}), and analysis of particular order of occurrence of faults (\ac{SEQ}).
\Acg{SFT} gates (as \ac{AND} and \ac{OR}) are part of \acp{DFT} as well.
We explain them and \acg{DFT} analysis in \cref{sec:dynamic-fault-trees}.
\end{sloppypar}

The structure of \iac{FT} (or the structure of \iac{MCS}, explained further) is represented with a formula.
The variables represent occurrences of basic events.
Unary and binary relation symbols capture the semantics of gates.
A formula with these characteristics is called \emph{structure expression}\index{structure expression} or \emph{structure function}\index{structure expression!function} (as the expression depends on the variables).
The semantics of a structure expression is that the top-level event occurs if some combination of basic events occur.

\begin{sloppypar}
The results obtained from the \acp{FTA} are shown in the \FThandbook.
We summarize them as:
%
\begin{alineas}
  \item Qualitative
  \begin{description}
    \item[\Acp{MCS}\index{Fault Tree Analysis!minimal cut set}:]
    Minimal combinations of component failures causing system failure.
    They are obtained from the reduction of structure expressions to a normal form.
    For example, in \acp{SFT}, structure expressions\index{structure expression} are reduced to \ac{DNF}.
    Each term in a reduced \ac{DNF} is \iac{MCS}.
    \item[Importance\index{Fault Tree Analysis!qualitative importance}:]
    Qualitative rankings on contributions to system failure.
    A single fault causing a catastrophic failure is usually unacceptable.
    Ranking \acp{MCS} is the same as ordering them in ascending order of their size (smaller first).
  \end{description}
  \item Quantitative
  \begin{description}
    \item[Numerical probabilities\index{Fault Tree Analysis!numerical probability}:]
    Probabilities of system and \ac{MCS} failures.
    A system failure probability is obtained by assigning probabilities to basic events and then calculating it according to the gate semantics.
    \Ac{MCS} failure probability is the calculation of the probability of the occurrence of \emph{all} basic events of a specific \ac{MCS}.
    %%%%%
    \item[Importance\index{Fault Tree Analysis!quantitative importance}:]
    Quantitative rankings on contributions to system failure.
    Ranking \acp{MCS} is the same as ordering them in descending order of some unreliability formula (higher first).
    These formulas used to quantify importance vary.
    The most common are:
    \begin{alineasinline}
      \item system unavailability, and
      \item system failure occurrence rate.
    \end{alineasinline}
    \item[Sensitivity evaluation\index{Fault Tree Analysis!sensitivity evaluation}:]
    Modifying characteristics of components and evaluate their impact.
    For a particular event in a tree, a higher and a lower failure probability value are assigned.
    If the system unavailability is not changed, then such an event is not important---the system is not sensitive to such an event.
  \end{description}\end{alineas}
\end{sloppypar}

As stated in~\cite{SVD+2002}, there are other uses of \ac{FTA}.
One of great importance is using it to minimize and optimize resources, which has been object of study in \ac{hiphops}~\cite{APS+2011}.
Through importance measures\index{importance measure}, \ac{FTA} not only identifies what is important but also what is unimportant.
This removes components without impacting the overall failure probability, which is related to the quantitative importance\index{Fault Tree Analysis!quantitative importance} and sensitivity evaluation\index{Fault Tree Analysis!sensitivity evaluation}.

\begin{sloppypar}
In important stages of critical systems, \ac{FTA} plays an essential role.
At least three dependability means\index{Dependability!means to attain} can be achieved by using \acp{FT}:
%
\begin{description}
  \item[Removal.]
  \Iac{FTA} calculates the probability of failure of a subsystem.
   If such a probability is higher than a certain maximum reference, such a subsystem should be removed or left to be incorporated in combination with a more reliable component.
  \item[Tolerance.]
  \Iac{FTA} indicates whether a single fault---or fewer combinations than expected---could lead to a catastrophic failure.
  In this case, a system should have replication, or stages of fault detection and error handling.
  Also, the probability of failure of the chosen fault tolerance method can be evaluated.
\end{description}
\end{sloppypar}

In \cref{sec:static-fault-trees,sec:temporal-fault-trees,sec:dynamic-fault-trees} we briefly show \ac{FT} symbology and means to analyse \acp{FT}.
We detail its structure expression extraction because they are a common means to perform both qualitative and quantitative analysis.

\subsection{\Aclp*{SFT}}
\label{sec:static-fault-trees}

\Ac{SFT} gates and structure expressions were used as basis for other kinds of trees, as in \acp{TFT} and \acp{DFT}.
We explain their symbology and semantics in this \lcnamecref{sec:static-fault-trees}.

The \FThandbook shows traditional symbols for gates and events.
Basic events are usually drawn as a rectangle (for the text) and a circle below it, as shown in \cref{fig:sft-example-ald-software}, or as a circle with the text of the basic event, as shown in \cref{fig:sft-example-traditional-gates}.
Top-level and intermediary events are drawn as a rectangle (for the text) and a gate below it, as shown in \cref{fig:sft-example-traditional-gates,fig:sft-example-ald-software}.
When \iac{FT} becomes too large, transfer in and out symbols can be used.
They are usually drawn as triangles with a letter or a number.
\Cref{fig:sft-example-traditional-gates} depicts traditional gates as specified in the \FThandbook, and \cref{fig:sft-example-ald-software} shows \iac{FT} using \theftanalyser{}---a free commercial tool.
In this work, to keep a visual identity with other \acp{FT}, and to avoid symbol confusion, we use gate symbols as shown in~\cref{fig:sft-gates}.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[1]{sft-example-ald-software}
  \caption{\Ac{SFT} symbols using a free commercial tool}
  \label{fig:sft-example-ald-software}
\end{figure}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.9]{sft-symbols-ft-handbook}
  \caption{\acs{SFT} symbols as in the \FThandbook}
  \label{fig:sft-example-traditional-gates}
\end{figure}

\begin{figure}[htb]
  \centering
  \subcaptionbox{Basic event\label{fig:sft-basic-event}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.2]{ft-symbol-basic-event}
    }%
  \subcaptionbox{Intermediary event\label{fig:sft-intermediary-event}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.2]{ft-symbol-top-or-intermediary}
    }
  \subcaptionbox{\ac{AND} gate\label{fig:sft-and-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-and-gate}
    }
  \subcaptionbox{\ac{OR} gate\label{fig:sft-or-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-or-gate}
    }
  \subcaptionbox{\ac{NOT} gate\label{fig:sft-not-gate}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.1]{ft-symbol-not-gate}
    }
  \subcaptionbox{Transfer symbol\label{fig:sft-transfer}}
    [.25\textwidth]{%
      \includegraphicsaspectratio[0.15]{ft-symbol-transfer}
    }
  \caption{\ac{SFT} gates}
  \label{fig:sft-gates}
\end{figure}

Structure expressions\index{structure expression} in \ac{FTA} are defined in terms of set theory, using symbols for fault events occurrence.
%, using what is called of generative sets.
If a fault event symbol is in a set, then it means that this fault has occurred.
A set is a combination of fault events that causes the occurrence of the top-level event of a tree.
A structure expression\index{structure expression} of a tree is denoted by a set of sets of fault event combinations.
The \ac{OR} gate becomes the union operator between sets and the \ac{AND} gate, the intersection.
For example, if a system contains fault events \emph{a}, \emph{b}, and \emph{c}, \aclp{FT} for this system contain at most all these three events.
%The occurrence of a single event $a$ may be associated with the occurrence (or not) of the other events in any order.
The occurrence of the fault event $a$ is denoted by a set of sets $A$, which contains the following sets:
%
\begin{alineas}
  \item\label{item:fta-only-a-occurs} $\left\{a\right\}$: only \emph{a} occurs;
  \item\label{item:fta-a-and-b-occur} $\left\{a,b\right\}$: \emph{a} and \emph{b} occur in any order;
  \item\label{item:fta-a-and-c-occur} $\left\{a,c\right\}$: \emph{a} and \emph{c} occur in any order;
  \item\label{item:fta-all-occur} $\left\{a,b,c\right\}$: all three events occur in any order.
\end{alineas}
All sets of $A$ contain the fault event $a$.
Similarly, the set of sets $B$---which represents the occurrence of $b$---contains all sets that contain the fault event $b$ (it includes the set $\setsin{a,b,c}$, for example).
%
%Fault event \emph{a} occurs in all possibilities.
%As these are sets, they represent combinations and not permutations.
%Combination $\left\{a,b,c\right\}$ represents the same as $\left\{b,a,c\right\}$, $\left\{c,b,a\right\}$, etc.
%Let the set that contains these sets be $A$.
%Similarly, let $B$ be the set of sets that contain the fault event $b$.

The \acl{FT} in \cref{fig:ex-fault-tree1} contains only two events and the resulting structure expression\index{structure expression} for this \ac{FT} is the expression $A \inter B$ ($TOP$), where $A$ and $B$ are the sets of sets that contain $a$ and $b$, respectively.
The resulting combinations for $TOP$ are $\left\{a,b\right\}$ and $\left\{a,b,c\right\}$ (fault events \emph{a} and \emph{b} occur in all possibilities).

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.45]{ex-fault-tree1}
  \caption{Very simple example of a \acl{FT}}
  \label{fig:ex-fault-tree1}
\end{figure}

After obtaining structure expressions\index{structure expression}, the next step is to reduce the expressions to a normal form to obtain the \emph{\acp{MCS}}\index{Minimal Cut!Sets}, which are the sets that contain the minimum and sufficient events to activate the top-level failure.
%That is, \acp{MCS}\index{Minimal Cut!Sets} are the smallest sets of fault event that, if all occur, cause the top-level failure to occur.
Probabilistic analysis is then performed on these events to obtain the overall probability of occurrence of the top-level event.
The \FThandbook shows an algorithm based on Shannon's method\index{Binary Decision Diagrams!Shannon's method} to reduce structure expressions\index{structure expression} to obtain minimal cut sets\index{Minimal Cut!Sets}.
%BDDs are essentially the diagrams of Shannon's method.
The Boolean\index{Boolean Algebra} expression of the tree shown in \cref{fig:ex-fault-tree1} is $TOP = A \wedge B$.
A technique called \ac{BDD}\index{Binary Decision Diagrams}---which derives from Shannon's method\index{Binary Decision Diagrams!Shannon's method}---is explained in \cref{sec:bdd}.

\subsection{\Aclp*{TFT}}
\label{sec:temporal-fault-trees}

There are at least two versions of \acp{TFT}.
One is described in~\cite{Palshikar2002} and uses a more traditional style of temporal logic (a variation of \ac{LTL}).
The other version is called \pandora and is the one we refer to in what follows.

\Acp{TFT} express ordering of events by directly focusing on ordering relationships rather than different states of a system. Basically they extend \acg{SFT} \ac{PAND} gates, allowing analysis of \ac{FT} with such gates.
It is simpler to express than \ac{DFT}, but lacks the fault-tolerance-related gate of \acp{DFT} (which we show in \cref{sec:dynamic-fault-trees}).

\begin{sloppypar}
Structure expressions\index{structure expression} are also present in \acp{TFT}~\cite{WP2009,Walker2009,WP2010}, through the \pandora methodology.
These expressions use the \ac{SFT} operators \ac{OR} and \ac{AND}, and three new operators\footnote{In formulas, the following symbols are used to represent the operators, respectively: ``$<$'', ``$|$'', and ``$\&$''} related to events ordering: \acf{PAND}, \acf{POR}, and \acf{SAND}.
The semantics of the \ac{PAND} in \acp{TFT} is similar to the semantics of the \ac{PAND} described in the \FThandbook.
To avoid ambiguous expressions, the semantics in \acp{TFT} is stated in terms of natural numbers, using a \emph{sequence value} function.
For every possible combination of events ordering, it assigns a sequence value to each fault event.
For example, if event A occurs before event B, then the sequence value of A is lower than the sequence value of B, and one formula to express this is $A \pand B$.
\end{sloppypar}

An invariant on sequence values is that there are no gaps for assigned values.
For example, if faults A and B occur at the same time and there are only these two events, then they should both be assigned value $1$.
On the other hand, if A occurs before B, then the assigned values are 1 and 2, respectively.
The possible values increase with the number of variables to express the cases that all events occur in different times.
For example, A occurs before B, and B occurs before C. 
In this case, the assigned values are 1, 2, and 3, respectively.
Value zero means that the event is not active on the combination.
Similar to Boolean's\index{Boolean Algebra} truth tables, the \pandora methodology defines \acp{TTT}.
They represent formula values for every combination of events.
\Cref{tbl:tft-operators} shows the \ac{TTT} of all \ac{TFT} operators according to the semantics described in terms of a sequence value function $S$ as follows:
%
\begin{subequations}
  \begin{align}
    S\parsin{A \land B} &=
    \begin{cases}
      \max \parsin{S\parsin{A}, S\parsin{B}} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0\\
      0 &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \lor B} &=
    \begin{cases}
      \min \parsin{S\parsin{A}, S\parsin{B}} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0\\
      \max \parsin{S\parsin{A}, S\parsin{B}}, &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \pand B} &=
    \begin{cases}
      S\parsin{B} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0 \land S \parsin{A} < S \parsin{B}\\
      0 &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \por B} &=
    \begin{cases}
      S\parsin{A} &\quad \text{if } S \parsin{A} < S \parsin{B} \lor S \parsin{B} = 0\\
      0 &\quad\text{otherwise}\\
    \end{cases}\\
%
    S\parsin{A \sand B} &=
    \begin{cases}
      S\parsin{A} &\quad \text{if }S \parsin{A} > 0 \land S \parsin{B} > 0 \land S \parsin{A} = S \parsin{B}\\
      0 &\quad\text{otherwise}\\
    \end{cases}
  \end{align}
\end{subequations}
%
\Cref{fig:tft-symbols} shows \ac{TFT}-specific symbols used in this work.
To illustrate \acp{TFT}, for the formula $\parsin{A \pand C} \lor \parsin{A \land B}$, we show:
\begin{alineasinline}
  \item the \ac{TFT} in \cref{fig:tft-small-example}, and
  \item its corresponding \ac{TTT} in \cref{tbl:ttt-small-example} (the column `\#' indicates the \ac{MCSeq} number).
\end{alineasinline}

\begin{table}
% table caption is above the table
\caption{\acs{TTT} of \acsg*{TFT} operators and sequence value numbers}
\label{tbl:tft-operators}
% For LaTeX tables use
\centering
\begin{tabular}{ccccccc}
\hline\noalign{\smallskip}
A & B & \ac{AND} & \ac{OR} & \ac{PAND} & \ac{POR} & \ac{SAND}  \\
\noalign{\smallskip}\hline\noalign{\smallskip}
0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 1 & 0 & 0 & 0\\
1 & 0 & 0 & 1 & 0 & 1 & 0\\
1 & 1 & 1 & 1 & 0 & 0 & 1\\
1 & 2 & 2 & 1 & 2 & 1 & 0\\
2 & 1 & 2 & 1 & 0 & 0 & 0\\
\noalign{\smallskip}\hline
\end{tabular}
\end{table}

\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{0.20\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-pand-gate}
    \caption{\acs*{PAND} gate}\label{fig:tft-pand-gate}
  \end{subfigure}
  \begin{subfigure}[b]{0.20\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-por-gate}
    \caption{\acs*{POR} gate}\label{fig:tft-por-gate}
  \end{subfigure}
  \begin{subfigure}[b]{0.20\linewidth}
    \centering
    \includegraphicsaspectratio[0.75]{ft-symbol-sand-gate}
    \caption{\acs*{SAND} gate}\label{fig:tft-sand-gate}
  \end{subfigure}
  \caption{\acs*{TFT}-specific gates}
  \label{fig:tft-symbols}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphicsaspectratio[0.55]{tft-small-example}
  \caption{\acs*{TFT} small example}
  \label{fig:tft-small-example}
\end{figure}

\begin{table}
  \caption{\acs*{TTT} of a simple example}
  \label{tbl:ttt-small-example}
  \centering
  {\scriptsize
  \begin{tabular}{ccccccc}
  \hline\noalign{\smallskip}
  \# & A & B & C & $A \pand C$ & $A \land B$ & $\parsin{A \pand C} \lor \parsin{A \land B}$ \\
  \noalign{\smallskip}\hline\noalign{\smallskip}
  01 & 0 & 0 & 0 & 0 & 0 & \textbf{0}\\
  02 & 0 & 0 & 1 & 0 & 0 & \textbf{0}\\
  03 & 0 & 1 & 0 & 0 & 0 & \textbf{0}\\
  04 & 0 & 1 & 1 & 0 & 0 & \textbf{0}\\
  05 & 0 & 1 & 2 & 0 & 0 & \textbf{0}\\
  06 & 0 & 2 & 1 & 0 & 0 & \textbf{0}\\
  07 & 1 & 0 & 0 & 0 & 0 & \textbf{0}\\
  08 & 1 & 0 & 1 & 0 & 0 & \textbf{0}\\
  09 & 1 & 0 & 2 & 2 & 0 & \textbf{2}\\
  10 & 1 & 1 & 0 & 0 & 1 & \textbf{1}\\
  11 & 1 & 1 & 1 & 0 & 1 & \textbf{1}\\
  12 & 1 & 1 & 2 & 2 & 1 & \textbf{1}\\
  13 & 1 & 2 & 1 & 0 & 2 & \textbf{2}\\
  14 & 1 & 2 & 2 & 2 & 2 & \textbf{2}\\
  15 & 1 & 2 & 3 & 3 & 2 & \textbf{2}\\
  16 & 1 & 3 & 2 & 2 & 3 & \textbf{2}\\
  17 & 2 & 0 & 1 & 0 & 0 & \textbf{0}\\
  18 & 2 & 1 & 0 & 0 & 2 & \textbf{2}\\
  19 & 2 & 1 & 1 & 0 & 2 & \textbf{2}\\
  20 & 2 & 1 & 2 & 0 & 2 & \textbf{2}\\
  21 & 2 & 1 & 3 & 3 & 2 & \textbf{2}\\
  22 & 2 & 2 & 1 & 0 & 2 & \textbf{2}\\
  23 & 2 & 3 & 1 & 0 & 3 & \textbf{3}\\
  24 & 3 & 1 & 2 & 0 & 3 & \textbf{3}\\
  25 & 3 & 2 & 1 & 0 & 3 & \textbf{3}\\
  \noalign{\smallskip}\hline
  \end{tabular}
  }
\end{table}

From structure expressions in order-sensitive \acp{FT} (\ac{TFT} and \ac{DFT}), \acp{MCSeq} are obtained.
Several approaches represent \ac{MCSeq} ordering differently.
For the best of our knowledge they are introduced in the work~\cite{TD2004} similarly to \ac{MCS}, allowing set elements with arrows (``$\rightarrow$'') to represent order.

For \acp{TFT}, in the work~\cite{Walker2009} \acp{MCSeq} are represented as \iac{DNF} using \ac{AND} and the temporal operators (\ac{PAND}, \ac{POR}, and \ac{SAND}) as doublets (a single temporal relation)---which are the minimal terms---or prime implicants---in the \ac{DNF}.
In a doublet, the expression is a product (\ac{AND}) of temporal operators, and each temporal operator contains \emph{exactly} two events.
The conversion to doublets uses the temporal laws as shown in the work reported in~\cite{Walker2009}.
For example, the expression $\parsin{X \sand Y} \por Z$ is a temporal relation (\ac{POR}) of a temporal relation (\ac{SAND}).
To extract \acp{MCSeq} it needs to be converted to $\squaresin{X \sand Y} \land \squaresin{X \por Z} \land \squaresin{Y \por Z} $ (the square brackets is the doublets notation and the conversion is the definition of the \emph{Temporal Distributive Law}~\cite[p. 120]{Walker2009}).

The normal form for \ac{TFT} is similar to that for \ac{SFT}: it is \iac{DNF} with temporal operators (\ac{PAND}, \ac{POR}, \ac{SAND}) in the minimal terms.
The reduction of \ac{TFT} structure expressions is achieved using \ac{DT}.
In \iac{DT}, if all children of a tree node are true, then the node is also true.
Conversely, if a node is true, then all its children are also true.
An issue with \acp{DT} is that they grow exponentially.
According to the work reported in~\cite{WP2010}, it is already infeasible to deal with seven fault events in \acp{TFT}.
Although there is a solution, it is based on a mixed application of \acp{DT}, modularisation of independent subtrees, and algebraic laws~\cite{WP2009}.
Such a solution is not able to solve \acp{FT} with \ac{NOT} gates, and requires some manual work to modularise independent trees.
We show \acp{DT} in~\cref{sec:dependency-trees}.
Some of these algebraic laws are:
%
\begin{subequations}
\begin{align}
  \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} &= X \land Y & \text{Conjunctive Completion Law}\label{law:tft-conjunctive-completion-law}\\
  \parsin{X \por Y} \lor \parsin{X \sand Y} \lor \parsin{Y \por X} &= X \lor Y & \text{Disjunctive Completion Law}\\
  \parsin{X \por Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} &= X & \text{Reductive Completion Law 1st}\\
  \parsin{X \land Y} \lor \parsin{X \por Y}  &= X & \text{Reductive Completion Law 2nd}
\end{align}
\end{subequations}

\subsection{\Aclp*{DFT}}
\label{sec:dynamic-fault-trees}

\begin{sloppypar}
\Aclp{DFT} were designed with the goal of analysing complex systems with dynamic redundancy management and complex fault and recovery mechanisms~\cite{DBB1992}.
The idea was to create easy-to-use and less error-prone modelling tools than using \acp{DTMC}---or simply \emph{\acap{DTMC}}---directly.
So, since the very beginning, \acp{DFT} were intended to be a visual representation of \acap{DTMC}.
\Cref{fig:dft-original-symbols} depicts the original gate symbols as shown in~\cite{DBB1992,Boyd1992}.
In this work, we use gate symbols as depicted in \cref{fig:dft-symbols}.
The informal semantics of them are:
%
\begin{description}
  \item[\Ac{FDEP}:]
  When the trigger event occurs, the dependent events are forced to occur.
  Timing in this gate between the trigger event and dependent events occurrences can be instantaneous (like in \acg{TFT} \ac{SAND} gate), or a small amount of time, thus implying an order of occurrence, depending on the kind of dependency.
  \item[\Ac{CSp}:]
  It is a specific gate to handle spare components.
  It is important to note that connected inputs are not components---they are fault events of connected components.
  If the i\emph{th} input is already active (fault has occurred), then it is expected that the input $\parsin{i+1}$\emph{th} is not, following the specified order.
  The output becomes true after all connected inputs become true.
  A spare event can be connected to more than one \ac{CSp} gate, representing the spare unit connection to one or more components.
  \item[\ac{PAND}:]
  The same as in \ac{TFT}: when the connected input events occur in the specified order, it outputs true.
  \item[\Ac{SEQ}:]
  The connected events \emph{shall} occur in the specified order.
  It is different from the \ac{PAND} gate, because the latter \emph{detects} the specified order.
  The usage of this gate is usually associated with \ac{FDEP}.
\end{description}
\end{sloppypar}

\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{.32\linewidth}
    \centering
      \includegraphicsaspectratio[1]{dft-original-fdep-symbol}
    \caption{\acs*{FDEP} gate}\label{fig:dft-original-fdep-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.45\linewidth}
    \centering
      \includegraphicsaspectratio[1]{dft-original-csp-symbol}
    \caption{\acs*{CSp} gate}\label{fig:dft-original-csp-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.20\linewidth}
    \centering
      \includegraphicsaspectratio[1]{dft-original-seq-symbol}
    \caption{\acs*{SEQ} gate}\label{fig:dft-original-seq-symbol}
  \end{subfigure}%
  \caption{\acspg*{DFT} original gates symbols}
  \label{fig:dft-original-symbols}
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{.3\linewidth}
    \centering
      \includegraphicsaspectratio[0.7]{ft-symbol-fdep-gate}
    \caption{\acs*{FDEP} gate}\label{fig:dft-fdep-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.3\linewidth}
    \centering
    \includegraphicsaspectratio[1]{ft-symbol-csp-gate}
    \caption{\acs*{CSp} gate}\label{fig:dft-csp-symbol}
  \end{subfigure}%
  %
  \begin{subfigure}[b]{.3\linewidth}
    \centering
      \includegraphicsaspectratio[0.8]{ft-symbol-seq-gate}
    \caption{\acs*{SEQ} gate}\label{fig:dft-seq-symbol}
  \end{subfigure}%
  \caption{\acpg*{DFT} gates symbols}
  \label{fig:dft-symbols}
  %
  %\legend{Source: \cite{DBB1992,Boyd1992}}
\end{figure}


There are several means to analyse \acp{DFT} qualitative and quantitatively.
The works reported in~\cite{Merle2010,MRL+2010,MRL2011,MRL2014} use structure expressions to perform both qualitative and quantitative analysis, and the work reported in~\cite{MRL2014} summarizes other approaches.
\Cref{tbl:dft-conversion-te-probability} shows more details about such approaches.
We categorize them as:
%
\begin{alineas}
  \item
  Finding \acp{MCSeq} (qualitative analysis) is obtained by replacing \ac{DFT} gates with \ac{SFT} gates, using the text as their logical constraints.
  \Acp{MCS} in the \ac{SFT} are expanded using timing constraints from the texts into \ac{MCSeq}.
  In this case, the behaviour of spare events cannot be correctly taken into account;
  \item
  Quantitative analysis consists in converting \iac{DFT} to a well-defined formalism to calculate the probability of its top-level event.
  \Cref{tbl:dft-conversion-te-probability} shows the conversion options, the calculation, and where the method is explained.
\end{alineas}

\begin{table}[t]
  \caption{\Ac{DFT} conversion to calculate probability of top-level event}
  \label{tbl:dft-conversion-te-probability}
  \centering
  \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } p{7cm} p{5cm} p{3cm} }
  %\begin{tabularx}{\linewidth}{XXX}
  \hline\noalign{\smallskip}
  \textbf{Conversion} & \textbf{Calculation} & \textbf{Explained in}\\
  \hline\noalign{\smallskip}\hline\noalign{\smallskip}
  Automaton-like structure & \ac{CTMC} & \cite{CSD2000}\\
  %
  \hline\noalign{\smallskip}
  \Ac{BN} & Inference algorithm (model-specific) & \cite{BRM+2005}\\
  %
  \hline\noalign{\smallskip}
  \Ac{SWN} (a kind of \ac{CPN}) & \ac{CTMC} & \cite{BR2004} \\
  %
  \hline\noalign{\smallskip}
  \Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} (a modified version of \ac{BDD}\index{Binary Decision Diagrams}) & model-specific & \cite{TXD2011,XTD2012} \\
  \hline\noalign{\smallskip}
  \end{tabular*}
  %\end{tabularx}
\end{table}

%Structure expressions\index{structure expression} are also used in \acp{DFT}.
In~\cite{Merle2010,MRL+2010,MRL2011} fault events occur in a specific time and are instantaneous (similar to detected faults), stated through a ``date-of-occurrence'' function.
As the ``date-of-occurrence'' function is stated in continuous time, the probability of two events occurring at the same time is negligible.
Thus, the relation in time of the occurrence of the events is, in fact, the useful information.
\Ac{DFT} gates' algebraic model is summarized in \cref{tbl:merle-dft-algebraic-model}.
Structure expressions\index{structure expression} are written with an algebra that has operators \ac{OR} and \ac{AND}, and three new operators to express events ordering:
\begin{alineasinline}
  \item \ac{NIBefore},
  \item \ac{SIMLT}, and
  \item \ac{IBefore}.
\end{alineasinline}
The \ac{NIBefore} and the \ac{SIMLT} operators are similar to \ac{TFT}'s \ac{POR} and \ac{SAND} operators, respectively.
The \ac{IBefore} is a composition of \ac{NIBefore} and \ac{SIMLT} operators.
\Cref{tbl:date-of-occurrence-for-operators} summarizes the date-of-occurrence function for all operators.
An infinite value means the event never occurs.

\Acp{MCSeq} are extracted from a normal form of structure expressions written in \iac{DNF}.
Minimal terms are products of variables and \ac{NIBefore} operators (the other operators can be written as combinations of \ac{NIBefore}).
The reduction of \ac{DFT} structure expressions\index{structure expression} uses algebraic laws as, for example:
\begin{subequations}
\begin{align}
%a \lor \parsin{a \nibefore b} &= a\\
%\parsin{a \nibefore b} \lor b &= a \lor b\\
%a \land \parsin{a \nibefore b} &= a \nibefore b\\
%a \lor \parsin{a \simultaneous b} &= a\\
%a \land \parsin{a \simultaneous b} &= a \simultaneous b\\
\parsin{a \nibefore b} \lor
  \parsin{a \simultaneous b} \lor
  \parsin{b \nibefore a} &= a \lor b\\
%
\parsin{a \land \parsin{b \nibefore a}} \lor
  \parsin{a \simultaneous b} \lor
  \parsin{b \land \parsin{a \nibefore b}} &= a \land b\\
%
\parsin{a \ibefore b} \land \parsin{b \ibefore a} &= a \simultaneous b
\end{align}
\end{subequations}

\begin{table}
  \caption{Algebraic model of \ac{DFT} gates with inputs $A$ and $B$}
  \label{tbl:merle-dft-algebraic-model}
  \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c p{5.9cm} p{7.8cm} }
  \hline\noalign{\smallskip}
  \textbf{Gate} & \textbf{Algebraic model of gate's output} & \textbf{Note}\\
  \hline\noalign{\smallskip}\hline\noalign{\smallskip}
  %
  \ac{FDEP} & $A_T = T \lor A$ and $B_T = T \lor B$ & $A_T$ and $B_T$ replace $A$ and $B$ on the resulting expression\\
  %
  \hline\noalign{\smallskip}
  \ac{CSp} &
    $\parsin{B_a \land \parsin{A \nibefore B_a}} \lor
    \parsin{A \land \parsin{B_d \nibefore A}}$ & $A$ is the active input, and $B$ is the spare. Subscripts $a$ and $d$ represent component's state---\emph{active} and \emph{dormant}, respectively, which are used on the failure distribution formulas\\
  %
  \hline\noalign{\smallskip}
  \ac{PAND} & $B \land \parsin{A \ibefore B}$ & No distinction of active or dormant states.\\
  %
  \hline\noalign{\smallskip}
  \end{tabular*}
\end{table}

\begin{table}
  \caption{Date-of-occurrence\index{Dynamic Fault Tree!Date-of-occurrence function} function for operators defined in \cite{Merle2010}}
  \label{tbl:date-of-occurrence-for-operators}
  \centering
  \begin{tabularx}{\textwidth}{ccXXX}
    \hline\noalign{\smallskip}
    \textbf{Operator} &
      \textbf{Expression} &
      \textbf{Expr. value if \smallskip\smallskip} $\mathbf{\func{d}{a} < \func{d}{b}}$ &
      \textbf{Expr. value if \smallskip\smallskip} $\mathbf{\func{d}{a} = \func{d}{b}}$ &
      \textbf{Expr. value if \smallskip\smallskip} $\mathbf{\func{d}{a} > \func{d}{b}}$\\
    \hline\noalign{\smallskip}\hline\noalign{\smallskip}
    \ac{OR} &
      $\func{d}{a \lor b}$ & $\func{d}{a}$ & $\func{d}{a}$ & $\func{d}{b}$\\
    \ac{AND} &
      $\func{d}{a \land b}$ & $\func{d}{b}$ & $\func{d}{a}$ & $\func{d}{a}$\\
    \ac{NIBefore} &
      $\func{d}{a \nibefore b}$ & $\func{d}{a}$ & $+\infty$ & $+\infty$\\
    \ac{SIMLT} &
      $\func{d}{a \simultaneous b}$ & $+\infty$ & $\func{d}{a}$ & $+\infty$\\
    \ac{IBefore} &
      $\func{d}{a \ibefore b}$ & $\func{d}{a}$ & $\func{d}{a}$ & $+\infty$\\
    \hline\noalign{\smallskip}
  \end{tabularx}

\end{table}

%The work reported in~\cite{TXD2011,XTD2012} shows the top-level events probability calculation for \acp{DFT} by converting them to a simplified version, using only order-based operators.
%Such a simplified version, which is based on a modified \ac{BDD}\index{Binary Decision Diagrams} that includes an order-based operator, creates Sequential BDDs\index{Binary Decision Diagrams!Sequential} that are used to perform the probabilistic analysis.

\begin{sloppypar}
\Cref{fig:dft-example} shows an example of \iac{DFT} extracted from~\cite{MRL2014}.
It is \iac{HCAS}, which is divided in four modules: trigger, CPU unit, motor section, and pumps.
The trigger is divided in two components, CS and SS.
The failure of any CS or SS, triggers a CPU unit failure.
The primary CPU (P) has a warm\footnote{Warm spare gates only differ from \ac{CSp} on the activation time.} spare (B).
The motor module fails if both M and MC fail.
In order for the pumps unit to fail, all three pumps need to fail, and the left-hand side spare gate needs to fail before (or at the same time as) the right-hand side spare gate (\ac{PAND} gate\footnote{Although the original example uses \iac{PAND} gate, accordingly to the informal description, \iac{SEQ} gate would fit better.}).
The top-level event structure expression is:
\begin{align}
SYSTEM =& CS \lor SS \lor \parsin{M \land MC} \lor \\
  &\parsin{P \land \parsin{B_d \nibefore P}} \lor \parsin{B_a \land \parsin{P \nibefore B_a}} \lor \nonumber\\
  &\parsin{BP_a \land \parsin{P2 \nibefore P1} \land \parsin{P1 \nibefore BP_a}} \lor
  \parsin{P2 \land \parsin{P1 \nibefore BP_a} \land \parsin{BP_a \nibefore P2}}\nonumber
\end{align}
\end{sloppypar}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.65]{dft-example-mrl2014}
  \caption{\acs*{DFT} example}
  \label{fig:dft-example}
\end{figure}

\section{Structure expression analysis}
\label{sec:structure-expression-analysis}

In this \lcnamecref{sec:structure-expression-analysis} we explain the difference of stateful and stateless methods to analyse structure expressions and detail the stateless methods.
A common approach to analyse \iac{FT} is to perform structure expression analysis based on algebraic laws.
Boolean\index{Boolean Algebra} laws are well-known and are used for \acp{SFT}, temporal laws~\cite{Walker2009,WP2010} for \acp{TFT}, and the works reported in~\cite{Merle2010,MRL2011} show laws for \acp{DFT}.
An issue with algebraic laws is that, in some cases, the expression needs to be expanded before it gets rewritten.
So, automation with rewriting is not trivial.
For example, the following \acg{TFT} structure expression needs to be expanded \cite{WP2010} before it gets reduced via rewriting:
\begin{align*}
  & \parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z} &\\
  = & \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} \lor \parsin{\parsin{X \pand Y} \land Z} & \text{by \cref{law:tft-conjunctive-completion-law}}\\
  = & \parsin{X \pand Y} \lor \parsin{X \sand Y} \lor \parsin{Y \pand X} & \text{by Boolean absorption of } X \pand Y\\
  = & X \land Y & \text{by \cref{law:tft-conjunctive-completion-law}}
\end{align*}

A denotational semantics to Boolean\index{Boolean Algebra} expressions---and consequently to \ac{SFT}---is given by \acp{FBA} (\cref{sec:fba}).
Using denotational semantics in favour of axiomatic laws is preferred as the axioms must be very simple or must be generally accepted, because a subtlety in an axiom (an unfounded axiom) may invalidate a whole theory.

There are several works with stateful analysis methods for \acp{FT} (\ac{SFT}, \ac{TFT}, and \ac{DFT}).
We show some of them in \cref{sec:ft-stateful-analysis-methods}.

\subsection{Stateful methods and temporal logic analysis}
\label{sec:ft-stateful-analysis-methods}

The work reported in~\cite{STR2002} shows a formal approach to analyse \ac{SFT} using \ac{ITL}.
Instead of tackling basic events ordering (as in \ac{PAND}), it considers a causal relation over a gate, as for example, a relation of a basic event and a higher-level intermediary event.

For \acp{TFT}, the works reported in~\cite{MPW2010,MWP2012} show an inverse solution.
They map \acp{FSM} to \pandora logic, then verify system properties.
They show that such a mapping simplifies expression reduction, thus improving performance on the analysis.

Although there is formal modelling approaches to \acp{DFT}, they do not implement a direct modelling of the \ac{DFT} itself.
Instead, most of the works propose a formal modelling using a state-based approach.
The work reported in~\cite{CSD2000} shows a formal model of \acap{DTMC} in \theac{Z} and each \ac{DFT} element (basic events and gates).
The analysis uses a quantifier on states of the resulting \aca{DTMC} automaton.
The work reported in~\cite{GD1997} shows a methodology to perform a modular analysis of \acp{DFT} based on \ac{BDD}\index{Binary Decision Diagrams} and \aca{DTMC}.
As \ac{DFT} extends \ac{SFT}, it identifies subtrees that are purely \ac{SFT} and uses \ac{BDD}\index{Binary Decision Diagrams}, otherwise.
It performs \aca{DTMC} analysis.
Still on the state-based approaches, the work reported in~\cite{SLD2011} maps \acp{DFT} to \ac{HLPN} to analyse false alarms.

%The work reported in~\cite{LR1998} uses a formal approach using \ac{FSM} to generate fault trees automatically from system models.

In the following we show specific stateless methods that are designed to reduce structure expressions.
In essence, the methods are very similar.
Structure expressions for \acp{SFT} can be reduced using \acp{BDD} (\cref{sec:bdd}), \acp{TFT} can be reduced using \acp{DT} (\cref{sec:dependency-trees}), \acp{MCSeq} of \acp{DFT} can be obtained using \ac{ZBDD} (\cref{sec:zbdd}), and the works reported in~\cite{TXD2011,XTD2012} show the analysis of standby systems (\ac{CSp} gates) using \acp{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} (\cref{sec:sbdd}).

\subsection[BDD]{\Aclp*{BDD}\index{Binary Decision Diagrams}}
\label{sec:bdd}

\Acp{BDD}\index{Binary Decision Diagrams} are directed acyclic graphs that represent a Boolean\index{Boolean Algebra} expression.
They are still referred to as \ac{BDD}\index{Binary Decision Diagrams}, but the widespread version is the \ac{ROBDD}, which is an optimisation.
There are two ways to generate \iac{BDD}\index{Binary Decision Diagrams} for an expression:
\begin{alineasinline}
  \item derive a diagram from the truth-table, or
  \item expand the paths based on Shannon's method\index{Binary Decision Diagrams!Shannon's method} (described in the \FThandbook).
\end{alineasinline}

To demonstrate the expressiveness of \iac{BDD}, \cref{fig:bdd-diagram-for-a-truth-table} shows a diagram for a truth table with three variables (\cref{tbl:bdd-truth-table-with-three-variable}).
In a node, when a path is chosen, the variable of the node assumes the edge value.
For example, the top-level node variable of \cref{fig:bdd-diagram-for-a-truth-table} is $A$.
Following the right-hand side of the node, all leaf nodes correspond to the lines of the truth table that $A$ has ``0'' values (the first four lines).
The symbol nodes are replaced by the values assumed by a specific formula.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{bdd-diagram-for-a-truth-table}
  \caption{A diagram for a truth table}
  \label{fig:bdd-diagram-for-a-truth-table}
\end{figure}

\begin{table}[t]
  \caption{Truth table for a formula outputs with three variables (A, B, and C)}
  \label{tbl:bdd-truth-table-with-three-variable}
  \centering
  {\footnotesize
  \begin{tabular}{cccc}
    \hline\noalign{\smallskip}
    \textbf{A} & \textbf{B} & \textbf{C} & \textbf{Formula}\\
    \hline\noalign{\smallskip}\hline\noalign{\smallskip}
    0 & 0 & 0 & a \\
    0 & 0 & 1 & b \\
    0 & 1 & 0 & c \\
    0 & 1 & 1 & d \\
    1 & 0 & 0 & e \\
    1 & 0 & 1 & f \\
    1 & 1 & 0 & g \\
    1 & 1 & 1 & h \\
    \hline\noalign{\smallskip}
  \end{tabular}
  }
\end{table}

Following Shannon's method\index{Binary Decision Diagrams!Shannon's method}, we choose a variable and build the lower level \ac{BDD}\index{Binary Decision Diagrams} assuming the edge value for the chosen variable.
In the remainder of the path, the variable's value is unchanged.
For example, the expression $A \lor \parsin{\lnot B \land C}$ has value ``0'' in the lines $a$ and $c$, and value ``1'' in the other lines.
By choosing the variable $A$ first, then $B$ and $C$, the resulting \ac{BDD}\index{Binary Decision Diagrams} with the binary values nodes (called sink nodes ``false'' and ``true'') for this formula is depicted in \cref{fig:bdd-diagram-for-example-expression}.
Starting from the top-level node $A$, the formula expressed by the \ac{BDD}\index{Binary Decision Diagrams} is true if $A$ assumes value true.
If $A$ is false, and $B$ is false, the expression is only true if $C$ is true.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.25]{bdd-diagram-for-example-expression}
  \caption{\Iacs{BDD} for the expression $A \lor \parsin{\lnot B \land C}$}
  \label{fig:bdd-diagram-for-example-expression}
\end{figure}

\Cref{fig:bdd-diagram-for-example-expression} is \iac{ROBDD}.
To be considered \iac{ROBDD}, the \ac{BDD}\index{Binary Decision Diagrams} must meet the following constraints~\cite{BRB1990}:
%
\begin{alineas}
  \item the variables are assigned a constant ordering;
  \item every path to sink nodes visit the input variables in ascending order;
  \item each node represents a distinct logic function.
\end{alineas}
%
For a given expression, the size of \acp{BDD} and \acp{ROBDD} depends on the chosen variables ordering.
The work reported in~\cite{Rudell1993} shows initial findings on best variable ordering, and the work reported in~\cite{KH2014} shows heuristics to improve the performance for optimal order search.

For \acp{SFT} the evaluation of \iac{BDD} is the calculation of the probability of the paths ending in \emph{true}.
For example, the probability of the expression in \cref{fig:bdd-diagram-for-example-expression} is obtained from the formula: $\probability{A \lor \parsin{\lnot A \land \lnot B \land C}}$. Note that the formula in the probability calculation is different from the formula that originated the diagram.

\subsection[DT]{\Acl*{DT}}
\label{sec:dependency-trees}

\Acf{DT} is a hierarchical acyclic graph of expressions that shows all possible cut sequences for any given set of events.
It is a graphical view of a \ac{TTT}.
At the top of \iac{DT} are the variables, that is, the single events that occur in an expression.
On the lower levels are the increasingly complex expressions.
Each node represents \iac{MCSeq}.
\Cref{fig:simple-dependency-tree} shows \iac{DT} with all nodes for variables $X$ and $Y$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{simple-dependency-tree}
  \caption{\acs*{DT} for variables $X$ and $Y$}
  \label{fig:simple-dependency-tree}
\end{figure}

The reduction of a structure expression is given by the activation (true values) of nodes.
If a node is active (true), then all child nodes are also active; the converse is also true: if all node's children are active, then it is also active.
The reduced expression is given by the \ac{DNF} created with the expressions of higher active level nodes.
To reduce the formula $\parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z}$, given on the beginning of this \lcnamecref{sec:dependency-trees}, we create the \ac{DT} depicted in \cref{fig:dependency-tree-reduction}.
Nodes marked with ``1'' are those \acp{MCSeq} given directly by the formula.
Nodes marked with ``2'' are child nodes of the ``1'''s nodes, and so forth.
The node of the expression $\parsin{\parsin{X \pand Y} \land Z}$ is a grandchild of $X \land Y$ and thus it is not necessary.
The final expression is obtained by the active higher level node, which is $X \land Y$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.7]{dependency-tree-reduction}
  \caption{\acs*{DT} for the formula $\parsin{X \land Y} \lor \parsin{\parsin{X \pand Y} \land Z}$}
  \label{fig:dependency-tree-reduction}
\end{figure}

\subsection[ZBDD]{\Aclp*{ZBDD}\index{Zero-suppressed Binary Decision Diagrams}}
\label{sec:zbdd}

The work reported in~\cite{TD2004} proposes \aclp{ZBDD}, which is a variant of \ac{BDD}\index{Binary Decision Diagrams}, and uses set manipulations (union, intersection, difference, and product) to obtain \acp{MCSeq} of \acp{DFT}.

To reduce \iac{BDD} to \iac{ZBDD}, the nodes that have the ``true'' (`1') path pointing to the ``false'' (`0') sink node are removed, and the parent node is connected directly to the ``false'' subgraph of the removed node.
\Cref{fig:zbdd-example} shows an example of \ac{ZBDD} for the combination set $\setsin{a,b}$, as shown in~\cite{TD2004}.
The idea of the reduction is to remove irrelevant variables and nodes.
The irrelevant variables are set to ``false''.
The method described in~\cite{TD2004} obtains the \acp{MCSeq} by navigating the paths to sink node ``true''.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.7]{bdd-zbdd-example}
  \caption{\acs*{ZBDD} example of combination set $\setsin{a,b}$}
  \label{fig:zbdd-example}
\end{figure}

Although the work reported in~\cite{TD2004} shows \theac{ZBDD}, the final solution does not use them directly. 
The idea is to transform the \ac{DFT} into \iac{SFT}, in a very similar way as the one shown in~\cite{TXD2011}.
The order-related operators in \iac{DFT} are replaced by a new event, which takes ordering into account.
Finally, the \acp{MCSeq} are obtained using set manipulation with elements that are basic events alone or order-related operators.
These order-related operators are event-to-event only, so they cannot be combined with other sets.

The use of sets in~\cite{TD2004} is very related to our \ac{algebra}.
We use sets of sequences to define the \ac{algebra}, but keep the analysis with set operators.
In \ac{algebra} we do not create new events that represent an order-related operator.
Our order-related operator has a set-based semantics that can be combined with other non-order-related (Boolean\index{Boolean Algebra}) operators.

\subsection[SBDD]{\Aclp*{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential}}
\label{sec:sbdd}

\Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} is an extension of \ac{BDD}\index{Binary Decision Diagrams} to tackle ordering of events in \acp{DFT} for \ac{CSp} and \ac{WSp} gates.
Ordering of events in \ac{CSp} gates~\cite{XTD2012} is slightly different from \ac{WSp}~\cite{TXD2011}.
A backup system in \ac{CSp} gets activated slower than in \ac{WSp}, which implies that there are less failure possibilities in \ac{CSp}, but its the readiness is lower than in \ac{WSp}.
\Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} adds a new kind of node that contains a binary operation of fault events, which allows to express the ordering of events.
One kind of operation expresses the slowness of the relation of the fault events of \ac{CSp}, and another one expresses the readiness of the \ac{WSp}.
The latter semantics is similar to the semantics of \ac{PAND} and \ac{IBefore} (combined with \ac{AND}) gates.

\Ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} creation has two steps:
\begin{alineasinline}
  \item \ac{CSp} or \ac{WSp} \ac{DFT} conversion, and \label{item:sbdd-creation-spare}
  \item \ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} model generation.\label{item:sbdd-model-generation}
\end{alineasinline}
In \ref{item:sbdd-creation-spare}, it is a \ac{DFT}-to-\ac{DFT} conversion.
\Ac{CSp} and \ac{WSp} gates are converted to a new, but equivalent \ac{DFT} without \ac{CSp} and \ac{WSp} gates, where the operations appear as basic events and are combined using other gates.
In \ref{item:sbdd-model-generation}, the \ac{SBDD}\index{Sequential Binary Decision Diagrams}\index{Binary Decision Diagrams!Sequential} model is created.
The model may contain nodes that are contradictory as, for example, nodes that assumes that an event $A$ is false and a binary operation with \ac{AND} semantics that contains $A$ is true.
This step ends when all contradictions are removed.
The evaluation is similar to \acg{BDD}: each path ending in true is a minimal term in the \ac{DNF} that may contain one of the binary operations and individual events.


\section[Free Boolean Algebras]{\Aclp*{FBA}}
\label{sec:fba}
\index{Boolean Algebra!Free}

Another means to analyse \acp{SFT} is to use \iac{FBA} to perform set-theoretical operations (intersection, difference, etc.) to reduce expressions.
In this \lcnamecref{sec:fba} we briefly present the \ac{FBA} theory and its elements.

Instead of using an axiomatic definition of a Boolean\index{Boolean Algebra} algebra directly, we follow its set-theoretical definition, as shown in~\cite[pp. 254--258]{Stoll1979} and~\cite[pp. 8--11]{GH2009}.
This definition represents a Boolean\index{Boolean Algebra} algebra as an algebra of sets and does not rely on Boolean axioms (which can be misleading, if an unfounded axiom is present).

\begin{definition}[Boolean Algebra]
\label{def:boolean-algebra}
A Boolean algebra is defined as a triple $\anglesin{B, \inter, -}$, where $B$ is a set with at least two elements, $\inter$ is the intersection (also called meet or \emph{infimum}) and $-$ is the complement (also called negation).
\end{definition}
%
\noindent The other Boolean elements (union, $\bot$, and $\top$) are derived from the previous two operators:
\begin{description}
  \item[$\union$] is the union (also called join or \emph{supremum}): $A \union B = -(-A \inter -B)$
  \item [$\bot$] is the bottom (also called zero): $\bot = A \inter -A$
  \item [$\top$] is the top (also called unit): $\top = -\bot$
\end{description}

\begin{sloppypar}
\Iacl{FBA} is defined from a set $E$ of generators.
A generator can be represented as a proposition in statement calculus~\cite[p. 274]{Stoll1979}.
For example, ``valve A is stuck closed'' and ``motor M is malfunctioning'' are valid statements.
A \acl{FBA} is constructed from $\powerset{E}$, where $\powersetop$ is the power set\index{Power Set} operator.
Note that if $E$ has $n$ symbols, $\powerset{E}$ has $2^{n}$ elements, called \emph{atoms}\index{Boolean Algebra!atoms} of a finite Boolean algebra.
For the two statements above, the atoms\index{Boolean Algebra!atoms} are:
\begin{alineas}
  \item ``Valve A is stuck closed'' and ``motor X is malfunctioning''
  \item ``Valve A is stuck closed'' and ``motor X is \emph{not} malfunctioning''
  \item ``Valve A is \emph{not} stuck closed'' and ``motor X is malfunctioning''
  \item ``Valve A is \emph{not} stuck closed'' and ``motor X is \emph{not} malfunctioning''
\end{alineas}
Such a Boolean\index{Boolean Algebra} algebra has $2^{2^{n}}$ formulas~\cite[p. 261]{GH2009}.
For example, if $E = \setsin{a,b}$, then $\powerset{E} = \setsin{ \setsin{}, \setsin{a}, \setsin{b}, \setsin{a,b} }$.
And the Boolean\index{Boolean Algebra} algebra generated by $E$ contains sixteen ($2^{2^{2}}$) formulas:
$\setsin{}$,
$\setsin{\setsin{}}$,
$\setsin{\setsin{}, \setsin{a}}$,
$\setsin{\setsin{}, \setsin{b}}, \ldots$,
$\setsin{\setsin{a}, \setsin{a,b}}, \ldots$,
$\setsin{\setsin{b}, \setsin{a,b}}, \ldots$,
$\setsin{\setsin{}, \setsin{a}, \setsin{b}, \setsin{a,b}}$.
\end{sloppypar}

The Boolean\index{Boolean Algebra} algebra $B$ can be inductively defined using some constructs.
%
\begin{definition}[Inductive \acl*{FBA}]
\label{def:inductive-fba}
Let $s$ be a statement, then:
%
\begin{subequations}
\begin{align}
\var s = \setsin{X | s \in X} & \implies \var s \in B & \text{(variable)}\\
X \in B & \implies -X \in B                           & \text{(complement)}\\
X \in B \land Y \in B & \implies X \inter Y \in B     & \text{(intersection)}
\end{align}
\end{subequations}
%
\end{definition}

The characterisation of a ``free'' Boolean\index{Boolean Algebra} algebra comes from that, for some valuation function $a$, some formulas evaluate to ``1''.
Given a function $p:B \cartesian \setsin{0,1} \rightarrow B$, such that:
%
\begin{equation}
p\parsin{i,j} =
\begin{cases}
  i & \quad j = 1\\
  -i & \quad j = 0
\end{cases}
\end{equation}

\begin{lemma}[Free generators (valuation)]
\label{lem:boolean-algebra-free-generators-valuation}
Let $F$ be a finite set, and $E$ be a set of generators of a Boolean\index{Boolean Algebra} algebra, such that $F \subseteq E$, and $a: F \rightarrow \setsin{0,1}$, a necessary and sufficient condition for the set $E$ to be free is then:
%
\begin{equation}
\bigwedge_{i \in F} p\parsin{i, a \parsin{i}} \neq 0
\end{equation}
\end{lemma}
%\begin{proof}
%See~\cite[p. 258]{GH2009}.
%\end{proof}


Essentially, \cref{lem:boolean-algebra-free-generators-valuation} states that there is no relation between generators, such as $a = -b$.

\begin{lemma}[Free generators (algebraic)]
Let $i$ and $j$ be statements, such that $i,j \in E$, hence from \cref{def:inductive-fba,lem:boolean-algebra-free-generators-valuation} it is necessary and sufficient that:
%
\begin{subequations}
\begin{align}
\var i = \var j & \iff i = j\\
\var i & \neq - \var j\\
-\var i & \neq \var j
\end{align}
\end{subequations}
%
\end{lemma}
%
%\begin{proof}
%See~\cite[p. 4]{Huffm2010}
%\end{proof}

\section[Using the NOT operator in static fault trees]{Using the \ac{NOT} operator in \aclp*{SFT}}
\label{sec:not-operator}

Although the \FThandbook introduces several gates, the vast majority of \ac{SFT} analyses would fit in \acp{FT} with only \ac{AND} and \ac{OR} gates (coherent \acp{FT})\index{Fault Tree!coherent}.
Qualitative analysis requires the reduction of the structure expression of \acp{FT} and, when \ac{NOT} gates are present (non-coherent \acp{FT}\index{Fault Tree!non-coherent}), such a reduction can cause the interpretation of failure expression to be misled~\cite{Andrews2001,Oliv2006,AB2003,CCR2008,Vaurio2016}.
The work reported in~\cite{Oliv2006} shows three funny examples of this kind of problem, and the works reported in~\cite{Andrews2001,CCR2008} show how to solve it using \acp{BDD}.
In the following we show:
\begin{alineasinline}
  \item the second example presented in~\cite{Oliv2006}, which highlights the problem when using \ac{NOT} gates (\cref{sec:non-coherent-misleads-example}), and
  \item the second example presented in~\cite{Andrews2001}, which defends the usefulness of \ac{NOT} gates in a multitasking system (\cref{sec:non-coherent-usefulness}).
\end{alineasinline}

Negated events in a non-coherent analysis are in fact the working state of a component.
The failure probability contribution of a negated basic event is close to $1$.
The problem with non-coherent \acp{FT} is that its analysis can cause impossible situations.
The general formula to identify coherency is given in~\cite{Andrews2001,CCR2008} in terms of a structure function\index{structure expression!function}.

\begin{definition}[\ac{FT} Coherency]
\label{def:ft-coherency}
Let $\ftcoherency{x}:B^n \rightarrow B^1$ be a binary function of a vector of binary variables, such that $x = \squaresin{x_1, x_2,\ldots,x_n}$, representing the states of $n$ system's components.

A binary structure function $\ftcoherency{x}$ is coherent if all the following hold:
\begin{alineas}
  \item $\ftcoherency{x}$ is monotonic (non-decreasing) in each variable;
  \item Each $x_i$ is relevant, which means that $\ftcoherency{x}\replace{x_i}{1} \neq \ftcoherency{x}\replace{x_i}{0}$ for some vector $x$.
\end{alineas}%
\end{definition}%
%
\noindent where $B^1 = \setsin{0,1}$, $B^n = B^{n-1} \cartesian B^1$, $x_i = 1$ implies that component $i$ failed, and $\ftcoherency{x} = 1$ implies the system failed.
For $y = \squaresin{y_1,y_2,\ldots,y_n}$, monotonicity of $\ftcoherencyop$ means that for \emph{all} $i$, $x_i \ge y_i$ ($y_i = 1 \implies x_i = 1$), and for \emph{some} $i$, $x_i > y_i$ ($x_i = 1$ and $y_i = 0$).
Variable replacement ($\replace{a}{b}$) is as usual:
$x\replace{x_i}{a} = \squaresin{x_1, \ldots, x_{i-1}, a, x_{i+1}, \ldots, x_n}$

\subsection[Non-coherent Fault Tree misleads]{Non-coherent \acl*{FT} misleads}
\label{sec:non-coherent-misleads-example}

In this \lcnamecref{sec:non-coherent-misleads-example} we illustrate---with the second example detailed in~\cite{Oliv2006}---how a non-coherent \ac{FT} misleads.

A college student who wants to visit her mother in another city has two options: wake up early ($x_3$) and take a ride with a friend ($x_1$), or wake up late ($\lnot x_3$) and take the metro ($x_2$).
The top-event failure is ``visit mother'' with expression $S = \parsin{x_1 \land x_3} \lor \parsin{x_2 \land \lnot x_3}$.
Its \acl{FT} is depicted in \cref{fig:non-coherent-ft-example}.
It is clear that the structure function is non-coherent in $x_3$ accordingly to \cref{def:ft-coherency}: $\ftcoherency{1,1,x_3}\replace{x_3}{1}=\ftcoherency{1,1,x_3}\replace{x_3}{0}$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.55]{non-coherent-ft-example}
  \caption{Non-coherent \ac{FT} college student's example}
  \label{fig:non-coherent-ft-example}
\end{figure}

The problem with this tree is the interpretation of the qualitative results.
One of the possibilities in this scenario is that the college student would take a ride \ac{AND} take the metro ($x_1 \land x_2$).
Quantitatively, the analysis of the probabilities shows that this result is not negligible, but its interpretation is impossible.

\subsection[Usefulness of NOT gates in FTA]{Usefulness of \ac{NOT} gates in \ac{FTA}}
\label{sec:non-coherent-usefulness}

In this \lcnamecref{sec:non-coherent-usefulness} we show the second example detailed in~\cite{Andrews2001}.

The gas detection system\index{gas detection system} depicted in \cref{fig:gas-detection-system} has two sensors $D_1$ and $D_2$ which are used to detect a leakage in a confined space.
When a leakage is detected, these sensors send a signal to the logic control unit $LU$, which performs three tasks:
%
\begin{alineas}
  \item shuts-down the main system (process isolation) by de-energizing relay $R_1$;
  \item informs the operator of the leakage by lamp and siren $L$;
  \item deactivates all possible ignition sources, which is the interruption of power supply by de-energizing relay $R_2$.
\end{alineas}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.45]{gas-detection-system}
  \caption{Gas detection system}
  \label{fig:gas-detection-system}
\end{figure}

The system\index{gas detection system} is in a fail state if it does not perform one of these three tasks.
The \acl{FT} that represents this generic failure is depicted in \cref{fig:ft-generic-failure-gas-detection-system}.
$G_1$, $G_2$, and $G_3$ are subtrees that represents the three tasks ``Operator not informed'', ``Process shut-down fails'', and ``Power supply not isolated'', respectively.
All three tasks will fail if their respective main component fails ($L$, $R_1$, and $R_2$) or there is no signal from $LU$ ($LU$ fails or both $D_1$ and $D_2$ fail).
The structure expressions for the subtrees are:
%
\begin{align*}
  G_1 & = L \lor LU \lor \parsin{D_1 \land D_2}\\
  G_2 & = R_1 \lor LU \lor \parsin{D_1 \land D_2}\\
  G_3 & = R_2 \lor LU \lor \parsin{D_1 \land D_2}\\
  TOP & = L \lor R_1 \lor R_2 \lor LU \lor \parsin{D_1 \land D_2}
\end{align*}

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[1]{ft-generic-failure-gas-detection-system}
  \caption{\ac{FT} for a generic failure in the gas detection system}
  \label{fig:ft-generic-failure-gas-detection-system}
\end{figure}

Analysing in more detail, there are different degrees of system failure.
There are eight outcomes (given the three tasks) and the most critical one is when both process shut-down ($G_2$) and power supply isolation ($G_3$) fail keeping energized upon a leakage, and the operator is not informed ($G_1$), but the operator information system is working (lamp and siren are off, but they are operational).
The coherent \ac{FT} of this outcome is depicted in \cref{fig:outcome-4-coherent-ft}.
The minimal cut sets obtained from this will be: $\setsin{R_1, R_2}$, $\setsin{D_1, D_2}$, and $\setsin{LU}$.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.5]{outcome-4-coherent-ft}
  \caption{\emph{Coherent} \ac{FT} for the most critical outcome of the gas detection system}
  \label{fig:outcome-4-coherent-ft}
\end{figure}

Quantification of the coherent \ac{FT} will overestimate the probability of the critical outcome unless the part of the system that is working (lamp and siren $L$, $LU$, and sensors $D_1$ and $D_2$) is taken into account.
The non-coherent \ac{FT} with the working part is shown in \cref{fig:outcome-4-non-coherent-ft}.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.65]{outcome-4-non-coherent-ft}
  \caption{\emph{Non-coherent} \ac{FT} for the most critical outcome of the gas detection system}
  \label{fig:outcome-4-non-coherent-ft}
\end{figure}

If the operator \emph{can} be informed, then cut sets $\setsin{D_1, D_2}$ and $\setsin{LU}$ could not have occurred (see \cref{fig:ft-generic-failure-gas-detection-system}).
Thus, the correct qualitative analysis should consider only cut set $\setsin{R_1,R_2}$.
Reducing the expressions of the non-coherent \ac{FT} (\cref{fig:outcome-4-non-coherent-ft}), we obtain the structure expression: $\lnot L \land \lnot LU \land R_1 \land R_2 \land \parsin{\lnot D_1 \lor \lnot D_2}$.
The approximation for this expression, removing the negated events, gives the cut set $\setsin{R_1,R_2}$, which gives a correct quantitative analysis.

%The examples of the usefulness of NOT gates in \ac{FTA} are one of the following, but not limited to: (i) generally, when the probability of negated events are close to $1$, (ii) exclusive states systems as, for example, non-repairable phased mission systems.

%Here we show the example of a simplified electric network (\cref{fig:simplified-electric-network-diagram}), presented in~\cite{CCR2008}.
%Two loads, pumps, $P_1$ and $P_2$ are supplied through circuits $CP_1$ and $CP_2$ by two external lines $D_1$ and $D_2$ through bars $B_1$ and $B_2$.
%The bars can be connected by switch $I$.
%Failures in $B_1$ and $B_2$ are not considered.
%In normal conditions, $I$ is open and is automatically closed in case of a failure of a line.

%\begin{figure}[t]
%  \centering
%  \includegraphicsaspectratio[0.3]{simplified-electric-network-diagram}
%  \caption{Simplified Electric Network}
%  \label{fig:simplified-electric-network-diagram}
%\end{figure}

%Suppose we need to calculate the following probabilities:
%\begin{description}
%  \item[$TOP_1$] = $P_1$ unavailable \emph{or} $P_2$ unavailable;
%  \item[$TOP_2$] = $P_1$ unavailable \emph{and} $P_2$ unavailable;
%  \item[$TOP_3$] = $P_1$ unavailable \emph{and} $P_2$ \emph{available};
%  \item[$TOP_4$] = Only one pump unavailable given only one electric line available.
%\end{description}

%We can construct two independent fault trees, $TP_1$ and $TP_2$, for the unavailability of $P_1$ and $P_2$ as: $TP_1 = P_1 \lor CP_1 \lor \parsin{D_1 \land \parsin{I \lor D_2}}$ and $TP_2 = P_2 \lor CP_2 \lor \parsin{D_2 \land \parsin{I \lor D_1}}$.
%$TOP_1$ and $TOP_2$ generate coherent fault trees, using $TP_1$ and $TP_2$.

\subsection{Probabilistic analysis of a non-coherent tree}
\label{sec:probabilistic-analysis-non-coherent-tree}

The work reported in~\cite{Andrews2001} shows an example of \iac{FT} with an explicit \ac{NOT} operator, the importance of such an operator, and how to calculate the probability of a critical failure.
The system is a leak protection system that has valves and sensors, and is depicted in \cref{fig:leak-protection-system}.
Valve $VAL$ closes a gas flow if a sensor detects a leak $L$.
If the valve is closed for a certain amount of time, the pressure on the system may increase, and then, a relief valve $PRV$ diverts the gas flow elsewhere.
%The possible failure are all internal failures: 
%

\begin{figure}[htb]
	\centering
	\includegraphicsaspectratio[0.5]{leak-protection-system}
	\caption{Leak Protection System architectural view}
	\label{fig:leak-protection-system}
\end{figure}

The undesired top-event is an ignition in room 1 ($TOP$).
As shown in~\cite{Andrews2001}, the structure expression of $TOP$ is:
%
\begin{equation}
TOP = L \land \left(\left(\lnot VAL \land PRV\right) \lor \left(VAL \land I_1\right)\right)\label{eq:leak-protection-system-structure-expression}
\end{equation}
%
For a coherent analysis, they use the consensus law to add a ``missing'' term.
In this case, the missing term is $L \land PRV \land I_1$.
This gives the final expression:
\begin{equation}
TOP = L \land \left(\left(\lnot VAL \land PRV\right) \lor \left(VAL \land I_1\right) \lor \left(PRV \land I_1\right)\right)\label{eq:leak-protection-system-extended-structure-expression}
\end{equation}
Finally, the probability for \cref{eq:leak-protection-system-structure-expression} is:
\begin{equation}
\probability{TOP} = P_L \times \left( P_{PRV} + P_{VAL} \times P_{I_1} - 
P_{PRV}\times P_{VAL}  \right)\label{eq:leak-protection-system-probability}
\end{equation}
%
where $P_x$ is the failure probability of $x$, $x \in \left\{L,PRV,VAL,I_1\right\}$.


\section{Systems nominal model and fault injection to obtain structure expressions}
\label{sec:faults-injection}

In this \lcnamecref{sec:faults-injection} we show how to obtain structure expressions\index{structure expression} from nominal models.
Nominal models are architectural models to represent the nominal behaviour (without failures) of a system.
Faults can be injected into a nominal model to simulate erroneous behaviour and observe which combinations of faults cause an unwanted operational mode.
The group of such combinations in a single expression is, in fact, the structure expression of the unwanted operational mode (\iacg{FT} structure expression of the system).

Control system modelling using \simulink block diagrams~\cite{MathWorks2010} is recommended in~\cite{Nise1992} and have been used by our industrial partner.
%We follow this recommendation in this work.
It is a complementary tool of \matlab~\cite{MathWorks2010c}.
In fact, it works as a graphical interface to \matlab.
A \simulink model has blocks and connections between these blocks, named signals.
Each block has inputs and outputs and an internal behaviour expressed by its mathematical formula, which defines a function of the inputs for each output.
There are many predefined blocks in the tool.
It is also possible to create new blocks or use subsystems that encapsulate other blocks.
A simulation adds extra parameters to a block diagram, like elapsed time and time between states.
The elapsed time of a simulation is an abstraction for the quantity of possible simulation states and the time between states is related to the lowest common denominator of the sample time.
Some components define different sample times, depending on their mode of operation.
Usually, the value for this property is set to \textsim{auto}, allowing \simulink to choose a proper value automatically.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio{acsBlockDiagrams}
  \caption{Block diagram of the ACS provided by \embraer (nominal model)}
  \label{fg:acsBlockDiagrams}
\end{figure}

Nowadays, control systems are usually composed of an electromechanical part and a processor.
\Cref{fg:acsBlockDiagrams} shows the components of a feedback system~\cite{AM2008} which was provided by \embraer.
In this system, the feedback behaviour is given by the \textsim{Controller} (1), \textsim{Actuator} (2) and \textsim{Sensor} (3). A command is received by the \textsim{Controller}, which sends a signal to the \textsim{Actuator} to start its movement.
The \textsim{Sensor} detects the actual position of the \textsim{Actuator} and sends it back to the \textsim{Controller}, which adjusts the given command to achieve the desired position. This loop (feedback) continues until the desired position given by the original command is reached.

\begin{figure}[htb]
  \centering
  \includegraphicsaspectratio[0.6]{blockDiagramMonitorInternals}
  \caption{Internal diagram of the monitor component (\cref{fg:acsBlockDiagrams}~(A)).}
  \label{fg:blockDiagramMonitorInternals}
\end{figure}

\Cref{fg:blockDiagramMonitorInternals} shows the internal elements of the monitor component (\cref{fg:acsBlockDiagrams}~(A)), which is used as a case study in \cref{chap:case-study} to illustrate our
strategy.
The outputs of the hardware elements are annotated with \textsim{HW}, which are the two power sources and an internal component of the monitor (switch command).

To perform a formal verification in a \simulink system model we use the model-checking tool \theac{FDR}.
It is a refinement checker for formal models written in the formal language \ac{CSPm}.
To verify a refinement\footnote{A refinement is an improvement in a specification. Such an improvement can be the reduction on the number of communications, bounding values or by a different representation of data.}, it takes two specifications:
\begin{alineasinline}
  \item a specification with more abstract properties, and
  \item an implementation with more concrete properties.
\end{alineasinline}
If a refinement does not hold (the implementation fails to refine the specification), \theac{FDR} shows counter-examples as traces of events.
The \ac{CSPm} language is suitable to model concurrent behaviour and is very expressive to model systems' states.
The work reported in~\cite{JMS+2011} translates a \simulink model to the \ac{CSPm} language.
%
The resulting \ac{CSPm} code (implementation) is then used to check if it meets functional requirements also encoded in \ac{CSPm} (specification).

In our previous work, reported in~\cite{DM2012}, we modified such a translation to perform fault injection using hardware annotations allowing a subsystem or part to ``break'' randomly.
%
We designed \iac{CSPm} process to act as an observer (specification), watching outputs of the nominal version and comparing to the outputs of the ``breakable'' version (with injected faults---the implementation) of the system.
%
When the \ac{CSPm} process of the model and the observer are loaded into the \acs{FDR} model-checker, counter-examples are generated for each output that differs from the nominal model, thus obtaining a \emph{sequence} of injected fault combinations that leads to the unexpected output, which are indeed \emph{fault traces}.

In what follows, injected faults and the top-level failure have generic names based on the names of the \simulink model blocks.
It is out of the scope of~\cite{DM2012} to define event names.

%TODO run in FDR4
For the \simulink model shown in~\cref{fg:blockDiagramMonitorInternals}, some representative fault traces are:

\begin{snippetcspm}[1]
TRACE 1:
failure.Hardware.N04_RelationalOperator.1.EXP.B.true
failure.Hardware.N04_RelationalOperator.1.ACT.B.false
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 2:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.true
failure.Hardware.N04_RelationalOperator.1.ACT.B.false
out.1.OMISSION

TRACE 3:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 4:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
out.1.OMISSION

TRACE 5:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
out.1.OMISSION

TRACE 6:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
out.1.OMISSION

TRACE 7:
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true

TRACE 8:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true

TRACE 9:
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION

TRACE 10:
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION

TRACE 11:
failure.Hardware.N04_MonIn2.1.EXP.I.5
failure.Hardware.N04_MonIn2.1.ACT.OMISSION
failure.Hardware.N04_RelationalOperator.1.EXP.B.false
failure.Hardware.N04_RelationalOperator.1.ACT.B.true
failure.Hardware.N04_MonIn1.1.EXP.I.5
failure.Hardware.N04_MonIn1.1.ACT.OMISSION
\end{snippetcspm}
%
where \verb$N04$ is the subsystem name of the monitor in the \simulink diagram, \verb$MonIn1$ (first input of the monitor), \verb$MonIn2$ (second input of the monitor), and \verb$RelationalOperator$ (switcher controller) are the names of the hardware components in the \simulink diagram.

We only show eleven counter-examples, but \acs{FDR} generates a total of 64 counter-examples for this system.
The other counter-examples are similar to the traces shown with different internal events.

To reuse \ac{hiphops}, which is based on \acp{SFT}, we ``remove'' the ordering information of the traces to generate a failure expression.
Each fault trace is abstracted as a conjunction (\ac{AND} combination of the inner events, thus losing the ordering information), and the several conjunction-based fault events are combined using \acp{OR} (disjunctions).
The result of the combination is a Boolean\index{Boolean Algebra} expression that represents the conditions that cause an undesirable output, the failure expression of the model.
With the \ac{algebra} proposed in this work we do not ``remove'' the ordering information, so we are able to use this information to generate or perform \ac{DFT} and \ac{TFT} analyses (\acp{TFT} have order-related operators, and it is shown in \cite{Merle2010,MRL2011b,MRL2011} that \acp{DFT} can be expressed by order-related operators).

If the failure expression is obtained for a whole system, it is indeed the structure expression\index{structure expression} of a \acl{FT} for a general failure as the top-level event.
Although it is possible to obtain the failure expression for a larger system, it may be impractical due to state-space explosion in \ac{CSPm} model analysis.
Thus it should be used for components and subsystems or small systems following \ac{hiphops} compositional structure.
%
%failure expression is used as the input of the strategy presented in~\cite{MJG+2010}.
Using failure expression as subsystem annotations in~\cite{PMS+2001}, it is possible to obtain structure expressions\index{structure expression} for a larger system.
It is worth noting that the goal of the work reported in~\cite{DM2012} was to connect with \ac{hiphops}, which is based on static \aclp{FT}.
But we already knew that we had a richer fault modelling information than that presented in~\cite{DM2012} because we abstracted traces (which already capture fault events ordering) to create propositions (any fault events order combination).
%In the works reported in~\cite{APR+2013,AFP+2013,AIP+2014}, fault modelling was used to verify if a system model is fault tolerant with respect to undesirable critical failures.
%The faults were explicitly modelled, and the analysis starts after the preliminary analysis of faults.
%Instead of modelling faults directly in a model, it is possible to inject faults without explicit fault modelling.
%This allows the system to break in hardware parts.

%Each injected fault appears on the trace as two events: the expected (\verb$EXP$) value of the nominal system and the actual (\verb$ACT$) value used on the breakable system.
%For example, in \verb$TRACE 1$, the expected output of the switcher (\verb$N04_RelationalOperator$) is true, but the actual value is false.

To show how these traces become failure expression, let us abbreviate fault names as:
%
\begin{snippetcspm}[2]
A = failure.Hardware.N04_MonIn1.1
B = failure.Hardware.N04_MonIn2.1
S = failure.Hardware.N04_RelationalOperator
\end{snippetcspm}

So, for each trace, we obtain an expression:
\begin{align*}
\mathtt{TRACE\,1} &= S \land B\\
\mathtt{TRACE\,2} &= B \land S\\
\mathtt{TRACE\,3} &= A \land B\\
\mathtt{TRACE\,4} &= B \land A\\
\mathtt{TRACE\,5} &= A \land S\\
\mathtt{TRACE\,6} &= A \land S \land B\\
\mathtt{TRACE\,7} &= A \land B \land S\\
\mathtt{TRACE\,8} &= B \land A \land S\\
\mathtt{TRACE\,9} &= S \land A \land B\\
\mathtt{TRACE\,10} &= S \land B \land A\\
\mathtt{TRACE\,11} &= B \land S \land A\\
\end{align*}

And we combine them as a single Boolean\index{Boolean Algebra} expression:
%
$\mathtt{TRACE\,1} \lor \mathtt{TRACE\,2} \lor \mathtt{TRACE\,3} \lor \mathtt{TRACE\,4} \lor \mathtt{TRACE\,5} \lor \mathtt{TRACE\,6} \lor \mathtt{TRACE\,7} \lor \mathtt{TRACE\,8} \lor \mathtt{TRACE\,9} \lor \mathtt{TRACE\,10} \lor \mathtt{TRACE\,11}$, %
which by a traditional Boolean reduction strategy results in:
%
\[(A \land B) \lor (S \land (A \lor B))\]

\begin{sloppypar}
The above expression is exactly the same failure expression provided by \embraer if we use the following association (\cref{tbl:acsAnnotations}):
\begin{align*}
A &= \text{LowPower-In1}\\
B &= \text{LowPower-In2}\\
S &= \text{SwitchFailure}
\end{align*}
\end{sloppypar}

\begin{table}[t]
\renewcommand{\arraystretch}{1.3}
\caption{Annotations table of the ACS provided by \embraer}
\label{tbl:acsAnnotations}
\centering
\begin{tabularx}{\linewidth}{|c|c|c|X|}
\hline
\bfseries Component & \bfseries Deviation & \bfseries Port & \bfseries Annotation \\
\hline
PowerSource & LowPower & Out1 & PowerSourceFailure\\
\hline
Monitor & LowPower & Out1 & (SwitchFailure AND (LowPower-In1 OR LowPower-In2)) OR (LowPower-In1 AND LowPower-In2) \\
\hline
Reference & OmissionSignal & Out1 & ReferenceDeviceFailure OR LowPower-In1\\
\hline
\end{tabularx}
\end{table}

Note that when we combine each fault with \ac{AND} gates, we lose the information about order\footnote{In our previous work we designed the observer to ignore order as well, by making similar traces---with different ordering---the same size. Here we modified the observer specification to make similar traces with different sizes.}: $S \land B$ and $B \land S$ are equal, due to the commutative law of Boolean expressions.

Our strategy finds fault combinations $S$ and $B$ (in the sense of $S$ occurring before $B$) as well as $B$ and $S$ (in the sense of $B$ occurring before $S$) but abstracts this ordering information obtaining $B$ and $S$, which is equivalent to $S$ and $B$ in Boolean\index{Boolean Algebra} Algebra.
%
If $A$ fails before $S$, the system fails because it should switch to $B$, but the switcher is in a faulty state.
%
On the other hand, if $S$ fails before $A$, the switcher fails because it inadvertently switched to $B$ when $A$ was still operational.
%
When $A$ fails, nothing changes and the output of the system is obtained from $B$.

We also employed the strategy proposed in the work~\cite{DM2012} in another case study and obtained a weaker failure expression (that is, our expression considers more cases).
The failure expression provided by the engineers of \embraer was stronger because they considered that one component has a very low probability of failure and removed it from the analysis.
Our strategy on the other hand generates the weakest failure expression; the best qualitative solution possible. Obviously that by quantitative analysis we can obtain the same structure expression as provided by the engineers of \embraer.

\section{Isabelle/HOL}
\label{sec:isabelle}

%To generate the file:
%Start an Isabelle session (Cygwin terminal in Windows)
%Go to dir isabelle-hol-basic
%Run isabelle build -D .
\input{isabelle-hol-basic/output/document/Basic}

