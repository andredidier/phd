 \chapter{A free algebra to express structure expressions of ordered events}
\label{chap:algebra}

\todo{De Augusto: ``Este capítulo é desnecessariamente conciso, principalmente por se tratar da contribuição. Seria importante, na versão final, ilustrar cada conceito e propriedade com exemplos.   
Tem que destacar resultados importantes, como o fato da mecanização com Isabelle. Deveria ter uma seção ou um capítulo dedicado à mecanização, não incluindo tudo, obviamente, mas ilustrando um pequeno exemplo.''}

\todo{Explain the interaction of (i) fault-injection, (ii) theorem proving, and (iii) symbolic execution.}
\todo{dizer que nossa abordagem usa a abordagem similar à de expressões de estrutura, mas que tem o objetivo de dar uma semântica denotacional baseada em conjuntos}

Recall from \cref{sec:time-relations,sec:fault-trees} that fault events are statistically independent of one another.
The set-theoretical abstraction of structure expressions\index{structure expression} for \acp{SFT}~\cite[pp. VI-11]{VGR+1981} is very close to \iac{FBA}\index{Boolean Algebra!Free}, where each generator in \acp{FBA}\index{Boolean Algebra!Free} corresponds to a fault event symbol in \aclp{FT}.
In \acp{FBA}\index{Boolean Algebra!Free}, as generators are ``free'', they are independent of one another and Boolean\index{Boolean Algebra} formulas are written as a set of sets of possibilities, which are similar to the structure expressions\index{structure expression} of \acp{SFT}.
%This is equivalent to the disjunctive normal form, where each set is a minterm (conjunction) and the formula itself is the disjunction of minterms.

We showed in \cref{sec:fault-trees} that there is a consistent presence of order-based operators to analyse \acp{TFT} and \acp{DFT}, and that each approach describes a new algebra based on different representations of events ordering with similar theorems to reduce expressions to a normal form.

From the need to tackle events ordering, related to the failure traces we can obtain by applying the fault injection strategy we developed in~\cite{DM2012}, we defined a list-based algebra, called \acf{algebra}, to express and analyse systems considering events ordering.
We also provide a mapping from fault traces~\cite{DM2012} (from \ac{CSPm} models) to this algebra, shown in \cref{sec:mapping-cspm-algebra}.
The order-specific operations are expressed with a new operator ($\xbeforeop$) that we call \ac{XBefore}.

The set of sets for \acp{FBA}\index{Boolean Algebra!Free} is our proposed denotational semantics for Boolean\index{Boolean Algebra} algebras.
We use the concept of generators to propose the \ac{algebra} with a denotational semantics of a set of lists without repetition (\distinctlists).
The choice for lists is because this structure inherently associates a generator to an index, making implicit the representation of order.
These lists are composed of non-repeated elements (\distinctlists) because the events in \aclp{FT} are non-repairable.
Thus, they do not occur more than once.

The elements of a list have an implicit order number, but such an order number is different from the Sequence Number function used in~\cite{WP2009,Walker2009}.
Although different, the order number in lists is related to the concept that there should be no gaps of the indexes between consecutive events occurrence.
The structure of the lists ensures this restriction.
But it is different because order 0 (zero) in~\cite{WP2009,Walker2009} means non-occurrence.
It may cause a discontinuity because 0 to 1 is different of 1 to 2.
In \acp{FBA}\index{Boolean Algebra!Free} the non-occurrence of an event is just the absence of the event.
Thus we use the same representation of non-occurrence as absence of the event in \ac{algebra} to avoid this discontinuity.
For example, the following lists are all permutations of fault events $a$ and $b$ (the generators are $a$ and $b$):
\begin{description}
	\item[$\emptylist $: ] no fault occurs
	\item[$\listsin{a}$: ] fault $a$ occurs and $b$ does not
	\item[$\listsin{b}$: ] fault $b$ occurs and $a$ does not
	\item[$\listsin{a,b}$: ] fault $a$ occurs before $b$. Note that, $a$ has index $0$ and $b$ has index $1$.
	\item[$\listsin{b,a}$: ] fault $b$ occurs before $a$.
\end{description}

%The work reported in~\cite{MRL2011,Merle2010} uses continuous time and the relations of events is obtained from a ``date-of-occurrence'' function.
%It is related to the detection of an event as discussed in~\cref{sec:time-relations,sec:structure-expressions} and the useful information is in fact the order of occurrence of the events, not the date-of-occurrence itself.


%In our previous work, we used this technique of using fault injection to reuse a nominal model without explicit fault modelling, obtaining Boolean expressions of systems' failures, as we showed in \cref{sec:faults-injection}.
%The drawback of this approach is that fault events ordering information is lost because it is not relevant on the Boolean expressions extraction.

%We show reduction laws relating the XBefore operator to traditional Boolean operators.
%It is important to note that we support a NOT operator in our algebra.

%\usepackage{graphics} is needed for \includegraphics
%\begin{figure}[t]
%\begin{center}
  %\includegraphics[width=0.5\textwidth]{strategy}
%  \caption{Strategy overview}
%  \label{fig:overview}
%\end{center}
%\end{figure}

%It is defined as a set of all sets of \distinctlists, called $\algebraset$.
%Then we show that all Boolean operators takes elements from and into $\algebraset$.

%We now show the \ac{algebra} as a set of all possible formulas.
In the following we show the definitions and laws of our proposed \ac{algebra}.
To avoid repetition, let $S$, $T$ and $U$ be sets of \distinctlists.
A list $xs$ is distinct if it has no repeated element.
So, if $x$ is in $xs$, then it has a unique associated index $i$ and we denote it as $x = \nth{xs}{i}$, where $i \neq j$ and there is no $\nth{xs}{j}$ such that $x=\nth{xs}{j}$.
Furthermore, as we follow \iac{FBA}\index{Boolean Algebra!Free} characterisation, we also need to show that the generators are independent.

The \ac{algebra} form a free algebra similar to \acp{FBA}\index{Boolean Algebra!Free}.
\emph{Infimum} and \emph{Supremum} are denoted as set intersection ($\inter$) and union ($\union$) respectively.
The order within the algebra is defined as set inclusion ($\subseteq$).

To distinguish the permutations that are not defined in \ac{FBA}\index{Boolean Algebra!Free}, we need a new operator.
We give the definition of \ac{XBefore} ($\xbeforeop$) in terms of list concatenation, similar to the work reported in~\cite{DM2015}:
%
\begin{align}
\denote{\xbefore{S}{T}} = &
  \left\{~
    zs ~\middle|~ \exists~ xs, ys ~\bullet~ \parsin{\listset{xs}} \inter \parsin{\listset{ys}} = \{\} \land \right.\nonumber\\
  & \left. xs \in \denote{S} \land ys \in \denote{T} \land zs = \append{xs}{ys}
  ~\right\}\label{def:xbefore-append}
\end{align}
%
where the $\listset{}$ function returns the set of the elements of a list, $\append{}{}$ concatenates two lists, and $\denote{.}$ obtains the denotational semantics of the formula.

In some cases it is more intuitive to use the \ac{XBefore} definition in terms of lists slicing because it uses indexes explicitly.
%\Cref{thm:xbefore} shows that the two definitions are equivalent.
Lists slicing is the operation of taking or dropping elements, obtaining a sublist.
In slicing, the starting index is inclusive, and the ending one is exclusive.
Thus the first index is 0 and the last index is the list length.
For example, the list $\slice{xs}{0}{\length{xs}}$ is equal to the $xs$ list, where $\length{xs}$ is the list length.
We use the following notation for list slicing:
%
\begin{subequations}
\begin{align}
\slice{xs}{i}{j} &= \text{starts at $i$ and ends at $j-1$}\label{def:slice}\\
\sliceright{xs}{j} &= \slice{xs}{0}{j}\label{def:slice-right}\\
\sliceleft{xs}{i} &= \slice{xs}{i}{\length{xs}}\label{def:slice-left}
\end{align}
\end{subequations}

To simplify the use of list slicing, its definition includes the lower and upper bounds as $0$ and its length, respectively:
%
\begin{equation}
\slice{xs}{i}{j} = \slice{xs}{L}{U}
\end{equation}
%
where $L = \max{0,i}$ and $U = \min{j,\length{xs}}$.

List slicing and concatenation are complementary: concatenating two consecutive slices results in the original list:
\begin{equation}
\label{law:slice-append}
\forall~ i ~\bullet~ \append{\sliceright{xs}{i}}{\sliceleft{xs}{i}} = xs
\end{equation}

There is an equivalent definition of \ac{XBefore} with concatenation using lists slicing:
%
\begin{equation}
\label{def:xbefore-slice}
\denote{\xbefore{S}{T}} =
  \left\{~
    zs ~\middle|~ \exists~ i ~\bullet~ \sliceright{zs}{i} \in \denote{S} \land \sliceleft{zs}{i} \in \denote{T}
  ~\right\}
\end{equation}

A variable in \ac{algebra} is defined by one generator, and denotes its occurrence:
%
\begin{equation}
\label{def:var}
\denote{\var{x}} =
  \left\{~
    zs ~\middle|~ x \in zs
  ~\right\}
\end{equation}
%
where $\mathop{set}zs$ is the set of the elements of $zs$, and $x \in zs$ is defined as $x \in \mathop{set} zs$.

For example, for generators $a$ and $b$, we obtain the following denotational semantics:
%
\begin{subequations}
\begin{align}
\denote{\var{a}} = & \left\{\listsin{a}, \listsin{a,b}, \listsin{b,a}\right\}\label{eq:denotational-var-a}\\
%
\denote{\var{b}} = & \left\{\listsin{b}, \listsin{a,b}, \listsin{b,a}\right\}\label{eq:denotational-var-b}
\end{align}
\end{subequations}

Given this definition, we show a small example on how the \ac{XBefore} operator works:
%
\begin{align}
\text{For } zs = \listsin{} \text{, } &
  \listsin{} \notin \denote{\var{a}} \land 
  \listsin{} \notin \denote{\var{b}} 
  \implies\nonumber\\
  & \listsin{} \notin \denote{\xbefore{\var{a}}{\var{b}}} \nonumber\\
%%%%%
\text{For } zs = \listsin{a} \text{, } &
  \listsin{a} \in \denote{\var{a}} \land 
  \listsin{a} \notin \denote{\var{b}} \land 
  \listsin{} \notin \denote{\var{b}} 
  \implies\nonumber\\
  & \listsin{a} \notin \denote{\xbefore{\var{a}}{\var{b}}} \nonumber\\
%%%%%
\text{For } zs = \listsin{b} \text{, } &
  \listsin{b} \in \denote{\var{b}} \land
  \listsin{b} \notin \denote{\var{a}} \land 
  \listsin{} \notin \denote{\var{a}} 
  \implies\nonumber\\
  & \listsin{b} \notin \denote{\xbefore{\var{a}}{\var{b}}} \nonumber\\
%%%%%
\text{For } zs = \listsin{a,b} \text{, } &
  \listsin{a} \in \denote{\var{a}} \land 
  \listsin{b} \in \denote{\var{b}} 
  \implies\nonumber\\
  & \listsin{a,b} \in \denote{\xbefore{\var{a}}{\var{b}}} \nonumber\\
%%%%%
\text{For } zs = \listsin{b,a} \text{, } &
  \listsin{b} \notin \denote{\var{a}} \land 
  \listsin{} \notin \denote{\var{a}} \land 
  \listsin{b,a} \in \denote{\var{a}} \land\nonumber\\
  & \listsin{} \notin \denote{\var{b}} \land 
  \listsin{a} \notin \denote{\var{b}} \land
  \listsin{b,a} \in \denote{\var{b}}
  \implies\nonumber\\
  & \listsin{b,a} \notin \denote{\xbefore{\var{a}}{\var{b}}} \nonumber\\
%%%%%
\denote{\xbefore{\var{a}}{\var{b}}} = & \left\{\listsin{a,b}\right\}
\end{align}

Boolean\index{Boolean} operators are denoted as in \ac{FBA}:
\begin{subequations}
\begin{align}
\denote{S \land T} & = \denote{S} \inter \denote{T}\label{eq:denotational-inf}\\
%%%%%%%%%%%%%%%%%
\denote{S \lor T} & = \denote{S} \union \denote{T}\label{eq:denotational-sup}\\
%%%%%%%%%%%%%%%%%
\denote{\lnot S} & = \UNIV - \denote{S} \label{eq:denotational-complement}\\
%%%%%%%%%%%%%%%%%
\denote{\bot} &= \emptyset\label{eq:denotational-bot}\\
%%%%%%%%%%%%%%%%%
\denote{\top} &= \UNIV\label{eq:denotational-top}
\end{align}
\end{subequations}

$\UNIV$ is the universal set. 
It contains all permutations of the generators of size $0$ to the number of the generators.
%
We denote the set of generators $\generators(S)$ of a formula $S$ as:
\begin{equation}
\generators(S) = \bigcup_{xs ~\in~ \denote{S}} \listset{xs}\label{eq:generators}
\end{equation}
%
The generators of \ac{algebra} are $\generators(\UNIV)$, or simply $\generators$.
%
For example, if the generators are $a$ and $b$, then $\UNIV$ is:
%
\[
\left\{~ \listsin{}, \listsin{a}, \listsin{b}, \listsin{a,b}, \listsin{b,a} ~\right\}
\]


The following expressions are sufficient to define the \ac{algebra} in terms of an inductively defined set ($\algebraset$):
%
\begin{subequations}
\label{def:algebraset}
\begin{align}
\denote{\var x} & \in \algebraset & \text{Variable}\label{def:algebraset-var}\\
\denote{S} \in \algebraset \implies \denote{\lnot S} & \in \algebraset & \text{Complement, Negation}\label{def:algebraset-compl}\\
%%%%%%%%%%%%%%%%%
\denote{S} \in \algebraset \land \denote{T} \in \algebraset \implies \denote{S \land T} & \in \algebraset & \text{Intersection, \emph{Infimum}}\label{def:algebraset-inf}\\
%%%%%%%%%%%%%%%%%
\denote{S} \in \algebraset \land \denote{T} \in \algebraset \implies \denote{\xbefore{S}{T}} & \in \algebraset & \text{\ac{XBefore}}\label{def:algebraset-xbefore}\\
%%%%%%%%%%%%%%%%%
\intertext{Following these definitions, the expressions below are also valid for $\algebraset$:}
%%%%%%%%%%%%%%%%%
\UNIV &\in \algebraset & \text{Universal set, True}\label{def:algebraset-true}\\
\emptyset &\in \algebraset & \text{Empty set, False}\label{def:algebraset-false}\\
\denote{S} \in \algebraset \land \denote{T} \in \algebraset \implies \denote{S \lor T} &\in \algebraset & \text{Union, \emph{Supremum}}\label{def:algebraset-sup}
\end{align}
\end{subequations}

The \ac{NOT} operator is given in terms of $\UNIV$.
For example, for generators $a$ and $b$:
\begin{align}
\denote{\lnot \var{a}} = & \UNIV - \denote{\var{a}} & \text{by \cref{eq:denotational-complement}}\nonumber\\
%%%%%
= & \left\{ \listsin{}, \listsin{a}, \listsin{b}, \listsin{a,b}, \listsin{b,a} \right\} - \left\{\listsin{a}, \listsin{a,b}, \listsin{b,a}\right\} & \text{by \cref{eq:denotational-var-a}} \nonumber\\
%%%%%
= & \left\{\listsin{}, \listsin{b}\right\}
\end{align}
To avoid repetition, we abbreviate \cref{eq:denotational-complement} suppressing $\UNIV$. 
For example:
\[
\UNIV - A \equiv -A
\]

The following expressions are valid for generators $a$ and $b$ and are sufficient to show that the generators are independent:
%
\begin{subequations}
\label{eqs:generators-independence}
\begin{align}
%&\var a \subseteq \var b \iff a = b\label{eqs:generators-independence-subseteq-eq}\\
&\denote{\var{a}} = \denote{\var{b}} \iff a = b\label{eqs:generators-independence-eq-eq}\\
%%%%%%%%%%%%%%
&\denote{\var{a}} \not\subseteq - \denote{\var{b}}\\
%%%%%%%%%%%%%%
&\denote{\var{a}} \neq -\denote{\var{b}}\label{eqs:generators-independence-subseteq-neq-compl} \\
%%%%%%%%%%%%%%
&- \denote{\var{a}} \not\subseteq \denote{\var{b}}\\
%%%%%%%%%%%%%%
&- \denote{\var{a}} \neq \denote{\var{b}}\label{eqs:generators-independence-subseteq-compl-neq}
\end{align}
\end{subequations}

Expressions \cref{def:algebraset-var} to \cref{def:algebraset-sup} and \cref{eqs:generators-independence-eq-eq} to \cref{eqs:generators-independence-subseteq-compl-neq} implies that the \ac{algebra} without the \ac{XBefore} operator \cref{def:xbefore-append} forms a Boolean\index{Boolean Algebra} algebra based on sets of lists.
And this is also equivalent to \iac{FBA}\index{Boolean Algebra!Free} with the same generators.

In our previous work~\cite{DM2015} we stated a relation between \ac{XBefore} and \emph{supremum}, provided the operands are variables \cref{def:var}.
Now we generalise this relation in terms of abstract properties of the operands of the \ac{XBefore}.
We name these properties as \emph{temporal properties}.
%and show them in \cref{sec:temporal-properties}.

\section{Temporal properties (\emph{\tempotext})}
\label{sec:temporal-properties}

Temporal properties give a more abstract and less restrictive shape on the \ac{XBefore} laws.
They are abbreviations that some operators satisfy altogether or individually.
%These properties avoid the requirement that every operand of \ac{XBefore} should be a variable (\cref{def:var}).
%The properties are: $\tempo[1]{}$ (\cref{def:tempo1}), $\tempo[2]{}$ (\cref{def:tempo2}), $\tempo[3]{}$ (\cref{def:tempo3}), and $\tempo[4]{}$ (\cref{def:tempo4}). 
%\todo{Explain temporal properties with respect to Figure 1 about relation of events? At least make it clearer.}

The first temporal property is about disjoint split.
If the first part of a list is in a given set, then every remainder part is not.
So, if a generator is in the beginning of a list, it must not be at the end (and vice-versa).
%
\begin{equation}
\tempo[1]{S} = \forall~ i, j, zs ~\bullet~
i \le j \implies
\lnot \left(
\sliceright{zs}{i} \in \denote{S} \land \sliceleft{zs}{j} \in \denote{S}
\right)\label{def:tempo1}
\end{equation}
%
For example, let $zs = \listsin{z_0,z_1,z_2,z_3,z_4}$.
If $\listsin{z_0,z_1} \in \denote{S}$, thus $\listsin{z_3,z_4} \notin \denote{S}$.
Note that it is vague, but it is the first relation indication on the lists of $S$.
In this property, as $zs$ has no repeated elements, then there is no element that is in both sublists.

In what follows we show how variables satisfy $\tempo[]{}$ properties.
To avoid repetition, the denotational semantics of $\var{z_1}$ is considered for generators $z_1,z_2,z_3$:
%
\begin{align}
\denote{\var{z_1}} = & 
\left\{
\listsin{z_1}, 
\listsin{z_1,z_2},\listsin{z_2,z_1},
\listsin{z_1,z_3},\listsin{z_3,z_1},
\listsin{z_1,z_2,z_3},\listsin{z_1,z_3,z_2},
\right.
\nonumber\\
&
\left.
\listsin{z_2,z_1,z_3},\listsin{z_2,z_3,z_1},
\listsin{z_3,z_1,z_2},\listsin{z_3,z_2,z_1}
\right\}
\end{align}

We demonstrate that the property $\tempo[1]{}$ is satisfied:
\begin{align}
\listsin{z_1} \in \denote{S} \implies & 
\listsin{z_2} \notin \denote{S} \land
\listsin{z_3} \notin \denote{S} \land
\listsin{z_2,z_3}\notin \denote{S} \land
\listsin{z_3,z_2}\notin \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2} \in \denote{S} \implies &
\listsin{z_3} \notin \denote{S}\nonumber\\
%%%%%
\listsin{z_2,z_1} \in \denote{S} \implies &
\listsin{z_3} \notin \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_3} \in \denote{S} \implies &
\listsin{z_2} \notin \denote{S}\nonumber\\
%%%%%
\listsin{z_3,z_1} \in \denote{S} \implies &
\listsin{z_2} \notin \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2,z_3} \in \denote{S} \implies &
\listsin{} \notin \denote{S}\nonumber\\
%%%%%
&\ldots\nonumber
\end{align}

The second temporal property is about belonging to one sublist in the beginning or in the end:
%
\begin{equation}
\tempo[2]{S} = \forall~ i, zs ~\bullet~
zs \in \denote{S} \iff
\sliceright{zs}{i} \in \denote{S} \lor \sliceleft{zs}{i} \in \denote{S}\label{def:tempo2}
\end{equation}
%
For example, if a generator is in a list, then it must be at the beginning or at the end.
If $\listsin{z_0,z_1,z_2,z_3,z_4} \in \denote{S}$, thus either $\listsin{z_0}\in\denote{S}$, or $\listsin{z_1,z_2,z_3,z_4} \in \denote{S}$.
If $\listsin{z_0} \notin \denote{S}$, thus $\listsin{z_1,z_2,z_3,z_4} \in \denote{S}$.
Then, either $\listsin{z_1} \in \denote{S}$ or $\listsin{z_2,z_3,z_4} \in \denote{S}$, and so forth.
For variable $\var{z_1}$:
%
\begin{align}
\listsin{z_1} \in \denote{S} \iff &
  \listsin{z_1} \in \denote{S} \lor \listsin{} \in \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2} \in \denote{S} \iff &
  \listsin{z_1} \in \denote{S} \lor \listsin{z_2} \in \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2,z_3} \in \denote{S} \iff &
  \left(\listsin{z_1} \in \denote{S} \lor \listsin{z_2,z_3} \in \denote{S}\right) \land\nonumber\\
  &\left(\listsin{z_1,z_2} \in \denote{S} \lor \listsin{z_3} \in \denote{S}\right)
  \nonumber\\
%%%%%
\listsin{z_2,z_1,z_3} \in \denote{S} \iff &
  \left(\listsin{z_2} \in \denote{S} \lor \listsin{z_1,z_3} \in \denote{S}\right) \land\nonumber\\
  &\left(\listsin{z_2,z_1} \in \denote{S} \lor \listsin{z_3} \in \denote{S}\right)
  \nonumber\\
& \ldots\nonumber
\end{align}

%
%\begin{definition}[\Tempotext 2, belongs to one sublist in the beginning or at the ending]
%\label{def:tempo2}
%Let $S$ be a set of \distinctlists:
%\end{definition}
%

The third temporal property is about belonging to one sublist in the middle.
If a generator belongs to a sublist between $j$ and $i$, then it belongs to the sublist that starts at the first position and ends in the $j^{th}$ and to the sublist that starts at $i^{th}$ and ends at the last position (both sublists contain the sublist in the middle).
%
\begin{align}
\tempo[3]{S} &= \forall~ i, j, zs ~\bullet~
j < i \implies \nonumber\\
&\left(
\slice{zs}{j}{i} \in \denote{S} \iff \sliceright{zs}{i} \in \denote{S} \land \sliceleft{zs}{j} \in \denote{S}
\right)\label{def:tempo3}
\end{align}
%
For example, if $\listsin{z_1,z_2,z_3} \in \denote{S}$, then both $\listsin{z_0,z_1,z_2,z_3}$ and $\listsin{z_1,z_2,z_3,z_4} \in \denote{S}$.
For a variable $\var{z_1}$:
%
%\begin{definition}[\Tempotext 3, belongs to the middle of a sublist]
%\label{def:tempo3}
%Let $S$ be a set of \distinctlists:
%\end{definition}
%
\begin{align}
\listsin{z_1} \in \denote{S} \iff &
  \listsin{z_1} \in \denote{S} \land \listsin{z_1} \in \denote{S}\land\nonumber\\
  & \listsin{z_2,z_1} \in \denote{S} \land \listsin{z_1} \in \denote{S} \land\nonumber\\
  & \listsin{z_3,z_1} \in \denote{S} \land \listsin{z_1} \in \denote{S} \land\nonumber\\
  & \listsin{z_1} \in \denote{S} \land \listsin{z_1,z_2} \in \denote{S} \land\nonumber\\
  & \listsin{z_1} \in \denote{S} \land \listsin{z_1,z_3} \in \denote{S} \land\nonumber\\
  & \listsin{z_2,z_1} \in \denote{S} \land \listsin{z_1,z_3} \in \denote{S}\land\nonumber\\
  & \listsin{z_3,z_1} \in \denote{S} \land \listsin{z_1,z_2} \in \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2} \in \denote{S} \iff &
  \listsin{z_3,z_1,z_2} \in \denote{S} \land \listsin{z_1,z_2} \in \denote{S}\nonumber\\
  & \listsin{z_1,z_2} \in \denote{S} \land \listsin{z_1,z_2,z_3} \in \denote{S}\nonumber\\
%%%%%
  & \ldots\nonumber
\end{align}

Finally, if a generator belongs to a list, then there is a sublist of size one that contains the generator.
%
\begin{equation}
\tempo[4]{S} = \forall~ zs ~\bullet~ zs \in \denote{S} \iff (\exists~ i ~\bullet~ \slice{zs}{i}{\left(i+1\right)} \in \denote{S})\label{def:tempo4}
\end{equation}
%
If list $zs=\listsin{z_0,z_1,z_2,z_3,z_4} \in \denote{S}$, then one list $\listsin{z_i} \in \denote{S}$, where $i \in \left\{0,\ldots,4\right\}$.
For a variable $\var{z_1}$:
%
%\begin{definition}[\Tempotext 4, belongs to one sublist of size one]
%\label{def:tempo4}
%Let $S$ be a set of \distinctlists:
%\end{definition}
%
\begin{align}
\listsin{z_1} \in \denote{S} \iff 
  & \listsin{z_1} \in \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2} \in \denote{S} \iff
  & \listsin{z_1} \in \denote{S} \lor \listsin{z_2} \in \denote{S}\nonumber\\
%%%%%
\listsin{z_1,z_2,z_3} \in \denote{S} \iff
  & \listsin{z_1} \in \denote{S} \lor \listsin{z_2} \in \denote{S} \lor \listsin{z_3} \in \denote{S}\nonumber\\
%%%%%
  & \ldots\nonumber
\end{align}

In general, for any generator $z$, the following is valid:
%
\begin{equation}
\label{law:var-tempo}
\tempo[1]{\left(\var{z}\right)} \land
\tempo[2]{\left(\var{z}\right)} \land
\tempo[3]{\left(\var{z}\right)} \land
\tempo[4]{\left(\var{z}\right)}
\end{equation}

We abbreviate \cref{law:var-tempo} as:
\begin{equation}
\tempo{S} = \tempo[1]{S} \land \tempo[2]{S} \land \tempo[3]{S} \land \tempo[4]{S}
\end{equation}

\begin{sloppypar}
In our previous work~\cite{DM2015} we used set difference to specify the \ac{XBefore} operator.
Provided $\tempo[1]{S}$ and $\tempo[1]{T}$, \ac{XBefore} in~\cite{DM2015} is equivalent to \cref{def:xbefore-append}:
%
\begin{align}
\denote{\xbefore{S}{T}} = &\left\{ zs ~\middle|~ \exists xs, ys ~\bullet~ xs \in \denote{S}-\denote{T} \land ys \in \denote{T}-\denote{S} \land \right.\nonumber\\
& \left. \distinct{zs} \land zs = \append{xs}{ys} \right\}\label{law:old-xbefore}
\end{align}
\end{sloppypar}

Other expressions also meet one or more temporal properties:
\begin{subequations}
\begin{align}
\tempo[1]{S} \land \tempo[1]{T} & \implies \tempo[1]{\parsin{S \land T}}\label{law:tempo1-inter}\\
\tempo[3]{S} \land \tempo[3]{T} & \implies \tempo[3]{\parsin{S \land T}}\label{law:tempo3-inter}\\
\tempo[2]{S} \land \tempo[2]{T} & \implies \tempo[2]{\parsin{S \lor T}}\label{law:tempo2-union}\\
\tempo[4]{S} \land \tempo[4]{T} & \implies \tempo[4]{\parsin{S \lor T}}\label{law:tempo4-union}
\end{align}
\end{subequations}

\section{\acs*{XBefore} laws}
\label{sec:xbefore-laws}

We now show some laws to be used in the algebraic reduction of \ac{algebra} formulas.
The laws follow from the definition of \ac{XBefore}, from events independence, and from the temporal properties.

We use a normal form similar to the \ac{DNF} of Boolean\index{Boolean Algebra} algebra.
In \ac{DNF} each sub-expression is a minimal cut set\index{Minimal Cut!Sets} for \ac{SFT}.
In our normal form, also called \ac{DNF}, we allow \acp{AND}, \acp{NOT}, and \acp{XBefore} to be in the sub-expressions.
Each sub-expression is a set of minimal cut sequences\index{Minimal Cut!Sequences} for \ac{TFT} and \ac{DFT}.
The following formulas are in \ac{DNF}:
%
\begin{align*}
&\parsin{A \land \lnot B \land \lnot C} \lor \parsin{\xbefore{\parsin{\xbefore{A}{B}}}{C}}\\
&\xbefore{A}{B}\\
&\xbefore{\xbefore{A}{B}}{C}
\end{align*}
%
The following formulas are \emph{not} in \ac{DNF}:
%
\begin{align*}
&A \lor B\\
&A \land B\\
&-\parsin{A \lor B}\\
&A \land \parsin{B \lor C}\\
&\xbefore{A}{\parsin{B \lor C}}\\
&\xbefore{A}{\parsin{B \land C}}
\end{align*}

\begin{sloppypar}
But to transform the last two formulas into \ac{DNF}, one can use \cref{thm:xbefore-sup-1,thm:xbefore-sup-2,thm:xbefore-inf-1,thm:xbefore-inf-2}, for instance.
The \ac{DNF} is clearer with the mapping function from denotational semantics to a formula $\formulaof{.}$ presented in \cref{sec:algebras-soundness-and-completeness}.
\end{sloppypar}

We define events independence ($\independenteventsop$) as the property that one operand does not imply the other.
For example, we need to avoid that the operands of \ac{XBefore} are $\var{a}$ and $\var{a} \lor \var{b}$ (it results in $\emptyset$, see \cref{thm:xbefore-not-idempotent}).
%
\begin{equation}
\label{law:independent-events}
\independentevents{S}{T} = \forall i, zs ~\bullet~
  \lnot \left(
    \slice{zs}{i}{\left(i+1\right)} \in \denote{S} \land
    \slice{zs}{i}{\left(i+1\right)} \in \denote{T}
  \right)
\end{equation}

\begin{sloppypar}
For generators $a$ and $b$ and the denotational semantics of $\var{a}$ and $\var{b}$ (see \cref{eq:denotational-var-a,eq:denotational-var-b}), it is easy to check that $\independentevents{\var{a}}{\var{b}}$ is satisfied, and $\independentevents{\var{a}}{\left(\var{a} \lor \var{b}\right)}$ is not.
Essentially if the formulas contain independent events one must not imply on the other on the occurrence of individual events ($\slice{zs}{i}{\left(i+1\right)}$).
\end{sloppypar}


The absence of occurrences ($\emptyset$, the empty set of $\algebraset$) is a ``0'' for the \ac{XBefore} operator.
The negation of all events ($\left\{\left[\right]\right\}$, a formula with the empty list) is a ``1'' for the \ac{XBefore} operator.
%
\begin{subequations}
\begin{align}
\xbefore{\bot}{S} =&~
  \bot &
  %\text{left-false-absorb}
  \label{thm:xbefore-of-false-1}\\
%
\xbefore{S}{\bot} =&~
  \bot &
  %\text{right-false-absorb}
  \label{thm:xbefore-of-false-2}\\
%
\tempo[1]{S} \implies \xbefore{\neutral}{S} =&~
  S &
  %\text{left-neutral-absorb}
  \label{thm:xbefore_neutral_1}\\
%
\tempo[1]{S} \implies \xbefore{S}{\neutral} =&~
  S &
  %\text{right-neutral-absorb}
  \label{thm:xbefore_neutral_2}\\
%
\left(\xbefore{S}{T}\right) \lor S =&~ S &
  %\text{left-union-absorb}
  \label{thm:xbefore-sup-absorb-1}\\
%
\left(\xbefore{T}{S}\right) \lor S =&~ S &
  %\text{right-union-absorb}
  \label{thm:xbefore-sup-absorb-2}\\
%
\tempo[1]{S} \implies
  \xbefore{S}{S} =&~
  \bot &
  %\text{non-idempotent}
  \label{thm:xbefore-not-idempotent}\\
%
\tempo[1]{S}\land\tempo[1]{T}\land \tempo[1]{U}\implies&\nonumber\\
  \xbefore{S}{(\xbefore{T}{U})} =&~
  \xbefore{(\xbefore{S}{T})}{U} &
  %\text{associativity}
  \label{thm:xbefore-associativity}
%
\end{align}
\end{subequations}
%
The \ac{XBefore} is absorbed by one of the operands: if one of the operands may happen alone, thus the order with any other operand is irrelevant.
However, an event cannot come before itself, thus \ac{XBefore} is not idempotent.
The \ac{XBefore} is associative.

To allow formula reduction we need the relation of \ac{XBefore} to the other Boolean\index{Boolean Algebra} operators.
First we use the \ac{XBefore} as operands of \ac{OR} and \ac{AND}.
%
\begin{subequations}
\begin{align}
\tempo[1]{S} \land \tempo[1]{T}&\implies\nonumber\\
  \parsin{\xbefore{S}{T}} \land \parsin{\xbefore{T}{S}} =&~
  \bot &
  %\text{inter-equiv-false}
  \label{thm:xbefore-inf-equiv-bot}\\
%
\tempo{S} \land \tempo{T} \land \independentevents{S}{T}&\implies\nonumber\\
  \parsin{\xbefore{S}{T}} \lor \parsin{\xbefore{T}{S}} =&~
  S \land T &
  %\text{union-equiv-inter}
  \label{thm:xbefore-sup-equiv-inf}
%
\end{align}
\end{subequations}
%
As \ac{XBefore} is not symmetric, the intersection of symmetrical \acp{XBefore} is empty.
The \ac{OR} of symmetrical \acp{XBefore} is a partition of the intersection of the operands.
For example, given generators $a$ and $b$ ($a \neq b$):
\begin{equation}
\left(\xbefore{\var{a}}{\var{b}}\right) \lor \left(\xbefore{\var{b}}{\var{a}}\right) = \var{a} \land \var{b}
\end{equation}
%
because $\var{a}$ and $\var{b}$ satisfy all temporal properties (\cref{law:var-tempo}) and are independent events.

In our previous work~\cite{DM2015}, we stated that $S$ and $T$ had to be variables, for example, of the form $\var{s}$ and $\var{t}$.
Now, each law requires that the operands satisfy some of the temporal properties, avoiding using variables explicitly.
%So, as variables satisfy all temporal properties and by \cref{thm:xbefore-sup-equiv-inf}, our theorem ``Exclusive before \emph{supremum}'' is still valid.

Expressions with Boolean\index{Boolean Algebra} operators are used as operands of the \ac{XBefore} in the following laws.
%
\begin{subequations}
\label{thms:xbefore-boolean}
\begin{align}
\xbefore{\left(S \lor T\right)}{U} =&~
  \parsin{\xbefore{S}{U}} \lor \parsin{\xbefore{T}{U}} &
  %\text{left-union-dist}
  \label{thm:xbefore-sup-1}\\
%%%%%
\xbefore{S}{\left(T \lor U\right)} =&~
  \parsin{\xbefore{S}{T}} \lor \parsin{\xbefore{S}{U}} &
  %\text{right-union-dist}
  \label{thm:xbefore-sup-2}\\
%%%%%
\tempo{S} \land \tempo{T} \land \independentevents{S}{T} & \implies\nonumber \\
  \xbefore{\left(S \land T\right)}{U} =&~
  \parsin{\xbefore{\xbefore{S}{T}}{U}} \lor \nonumber\\
  &\parsin{\xbefore{\xbefore{T}{S}}{U}} &
  %\text{left-inter-dist}
  \label{thm:xbefore-inf-1}\\
%%%%%
\tempo{T} \land \tempo{U} \land \independentevents{T}{U} & \implies \nonumber\\
  \xbefore{S}{\left(T \land U\right)} =&~
  \parsin{\xbefore{S}{\xbefore{T}{U}}} \lor \nonumber\\
  &\parsin{\xbefore{S}{\xbefore{U}{T}}} &
  %\text{right-inter-dist}
  \label{thm:xbefore-inf-2}\\
%%%%%
\tempo[2]{S} \implies S \land \parsin{\xbefore{T}{U}} =&~
  \parsin{\xbefore{\parsin{S \land T}}{U}} \lor \nonumber\\
  &\parsin{\xbefore{T}{\parsin{S \land U}}} &
  %\text{unordered}
  \label{thm:and_xbefore_equiv_or_xbefore}\\
%%%%%
\tempo[1]{T} \land \tempo[3]{T} &\implies\nonumber\\
  \xbefore{S}{T} \land \xbefore{T}{U} =&~
  \xbefore{\left(\xbefore{S}{T}\right)}{U}
  & 
  %\text{inter-transitivity}
  \label{thm:inf_xbefore_trans}\\
%%%%%
\independentevents{S}{T} \land \tempo[1-4]{S} \land \tempo[1-4]{T} & \implies\nonumber\\
  S \land \left(\xbefore{S}{T}\right) =&~ \xbefore{S}{T}
  \label{thm:xbefore_inf_absorb_1}\\
%%%%%
\independentevents{S}{T} \land \tempo[1-4]{S} \land \tempo[1-4]{T} & \implies\nonumber\\
  S \land \left(\xbefore{T}{S}\right) =&~ \xbefore{T}{S}
  \label{thm:xbefore_inf_absorb_2}
\end{align}
\end{subequations}
%
\ac{XBefore} is distributive over \ac{OR}.
On the other hand, the \ac{AND} is not.
The \ac{AND} of an event with an \ac{XBefore} states that such an event can occur in any order within the events in the \ac{XBefore}.
Lastly, the \ac{XBefore} is transitive with preconditions over the intermediary variable.

The law name, unordered, of \cref{thm:and_xbefore_equiv_or_xbefore} is clearer if we expand \cref{thm:and_xbefore_equiv_or_xbefore} with \cref{thm:xbefore-inf-1} and  \cref{thm:xbefore-inf-2}:
%
%\begin{subequations}
\begin{align}
\tempo{S} \land \tempo{T} \land \nonumber\\
  \tempo{U} \land \independentevents{S}{T} \land \independentevents{S}{U} & \implies \nonumber\\
  S \land \parsin{\xbefore{T}{U}} = &
  \parsin{\xbefore{\xbefore{S}{T}}{U}} \lor \nonumber\\
  & \parsin{\xbefore{\xbefore{T}{S}}{U}} \lor \nonumber\\
  & \parsin{\xbefore{\xbefore{T}{U}}{S}} &
  \text{expanded-unordered}
  \label{thm:and_xbefore_equiv_or_xbefore_expanded}
%\\
%
%\tempo[2]{S} \implies S \inter \parsin{\xbefore{S}{T}} =& \xbefore{S}{T} &
%  \text{left-inter-absorb}
%  \label{thm:xbefore-inf-absorb-1}\todo{Prove this in Isabelle}\\
%
%
%\tempo[2]{S} \implies S \inter \parsin{\xbefore{T}{S}} =& \xbefore{T}{S} &
%  \text{right-inter-absorb}
%  \label{thm:xbefore-inf-absorb-2}\todo{Prove this in Isabelle}
\end{align}
%\end{subequations}
%
%From \cref{thm:xbefore-not-idempotent} and \cref{thm:and_xbefore_equiv_or_xbefore}, intersection and \ac{XBefore} also have an absorption law.

In what follows we show properties of \ac{XBefore} related to the \ac{NOT} operators.
%
\begin{subequations}
\label{thms:xbefore-not}
\begin{align}
\independentevents{S}{T} \land
\tempo[1-4]{S} \land \tempo[1-4]{T} & \implies \nonumber\\
  \lnot \left(\xbefore{S}{T}\right) =&
  \left(\lnot S \lor \lnot T\right) \lor \left(\xbefore{T}{S}\right)
  \label{thm:not_xbefore}\\
%%%%%
\tempo[1]{S} \land \tempo[2]{T} & \implies \nonumber\\
  \xbefore{\lnot S}{T} = &~ T\label{thm:not_1_xbefore_equiv}\\
%%%%%
\tempo[1]{T} \land \tempo[2]{S} & \implies \nonumber\\
  \xbefore{S}{\lnot T} = &~ S\label{thm:not_2_xbefore_equiv}\\
%%%%%
\independentevents{S}{T} \land \tempo[1-4]{S} \land \tempo[1-4]{T} & \implies\nonumber\\
  \left(S \land \lnot T\right) \lor \left(\xbefore{S}{T}\right) = &
  S \land \lnot\left(\xbefore{T}{S} \right)
  \label{thm:xbefore_sup_compl_inf_absorb1}
%    sup (inf a (-b)) (xbefore a b) = inf a (- (xbefore b a))
\end{align}
\end{subequations}

\section{Soundness and completeness}
\label{sec:algebras-soundness-and-completeness}

The soundness and completeness in \ac{algebra} are obtained as in traditional logic: from the set of all formulas (syntax), and from the set of all formulas' representation (denotational semantics).

To show equivalence of a formula and its denotational we need two mapping functions: one that takes a formula, and returns its set of distinct lists, and another that takes a set of distinct lists and returns a formula.
The function that maps a formula to its denotational semantics is the function $\denote{.}$, shown in the beginning of this \lcnamecref{chap:algebra}:
%
\begin{align}
\denote{\bot} = &~ \left\{\right\}\nonumber\\
%%%%%
\denote{\top} = &~ \UNIV\nonumber\\
%%%%%
\denote{\neutral} = &~ \left\{\listsin{~} \right\}\nonumber\\
%%%%%
\denote{\var x} = &~ 
	\left\{~ 
		dl \bullet x \in \listset{dl}  
	~\right\}\nonumber\\
%%%%%
\denote{X \lor Y} = &~ \denote{X} \union \denote{Y}\nonumber\\
%%%%%
\denote{X \land Y} = &~ \denote{X} \inter \denote{Y}\nonumber\\
%%%%%
\denote{\lnot X} = &~ - \denote{X}\nonumber\\
%%%%%
\denote{\xbefore{X}{Y}} = &~
	\left\{~
		dl ~\middle|~ \exists~ i ~\bullet~ \sliceright{dl}{i} \in \denote{X} \land \sliceleft{dl}{i} \in \denote{Y}
	~\right\}
\end{align}

\begin{proposition}[Soundness]
Let $L$ be the set of all formulas in \ac{algebra}, and $M$ the set of all sets of \distinctlists, then:

\begin{align}
\forall~ f ~\in~ L ~\bullet~ \denote{f} ~\in~ M
\end{align}
\end{proposition}

The mapping function from a set of lists to a formula is given in terms of the \iac{DNF}\index{DNF} of \ac{algebra} and a set of generators $S$:
%%%%%
\begin{align}
\listformulaof{\listsin{~}} = &~ \neutral\nonumber\\
%%%%%
\listformulaof{\listsin{x}} = &~ \var{x} \land \bigwedge_{y ~\in~ \generators\left(S\right)-\left\{x\right\}} \lnot \var{y} \nonumber\\
%%%%%
\listformulaof{\cons{x}{dl}} = &~ \xbefore{\var{x}}{\listformulaof{dl}}\nonumber\\
%%%%%
\formulaof{\left\{~\right\}} = &~ \bot\nonumber\\
%%%%%
\formulaof{X} = &~ \bigvee_{dl ~\in~ X} \listformulaof{dl}
\end{align}

\begin{proposition}[Completeness]
Let $L$ be the set of all formulas in \ac{algebra}, and $M$ the set of all sets of \distinctlists, then:

\begin{align}
\forall~ X ~\in~ M ~\bullet~ \formulaof{X} ~\in~ L
\end{align}
\end{proposition}

\section{Qualitative and quantitative analyses}
\label{sec:qualitative-quantitative-analyses}

In \cref{sec:fault-trees} we showed the kind of results that are obtained in \ac{FTA}.
In this \lcnamecref{sec:qualitative-quantitative-analyses} we show how to formalize these \ac{FTA} results as: 
\begin{alineasinline}
  \item \ac{MCSeq}, the number of fault elements in the minimal sequences that cause a root failure, and 
  \item the root probability, given the availability of basic fault occurrences probabilities.
\end{alineasinline}
%
These attributes are the most representative, but other ones can be modelled similarly.

\subsection{\Acl{MCSeq}}

Recall from the beginning of this \lcnamecref{chap:algebra} that the denotational semantics of \ac{algebra} is a set of \distinctlists.
Thus, each list has no repeated elements and represent a possible combination of faults that causes the root failure.
\Acp{MCSeq} are those \distinctlists with the least length, defined in what follows.

\begin{definition}[Minimal cut sequences]
Let $S$ be a formula in \ac{algebra}.
Its \aclp{MCSeq} ($\mcseqop$ of $S$) are:
%
\begin{equation}
\mcseq{S} = \left\{~ xs ~\middle|~ xs \in \denote{S} ~\bullet~ \length{xs} = min_S ~\right\}
\end{equation}
%
where
\[
min_S = \Min{\left\{~ \length{xs} ~\middle|~ xs \in \denote{S} ~\right\}}
\]
%
and $\Minop$ returns the least sequence length in the given set.
\end{definition}

For example, the \acp{MCSeq} of $\xbefore{\var{a}}{\left(\var{b} \lor \var{c}\right)}$ (for generators $a$, $b$, and $c$) are:
%
\begin{equation}
\mcseq{\xbefore{\var{a}}{\left(\var{b} \lor \var{c}\right)}} = \left\{ \listsin{a,b}, \listsin{a,c} \right\}\label{eq:mcseq-a-and-b}
\end{equation}

\Cref{eq:mcseq-a-and-b} states that it is sufficient that $a$ occurs before $b$, or $a$ occurs before $c$, to cause the top event.
Other lists in the denotational semantics of the formula are $\listsin{a,b,c}$ and $\listsin{a,c,b}$, but these are not minimal.

\subsection{Root probability}

The work reported in~\cite{Merle2010} shows how to calculate the probability of \iac{PAND} gate as:
%
\begin{align}
P\left(t\right) & = \probabilityt{T_1 \le T_2 }\nonumber\\
& = \int_0^t P'_2(t_2) \int_0^{t_2} P'_1(t_1) dt_1 dt_2 \nonumber\\
& = \int_0^t P'_2(t_2) P_1(t_2) dt_2\label{eq:pand-probability}
\end{align}
%
where $P_1$ and $P_2$ are the probabilities of the occurrences of the first and the second faults (cumulative distribution function), respectively, and $T_1$ and $T_2$ are the times the first and the second faults occur.
The general case (reported in~\cite{FAR1976}) of \iac{PAND} gate with $n$ inputs is the probability of the sequence of faults $f_i$, $i \in \left\{~1, \ldots, n~\right\}$:
%
\begin{align}
\probability{\left[f_1,f_2\ldots,f_{n-1},f_n\right]} = \nonumber\\ \int_0^t\fiti{n}\int_0^{t_n}\fiti{n-1}\ldots\int_0^{t_3}\fiti{2}
 \int_0^{t_2}\fiti{1} dt_1 dt_2\ldots dt_{n-1}  dt_n\label{eq:general-pand-probability}
\end{align}
%
where $P_i$ is the cumulative probability function of fault $f_i$.
\todo{ACM: deixar mais claro o que o cumulative probability function}

For \ac{algebra}, our proposal for probability calculation is defined in terms of the probability of \ac{PAND} gates.
The reason is that our semantics is defined in terms of a set of lists (or sequences) of fault occurrences.
The main difference from the \ac{PAND} calculation as reported in~\cite{FAR1976} is that repeated situations must be removed.
For example, the probability of $\denote{\xbefore{\var{f_1}}{\var{f_2}}}$ contains the situations in which $f_1$ occurs before $f_2$ \emph{and} $f_3$ does not occur, or $f_3$ occurs in some time: $\probability{\left[f_1,f_2,f_3\right]}$, $\probability{\left[f_1,f_3,f_2\right]}$, and $\probability{\left[f_3,f_1,f_2\right]}$.
%
%To isolate these cases, we use the following definitions:
%
%\begin{subequations}
%\begin{align}
%\permutations{A} = & \left\{~ ys ~\middle|~ \listset{ys} \in A ~\right\}\label{eq:permutations}\\
%%%%%
%\filter{xs}{ys} = & ys / \left(\listset{ys} - \listset{xs}\right) \label{eq:filter}\\
%%%%
%\listsof{S}{xs} = & \left\{~ ys ~\middle|~ ys \in \denote{S} ~\bullet~xs = \filter{xs}{ys} ~\right\}\label{eq:listsof}
%\end{align}
%\end{subequations}
%
%where $ys / A$ removes the elements of $A$ in $ys$.

Using \cref{eq:general-pand-probability,eq:generators} we define the probability for a fault sequence as:
%
\begin{equation}
\denotationalprob{xs} = 
  \probability{xs} \times \prod_{f_j ~\in~ \generators - \listset{xs}} \left(1-P_j\left(t\right)\right)\label{eq:denotational-probability}
\end{equation}
%
%For example, to calculate $\denotationalprob{\left[f_1, f_2\right]}$ for set of generators $\left\{f_1,f_2,f_3\right\}$, we have:
%\begin{align*}
%\denotationalprob{\left[f_1,f_2\right]} = & \probability{\left[f_1,f_2\right]}
%- \probability{\left[f_1,f_2,f_3\right]}\nonumber\\
%%%%%%
%&- \probability{\left[f_1,f_3,f_2\right]}
%- \probability{\left[f_3,f_1,f_2\right]}
%\end{align*}
%
%In other words, the denotational probability gives the probability of the occurrence of the faults in the order of the list \emph{and no other fault occurs}.
%%%%
For example, for generators $f_1$, $f_2$, and $f_3$, $\denotationalprob{\left[f_1,f_2\right]} = \probability{\left[f_1,f_2\right]}\times\left(1-P_3(t)\right)$, which is the probability of $f_1$ occurring before $f_2$ and $f_3$ not occurring.

As the probability of each fault sequence is independent of each other, the probability of an \ac{algebra} formula is the sum of the denotational probabilities of its constituent lists.

\begin{definition}[Probability of a formula in \ac{algebra}]
Let $S$ be a formula in \ac{algebra}.
Then the probability of $S$, $\formulaprob{S}$, is given by:
%
\begin{equation}
\label{eq:formula-probability}
\formulaprob{S} = \sum_{xs \in \denote{S}}\denotationalprob{xs}
\end{equation}
\end{definition}

The interesting part behind the probabilistic calculus over the denotational semantics is that it is only about ordering of events.
It means that even if a formula contains \iac{NOT} operator, we still safely obtain a probability value, without worrying about complement probabilities as tackled in~\cite{Andrews2001}.
For example, the denotational semantics of $\lnot \var{f_1}$ (for generators $f_1$ and $f_2$) is:
%
\begin{align}
\denote{\lnot \var{f_1}} = &~ \UNIV - \denote{\var{f_1}} \nonumber\\
%%%%%
= &~ \UNIV - 
	\left\{
		\listsin{f_1},
		\listsin{f_1,f_2},
		\listsin{f_2,f_1}
	\right\}\nonumber\\
%%%%%
= &~ \left\{ 
		\emptylist,
		\listsin{f_1},
		\listsin{f_2},
		\listsin{f_1,f_2},
		\listsin{f_2,f_1}
	\right\} - 
	\left\{
	\listsin{f_1},
	\listsin{f_1,f_2},
	\listsin{f_2,f_1}
	\right\}
	\nonumber\\
= &~ \left\{\emptylist, \listsin{f_2} \right\}
\end{align}
%
and the probability of $\lnot \var{f_1}$ is:
%
\begin{align}
\formulaprob{\lnot \var{f_1}} = &~ \denotationalprob{\left[\right]} + \denotationalprob{\left[f_2\right]} & \text{by \cref{eq:formula-probability}} \nonumber\\
%%%%%%%%%%%%%
= &~ \probability{\left[\right]}\times\left(1 - P_1(t)\right)\times\left(1 - P_2(t)\right)\nonumber\\
& + \probability{\left[f_2\right]}\times\left(1 - P_1(t)\right) & \text{by \cref{eq:denotational-probability}} \nonumber\\
%%%%%%%%%%%%%
= &~ 1 \times \left(1- P_1(t)\right) \times \left(1 - P_2(t)\right)\nonumber\\
& + P_2(t) \times \left(1 - P_1(t)\right) & \text{by \cref{eq:general-pand-probability}}\nonumber\\
%%%%%%%%%%%%%
= &~ 1 - P_1(t)
\end{align}

The empty list is a special case and has value $1$.
It works as the universal complement probability of any other list.
When the empty list appears in a denotational semantics it means that the top-event occurs if no fault occurs.
%Thus its probability value depends on the value of the probabilities of all constituents be operational, which is \emph{usually} near $1$ (see~\cite{Andrews2001}).
%This is the only assumption in the calculations shown in this \lcnamecref{sec:qualitative-quantitative-analyses}.

We use the traditional probability calculations~\cite{Merle2010} as reference to calculate the probabilities of formulas in \ac{algebra}.
%\begin{subequations}
%\begin{align}
%\probability{\vari{1} \land \vari{2}} = & \Fit{1} \times \Fit{2}\label{eq:and-probability}\\
%\formulaprob{\vari{1} \lor \vari{2}} = & \Fit{1} + \Fit{2} - \Fit{1} \times \Fit{2}\label{eq:or-probability}
%\end{align}
%\end{subequations}
%
For example, the formula $\left(\xbefore{\var{f_1}}{\var{f_2}}\right) \lor \left(\xbefore{\var{f_2}}{\var{f_1}}\right)$, considering only the two generators ($f_1$ and $f_2$), has denotational semantics $\left\{\left[f_1, f_2\right], \left[f_2, f_1\right]\right\}$ and the probability of the formula is the probability of $\left[f_1, f_2\right]$ \emph{or} $\left[f_2, f_1\right]$ (but not both):
%
\begin{align}
\formulaprobop&\left\{\left(\xbefore{\var{f_1}}{\var{f_2}}\right) \lor \left(\xbefore{\var{f_2}}{\var{f_1}}\right)\right\}\nonumber\\
%%%%
=&\denotationalprob{\left[f_1,f_2\right]} + \denotationalprob{\left[f_2,f_1\right]} & \text{by \cref{eq:formula-probability}} \nonumber\\
%%%%
= &\probability{\left[f_1,f_2\right]} + \probability{\left[f_2,f_1\right]} & \text{by \cref{eq:denotational-probability}}\nonumber\\
%%%%
=&\int_0^t P'_2(x) P_1(x) dx + \int_0^t P'_1(x) P_2(x) dx & \text{by \cref{eq:pand-probability}} \nonumber\\
%%%%
= & \int_0^t \left(P'_2(x) P_1(x) + P'_1(x) P_2(x)\right) dx & \text{by sum of $\int$} \nonumber\\
%%%%
= & \int_0^t \left(P_1(x) P_2(x)\right)' dx & \text{by inv. deriv. product} \nonumber\\
%%%%
= & P_1(t) \times P_2(t)\label{eq:prob-xbefore-sup-equiv-inf}
\end{align}

In \cref{eq:prob-xbefore-sup-equiv-inf} we demonstrated that the probability of a formula $\left(\xbefore{\var{f_1}}{\var{f_2}}\right) \lor \left(\xbefore{\var{f_2}}{\var{f_1}}\right)$ is equal to the probability of the traditional \ac{AND} probability ($\var{f_1} \land \var{f_2}$).
This is expected as these two formulas are equivalent, as shown in \cref{thm:xbefore-sup-equiv-inf}.

Another example including complement is the formula $\var{f_1} \land \var{f_2} \land \lnot \var{f_3}$:
%
\begin{align}
S = & \var{f_1} \land \var{f_2} \land \lnot \var{f_3}\nonumber\\
%%%%%
\probability{S} = &
\denotationalprob{\left[f_1,f_2\right]} + \denotationalprob{\left[f_2,f_1\right]} 
  & \text{by \cref{eq:formula-probability}}\nonumber\\
%%%%%
= & \probability{\left[f_1,f_2\right]}\times \left(1 - P_3(t)\right)
+ \probability{\left[f_2,f_1\right]}\times \left(1 - P_3(t)\right)
	& \text{by \cref{eq:denotational-probability}}\nonumber\\
%%%%%
= & P_1(t) \times P_2(t) \times \left(1 - P_3(t)\right) & \text{by \cref{eq:prob-xbefore-sup-equiv-inf}}
\end{align}

Using \cref{eq:formula-probability}, and for generators $f_1$ and $f_2$, we demonstrate the equivalence to the probability of a traditional \ac{OR} operator, calculated using the denotational semantics:
%
\begin{align}
S = & \vari{1} \lor \vari{2}\nonumber\\
%%%
\formulaprob{S} = & \denotationalprob{\left[f_1\right]} +
  \denotationalprob{\left[f_2\right]} + \nonumber\\
  & \denotationalprob{\left[f_1,f_2\right]} +
  \denotationalprob{\left[f_2,f_1\right]}
  & \text{by \cref{eq:formula-probability}}
\nonumber\\
%%%%%%%%%%%
= &\probability{\left[f_1\right]}\times\left(1 - P_2(t)\right) + 
\probability{\left[f_2\right]}\times\left(1 - P_1(t)\right) +\nonumber\\
&P_1(t) \times P_2(t) & \text{by \cref{eq:prob-xbefore-sup-equiv-inf,eq:denotational-probability}}\nonumber\\
%%%%%%%%%%%
= & P_1(t) \times \left(1 - P_2(t)\right) + P_2(t) \times \left(1 - P_1\right) + \nonumber\\
  & P_1(t) \times P_2(t)\nonumber\\
= & P_1(t) + P_2(t) - P_1(t) \times P_2(t)
\end{align}

We show an equivalence using the formula probability $\formulaprobop$ for generators $f_1$ and $f_2$:
\begin{align}
\formulaprob{\var{f_1} \land \var{f_2}} = &~ \formulaprob{\var{f_1}} \times \formulaprob{\var{f_2}}\label{eq:formula-probability-of-inf}\\
%%%%%
\denotationalprob{\listsin{f_1,f_2}} + \denotationalprob{\listsin{f_2,f_1}} = &~
  \left(\denotationalprob{\listsin{f_1}} + 
     \denotationalprob{f_1,f_2} + 
     \denotationalprob{f_2,f_1}\right) \times\nonumber\\
  &~\left(\denotationalprob{\listsin{f_2}} + 
    \denotationalprob{f_1,f_2} + 
    \denotationalprob{f_2,f_1}\right)\nonumber\\
%%%%%
P_1(t) \times P_2(t) = &~ 
  \left(P_1(t) \times (1 - P_2(t)) + P_1(t) \times P_2(t)\right) \times\nonumber\\
  &~ \left(P_2(t) \times (1 - P_1(t)) + P_1(t) \times P_2(t)\right) \nonumber\\
%%%%%
= &~
  \left(P_1(t) - P_1(t)\times P_2(t) + P_1(t) \times P_2(t)\right) \times\nonumber\\
  &~ \left(P_2(t) - P_2(t) \times P_1(t)) + P_1(t) \times P_2(t)\right) \nonumber\\
%%%%%
= &~
  P_1(t) \times P_2(t)\nonumber
\end{align}

Finally, we propose that the formula probability calculation of a greater set of generators is the same of a smaller one.
For example, for $\var{f_1} \land \var{f_2}$ and generators $f_1$, $f_2$ ,and $f_3$:
\begin{align}
\formulaprob{\var{f_1} \land \var{f_2}} =&~
  \denotationalprob{\listsin{f_1,f_2}} +
  \denotationalprob{\listsin{f_2,f_1}} + \nonumber\\
  &~\denotationalprob{\listsin{f_1,f_2,f_3}} +
  \ldots +
  \denotationalprob{\listsin{f_3,f_2,f_1}} \nonumber\\
%%%%%
= &~ P_1(t) \times P_2(t) \times (1 - P_3(t)) + P_1(t) \times P_2(t) \times P_3(t)\nonumber\\
%%%%%
= &~ P_1(t) \times P_2(t) - P_1(t) \times P_2(t) \times P_3(t) + \nonumber\\
  &~ P_1(t) \times P_2(t) \times P_3(t)\nonumber\\
%%%%%
= &~ P_1(t) \times P_2(t)\label{eq:formula-probability-any-generators}
\end{align}
%
which is the same calculation as shown in \cref{eq:formula-probability-of-inf}.
Thus, the probability calculation is not sensitive to a particular set of generators.

\subsection{Formal acceptance criteria}
\label{sec:formal-acceptance-criteria}

To enable the formal verification of structure expressions we use the concept of \emph{acceptance criteria}.
Safety requirements are written in terms of the properties of \iac{FT}, for example: 
\begin{alineasinline}
  \item no single failure should cause a critical failure (the length the \acp{MCSeq} should be greater than $1$), or 
  \item the probability of all critical failure should be less than $P_x$.
\end{alineasinline}
To check these requirements we translate these requirements into a value and verify in the theorem prover.

For the two analysis shown in this \lcnamecref{sec:qualitative-quantitative-analyses}, we define the two acceptance criteria:
%
\begin{subequations}
\begin{align}
\lengthacceptance{F}{n} = &~ \Min{\left\{~ \length{xs} ~\middle|~ xs \in \denote{F} ~\right\}} > n & \text{length of \acp{MCSeq}}\\
%
\probacceptance{F}{P_x} = &~ \formulaprob{F} < P_x & \text{root-event probability}
\end{align}
\end{subequations}
%
Both equations have Boolean\index{Boolean} return value, which can be verified by a theorem prover.

Using the formal acceptance criteria, safety requirements as stated in the beginning of this section are:
%
\begin{description}
	\item[$\lengthacceptance{F}{1}$:] the minimum length of the \acp{MCSeq} of $F$ are higher than 1;
	\item[$\probacceptance{F}{10^{-9}}$: ] the probability of the top event of $F$ shall be less than $10^{-9}$.
\end{description}

The verification of the acceptance criteria is illustrated with the probability calculation of a formula in \cref{sec:top-event-probability-explicit-not}.

\section{Mapping \ac*{CSPm} traces to \ac*{algebra}}
\label{sec:mapping-cspm-algebra}

In our previous work~\cite{DM2012,Didier2012} we reported a strategy to inject faults in a \ac{CSPm} model generated from an architectural model of a system in \simulink.
Using a model-checker we were able to obtain failure traces with the injected faults, which we produced failure expressions in Boolean algebra.
Thus, the order-related information was lost, as there are no means to represent them in Boolean algebra\index{Boolean algebra}.
For example, a trace that represents the occurrence of $f_1$ before $f_2$ was written as the expression $\var{f_1} \land \var{f_2}$, which is the same as $\var{f_2} \land \var{f_1}$.

Using the same strategy, but now mapping the traces to \ac{algebra} we are able to analyse order-related failures.
In this section we show how to map the same failure traces obtained by the strategy reported in the work~\cite{DM2012} to \ac{algebra}.

The mapping function takes the set of traces as input and produces a structure expression in \ac{algebra}.
Each event in the traces becomes a variable, and each list becomes \iac{XBefore} with the conjunction (\acp{AND}) of the variables of the remaining generators.
The following recursive definitions describe the mapping function.
%
\begin{subequations}
\begin{align}
\tracetoalgebra{\trace{}} = &~ \top\label{eq:mapping-algebra-empty}\\
%
\tracetoalgebra{\trace{f}} = &~ \var{f}\label{eq:mapping-algebra-singleton}\\
%
\tracetoalgebra{\append{\trace{f_1}}{tr}} = &~
  \xbefore
    {\var{f_1}}
    {\tracetoalgebra{tr}}\label{eq:mapping-algebra-two-more-trace}\\
%
\tracetoalgebra{\left\{ tr_1, tr_2, \ldots, tr_n  \right\}} =&~ 
  \bigvee_{i \in \left\{1,\ldots,n\right\}} 
  \left(\tracetoalgebra{tr_i} \land 
  \lnot \bigvee_{j ~\in~ \generators - \listset{tr_i}} \var{f_j}\right)\label{eq:mapping-algebra-set}
\end{align}
\end{subequations}
%
where $\append{}{}$ concatenates two traces.
The following examples show how it works for generators $f_1$, $f_2$, $f_3$:
%
\begin{subequations}
\begin{align}
\tracetoalgebra{\trace{f_1}} = & \var{f_1} \land \lnot \left(\var{f_2} \lor \var{f_3}\right)\\
%
\tracetoalgebra{\trace{f_1,f_2}} = & \xbefore{\var{f_1}}{\var{f_2}} \land \lnot \var{f_3}\\
%
\tracetoalgebra{\trace{f_3,f_2,f_1}} = & \xbefore{\var{f_3}}{\left(\xbefore{\var{f_2}}{\var{f_1}}\right)}\\
%
\tracetoalgebra{\left\{\trace{f_1},\trace{f_1,f_2}\right\}} = & 
  \left(\var{f_1} \land \lnot \var{f_2} \land \lnot \var{f_3}\right) \lor \nonumber\\
  & \left(\left(\xbefore{\var{f_1}}{\var{f_2}}\right) \land \lnot \var{f_3}\right)
\end{align}
\end{subequations}

