\chapter{Modelling faults}
\label{sec:fault-modelling}

\begin{quotation}[Título]{Autor}
Texto \\
Text
\end{quotation}

In this section we show how to model faults using functions in a component-level failure logic.
%
We define two relations to establish our axioms: (i) failure value and failure state, (ii) order of occurrence.
%
Using these definitions we are able to create a library of basic components that can be used as building blocks to create new components or to compose a system model.

\section{Modelling a system}
\label{sec:modelling-a-system}

A system model is a block diagram (nodes) with directed connected edges. 
%
An edge's origin is the output of some component and the destination is one or more inputs of other component.
%
Two output ports cannot be directly connected, nor does two inputs.
%
It is required an output and at least one input to connect two components.

Edges and nodes contain fault-related information.
%
An edge contains the current value of the output of the originating node.
%
It is a Boolean indicating a nominal or an erroneous value. 
%
In the last case, the edge also contains the error mode.
%
A node contains: (i) state information, indicating whether the component is in failure, and (ii) a logic for each output that expresses how the output reacts to internal failures and failures on the inputs. 
%
Item (ii) is very similar to the cause of output deviation in \HIPHOPS[TODO: citar def. HH].
%
It also includes the order of occurrence of the failures.

Differently from \HIPHOPS, an output expression also contains the nominal case to cover all possibilities on the components, to avoid missing a case.

\begin{definition}[Values]
The set of possible values in inputs and outputs is defined as: 
\[\Values=N.\Real \union \FMode\]
%
where $N$ means a nominal value and $\FMode$ specifies a failure mode, such as omission, commission etc. and denotes all possible failure modes for any component.
\end{definition}

\begin{definition}[Component]
\begin{sloppypar}
$C_m = \left(I_m, O_m \right)$
%
\\where $I_m = \left(\cin{m}{1},\ldots,\cin{m}{n_{in}}\right)$ are inputs of type $\Values$, $O_m = \left( \cout{m}{1},\ldots,\cout{m}{n_{out}} \right)$ are output functions of type $\ValueFunction$, $\ValueFunction : (\Values \cross \ldots \cross \Values) \cross FMode \rightarrow \Values $, $m$ is the index of the component in a model, and $n_{in}$ and $n_{out}$ are the number of inputs and outputs.
\end{sloppypar}
\end{definition}

\begin{definition}[System model]
$S = \left(Cs, A\right)$
\noindent where $Cs$ is a set of components and $A : \PortIndex \cross \PortIndex$ relates a component output to another component's input, $\PortIndex$ is a pair of indexes where the first element is a component's index and the second is the input or output index within the component, and
\[\forall m, j \bullet \lnot \exists k \bullet A\left(\left(m, o_m\right), \left(k, i_k\right)\right) \land A\left(\left(j, o_j\right), \left(k, i_k\right)\right)\]
\end{definition}

\begin{definition}[Model inputs and outputs]
Model inputs and outputs are all components' inputs and outputs that are not in $A$.
\[
\MIn = \bigcup_m \bullet \left(m,k\right) | \forall m,j,k \bullet \lnot A\left( \left(j, o_j\right), \left(m, k\right) \right)
\]
and
\[
\MOut = \bigcup_m \bullet \left(m,k\right) | \forall m,j,k \bullet \lnot A\left( \left(m, k\right), \left(j, i_j\right) \right)
\]
%
where $C_m = \left(I_m, O_m\right)$, $I_m = \left(i_{m,1},\ldots,i_{m,n_{in}}\right)$ and $O_m = \left(o_{m,1},\ldots,o_{m,n_{out}}\right)$
\end{definition}

\begin{lemma}[Inputs and Outputs completeness]
In a model, every input and output is either in $A$, or in $\MIn \cup \MOut$:
\[\forall m,i \bullet \left(m,i\right) \in \MIn \lor \left(m,i\right) \in \ran A \]
\[\forall m,o \bullet \left(m,o\right) \in \MOut \lor \left(m,o\right) \in \dom A \]
\end{lemma}
\begin{proof}
\TODO{sorry}
\end{proof}

\TODO{Acrescentar teorema sobre como as funções de saída geram as equações para as árvores.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Failure value and failure state%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Failure value and failure state}

%A function $F_i : Input \rightarrow Boolean$ expresses whether the current value on an input is a failure value. 
%
%Similarly, a function $F_c : Component \rightarrow Boolean$ expresses whether the current state of a component is a failure state.
%
%The type of a failure value is defined by a unbounded value.

To illustrate these definitions, suppose a component $C$ that contains only one output, and its failure logic depends only on its internal state: if it is faulty, it produces an omission value $O_M$, otherwise it produces a nominal value $N$. 
%
The failure logic for its output $O$ is: $O = F \land O_M \lor \lnot F \land N$.

TODO: all Boolean operators relate to $FailureMode$ as: if the Boolean value is $true$, then it results in the $FailureMode$ value, otherwise it results in $false$. It creates an invariant that all output functions are tautologies.

\subsection{Order of occurrence}

The order of occurrence of events is defined as a sequence value as it is in \HIPHOPS: it is a natural value assigned to each input.
%
The value does not contain gaps, so always there is a pair of input that the modulus of the difference of their sequence values is 1, or the modulus of the difference is 0 for all pairs of inputs.
%
For example, if we have two variables, they can be assigned values 0 and 1 or 1 and 2, but not 0 and 2. 

We define a relation $S : Input \rightarrow \Nat $ as the sequence value for the given input.

