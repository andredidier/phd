\chapter{Modelling faults}
\label{sec:fault-modelling}

\begin{quotation}[Título]{Autor}
Texto \\
Text
\end{quotation}

In this section we show how to model faults using functions in a component-level failure logic.
%
We define two relations to establish our axioms: (i) failure value and failure state, (ii) order of occurrence.
%
Using these definitions we are able to create a library of basic components that can be used as building blocks to create new components or to compose a system model.

\section{Modelling a system}
\label{sec:modelling-a-system}

A system model is a block diagram (nodes) with directed connected edges. 
%
An edge's origin is the output of some component and the destination is one or more inputs of other component.
%
Two output ports cannot be directly connected, nor does two inputs.
%
It is required an output and at least one input to connect two components.

Edges and nodes contain fault-related information.
%
An edge contains the current value of the output of the originating node.
%
It is a Boolean indicating a nominal or an erroneous value. 
%
In the last case, the edge also contains the error mode.
%
A node contains: (i) state information, indicating whether the component is in failure, and (ii) a logic for each output that expresses how the output reacts to internal failures and failures on the inputs. 
%
Item (ii) is very similar to the cause of output deviation in \HIPHOPS[TODO: citar def. HH].
%
It also includes the order of occurrence of the failures.

Differently from \HIPHOPS, an output expression also contains the nominal case to cover all possibilities on the components, to avoid missing a case.

\begin{definition}[Values]
The set of possible values in inputs and outputs is defined as: 
\[\Values=\Nominal{\Real} \union \FMode\]
%
where $N$ means a nominal value and $\FMode$ specifies a failure mode, such as omission, commission etc. and denotes all possible failure modes for any component.
\end{definition}

\begin{definition}[Component]
\begin{sloppypar}
$C_m = \left(I_m, O_m \right)$
%
\\where $I_m = \left\{\cin{m}{1},\ldots,\cin{m}{n_{in}}\right\}$ are inputs of type $\Values$, $O_m = \left\{ \cout{m}{1},\ldots,\cout{m}{n_{out}} \right\}$ are output functions of type $\ValueFunction$, $\ValueFunction : (\Values \cross \ldots \cross \Values) \cross FMode \rightarrow \Values $, $m$ is the index of the component in a model, and $n_{in}$ and $n_{out}$ are the number of inputs and outputs.
\end{sloppypar}
\end{definition}

\begin{definition}[System model]
$S = \left(Cs, A\right)$
\noindent where $Cs$ is a set of components and $A : \PortIndex \cross \PortIndex$ relates a component output to another component's input, $\PortIndex$ is a pair of indexes where the first element is a component's index and the second is the input or output index within the component, and
\[\forall m, j \bullet \lnot \exists k \bullet A\left(\left(m, o_m\right), \left(k, i_k\right)\right) \land A\left(\left(j, o_j\right), \left(k, i_k\right)\right)\]
\end{definition}

\begin{definition}[Model inputs and outputs]
\label{def:model-in-out}
Model inputs and outputs are all components' inputs and outputs that are not in $A$.
\[
\MIn = \bigcup_m \bullet \left(m,k\right) | \forall m,j,k \bullet \lnot A\left( \left(j, o_j\right), \left(m, k\right) \right)
\]
and
\[
\MOut = \bigcup_m \bullet \left(m,k\right) | \forall m,j,k \bullet \lnot A\left( \left(m, k\right), \left(j, i_j\right) \right)
\]
%
where $C_m = \left(I_m, O_m\right)$, $I_m = \left(i_{m,1},\ldots,i_{m,n_{in}}\right)$ and $O_m = \left(o_{m,1},\ldots,o_{m,n_{out}}\right)$
\end{definition}

\begin{lemma}[Inputs and Outputs completeness]
In a model, every input and output is either in $A$, or in $\MIn \cup \MOut$:
\[\forall m,i \bullet \left(m,i\right) \in \MIn \lor \left(m,i\right) \in \ran A \]
\[\forall m,o \bullet \left(m,o\right) \in \MOut \lor \left(m,o\right) \in \dom A \]
\end{lemma}
\begin{proof}
\TODO{sorry}
\end{proof}

The output functions are defined using a \emph{valued tautology} logic.
%
It adds value information to a Boolean expression and can be generally understood as a guarded-value expression. 
%
The evaluation of the expression of all guards is always \emph{true} (tautology).
%
The most basic example of a valued tautology is a $\top$ expression and its associated value $V : \Values$:
\[\top^V\]
\begin{definition}[Valued tautology]
\label{def:valued-tautology}
A valued tautology is defined as:
\begin{align*}
ValuedTautology & \defs E_0^{V_0} \mathop{op_0} \ldots \mathop{op_m} E_m^{V_m}
\\ E_0 \mathop{op_0} \ldots \mathop{op_m} E_m & = \top
\\ \forall i, j & \bullet E_i \land E_j \implies V_i = V_j
\end{align*}
%
where $op_m$ is a Boolean operator, $E_m$ is a Boolean expression and $V_m$ is a value of type $\Values$.
\end{definition}

\begin{lemma}[Valued tautology \emph{OR}]
Given two Boolean variables $A$ and $B$, their respective values $U$ and $V$, and a third value $Q$, $A^U \lor B^V \lor \left(\lnot A \land \lnot B\right)^Q $ is a valued tautology:
\begin{align*}
A^U \lor B^V \lor \left(\lnot A \land \lnot B\right)^Q \defs & 
\left(A \land \lnot B\right)^U \lor
\left(\lnot A \land B\right)^V \lor 
\\&  \left(A \land B \land \left(U = V\right) \right)^U \lor
\\&  \left(\lnot A \land \lnot B\right)^Q
\end{align*}

\end{lemma}
\begin{proof}
Assume $E = A \lor B$, $\lnot E = \left(\lnot A \land \lnot B\right) $ is also in the expression, thus:
\[ E \lor \lnot E = \top \] 
\TODO{completar}
\end{proof}


\begin{lemma}[Valued tautology \emph{AND}]
Give two Boolean variables $A$ and $B$, their respective values $U$ and $V$ and a third value $Q$, $A^U \land B^V \lor \left(\lnot A \lor \lnot B\right)^Q $ is a valued tautology:
\begin{align*}
\left(A^U \land B^V\right) \lor \left(\lnot A \lor \lnot B\right)^Q \defs & 
\left(A \land \lnot B \right)^Q \lor
\left(\lnot A \land B\right)^Q \lor
\\&\left(A \land B \land U = V\right)^U \lor
\\&\left(\lnot A \land \lnot B\right)^Q
\end{align*}
\end{lemma}
\begin{proof}
Assume $E = A \land B$, $\lnot E = \left(\lnot A \lor \lnot B\right) $ is also in the expression, thus:
\[ E \lor \lnot E = \top \] 
\TODO{completar}
\end{proof}
\TODO{Citação do capítulo ou da seção: to be or not to be.}

\begin{definition}[Value of a valued tautology]
\label{def:vtvalue}
The value of a valued tautology is the i-eth value when the i-eth expression evaluates to \emph{true}.
%
Given a valued tautology $T = E_0^{V_0} \mathop{op_0} \ldots \mathop{op_m} E_m^{V_m}$, the value of $T$ is defined by the function $\VTValue$:
\[
\exists i \bullet E_i \land \VTValue\left(T\right) = V_i  
\]
\end{definition}
If an $E_j (i\neq j)$ also evaluates to \emph{true}, the value is the same, accordingly to~\cref{def:valued-tautology}.

\begin{definition}[Rules for $\VTValue$]
\label{def:vtvalue-rules}
Given a predicate $P\left(.\right)$, and Boolean expressions $E$ and $E_i$, $i \in [1,n]$:

\begin{align}
P\left(\VTValue\left(E_1^{V_1} \lor \ldots \lor E_n^{V_n}\right)\right) =& 
  \left( P\left(V_1\right) \land E_1 \right) \lor \ldots \lor
  \left( P\left(V_n\right) \land E_n \right)
  \\
E^{\VTValue\left(E_1^{V_1} \lor \ldots \lor E_n^{V_n}\right)} =& \left(E \land E_1\right)^{V_1} \lor \ldots \lor \left(E \land E_n\right)^{V_n}
\end{align} 
\end{definition}

\TODO{Acrescentar teorema sobre como as funções de saída geram as equações para as árvores.}

Accordingly to the work reported in~\cite{STR2002}, a fault tree structure function is not only a Boolean expression.
%
It exemplifies with the expression $true \land \lnot closed(barriers)$, where we cannot just replace `$\land$' to an $\mathrm{AND}$-gate, because $true$ is not a basic event, nor $\lnot closed(barriers)$ expresses a fault.
%
The work reported in~\cite{XY2010} defines a formal model of static fault trees considering operands as events. 

\begin{definition}[Fault tree gate]
Given $F_f$, $f \in [0,n_F], n_F \geq 0$, Boolean variables where if $F_f$ evaluates to $true$, then a basic fault event occurs, a fault tree gate $G$ combines all $F_f$ with a Boolean operator $\mathop{op}$:
\[G = F_0 \mathop{op} \ldots \mathop{op} F_{n_F}\]
\end{definition}

If $n_F = 0$ then the gate reduces to the variable $F_0$.

\begin{definition}[Fault tree structure function]
\begin{sloppypar}
Given $F_f$, $f \in [0,n_F]$ Boolean variables, and fault tree gates $G_g$, $g \in [0, n_G]$, a structure function $SF:\left(Boolean \cross \ldots \cross Boolean\right) \rightarrow Boolean $ is also a fault tree gate with operator $op$:
\[
SF\left(F_0, \ldots, F_{n_F}\right) = G_0\left(F_0, \ldots, F_{n_F}\right) \mathop{op} \ldots \mathop{op} G_{n_G}\left(F_0, \ldots, F_{n_F}\right)
\]
%
where if $F_f$ evaluates to $true$, then a basic fault event occurs.
% 
Then $SF$ represents a fault tree.
\end{sloppypar} 
\end{definition}

\begin{theorem}[A predicate over a valued tautology is a structure function of a fault tree]
\label{thr:predicate-fault-tree}
Given $F_f$, $f \in [1,n_F]$ Boolean variables that represent basic fault events, $G_g$, $g \in [0,n_G]$ fault tree gates that contains only $F_f$, and $T = G_0^{V_0} \mathop{op_0} \ldots \mathop{op_{n_G}} G_{n_G}^{V_{n_G}}$ a valued tautology, then a predicate $P$ over $F_f$ is a structure function of $T$.
\end{theorem}
\begin{proof}
\TODO{sorry.}
\end{proof}

\subsection{Example of valued tautology}
%
A single battery $b_x$ is defined as:
\begin{align*}
C_{b_x} = & \left( \emptyset, \left\{\cout{b_x}{1}\right\} \right) \\
\cout{b_x}{1} = & F_{b_x}^{\Omission} \lor \lnot F_{b_x}^{\Nominal{5}}
\end{align*}

A simple monitor $mon$:
\begin{align*}
C_{mon} = &  \left( 
    \left\{\cin{mon}{1}, \cin{mon}{2}\right\}, 
    \left\{\cout{mon}{1}\right\} 
  \right) \\
\cout{mon}{1} = 
  &\left( 
    \lnot F_{mon} \land \VTValue\left(\cin{mon}{1}\right) \geq \Nominal{2}
  \right)^{\VTValue\left(\cin{mon}{1}\right)} \lor \\
  & \left(
    \lnot F_{mon} \land \VTValue\left(\cin{mon}{1}\right) < \Nominal{2}
  \right)^{\VTValue\left(\cin{mon}{2}\right) } \lor \\
  & \left(
    F_{mon} \land \VTValue\left(\cin{mon}{1}\right) \geq \Nominal{2}
  \right)^{\VTValue\left(\cin{mon}{2}\right)} \lor \\
  & \left(
    F_{mon} \land \VTValue\left(\cin{mon}{1}\right) < \Nominal{2}
  \right)^{\VTValue\left(\cin{mon}{1}\right)}
\end{align*}

Combining both components into a system $S_{mon}$ results in the following system model:
\begin{align*}
S_{mon} = & \left(\left\{ C_{b_1}, C_{b_2}, C_{mon} \right\}, A_{mon} \right) \\
& A_{mon}\left(\left(b_1, 1\right), \left(mon, 1\right) \right) \\
& A_{mon}\left(\left(b_2, 1\right), \left(mon, 2\right) \right) \\
\end{align*}

And, accordingly to \cref{def:model-in-out}:
\begin{align*}
\MIn = & \emptyset \\
\MOut = & \left\{ \left(mon, 1\right) \right\}
\end{align*}

The system model output is the result of expanding $\cout{mon}{1}$ with the output functions of the connected single batteries $\cout{b_1}{1}$ and $\cout{b_2}{1}$:
\begin{align*}
\cout{mon}{1} = 
  &\left( 
    \lnot F_{mon} \land \VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}} \right) \geq \Nominal{2}
  \right)^{\VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}} \right)} \lor \\
  & \left(
    \lnot F_{mon} \land \VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}}\right) < \Nominal{2}
  \right)^{\VTValue\left( F_{b_2}^{\Omission} \lor 
    \lnot F_{b_2}^{\Nominal{5}} \right) } \lor \\
  & \left(
    F_{mon} \land \VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}}\right) \geq \Nominal{2}
  \right)^{\VTValue\left(F_{b_2}^{\Omission} \lor 
    \lnot F_{b_2}^{\Nominal{5}} \right)} \lor \\
  & \left(
    F_{mon} \land \VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}}\right) < \Nominal{2}
  \right)^{\VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}}\right)}\\
\cout{mon}{1} =
  &\left( 
    \lnot F_{mon} \land \lnot F_{b_1}  
  \right)^{\VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}} \right)} \lor \text{by \cref{def:vtvalue,def:vtvalue-rules}}\\
  & \left(
    \lnot F_{mon} \land F_{b_1}
  \right)^{\VTValue\left( F_{b_2}^{\Omission} \lor 
    \lnot F_{b_2}^{\Nominal{5}} \right) } \lor 
  \left(
    F_{mon} \land \lnot F_{b_1}
  \right)^{\VTValue\left(F_{b_2}^{\Omission} \lor 
    \lnot F_{b_2}^{\Nominal{5}} \right)} \lor \\
  & \left(
    F_{mon} \land F_{b_1}
  \right)^{\VTValue\left( F_{b_1}^{\Omission} \lor 
    \lnot F_{b_1}^{\Nominal{5}}\right)}\\
\cout{mon}{1} =
  &\left( 
    \lnot F_{mon} \land \lnot F_{b_1}  
  \right)^{\Nominal{5}} \lor \text{by \cref{def:vtvalue-rules}}\\
  & \left(
    \left(\lnot F_{mon} \land F_{b_1}\right) \land F_{b_2} 
  \right)^{\Omission } \lor  
  \left(
    \left(\lnot F_{mon} \land F_{b_1}\right) \land \lnot F_{b_2}
  \right)^{\Nominal{5}} \lor \\ 
  & \left(
    \left(F_{mon} \land \lnot F_{b_1}\right) \land F_{b_2}
  \right)^{\Omission} \lor
  \left(
    \left(F_{mon} \land \lnot F_{b_1} \right) \land \lnot F_{b_2}
  \right)^{\Nominal{5}} \lor \\
  & \left(
    F_{mon} \land F_{b_1}
  \right)^{\Omission}
\end{align*}

Finally, we obtain the system fault tree from a predicate (see \cref{thr:predicate-fault-tree}):
\begin{align*}
\VTValue\left(\cout{mon}{1}\right) = \Omission \defs &
  \VTValue\left(\right.
    \left( 
      \lnot F_{mon} \land \lnot F_{b_1}  
    \right)^{\Nominal{5}} \lor \\
    & \left(
      \left(\lnot F_{mon} \land F_{b_1}\right) \land F_{b_2} 
    \right)^{\Omission } \lor  \\
    & \left(
      \left(\lnot F_{mon} \land F_{b_1}\right) \land \lnot F_{b_2}
    \right)^{\Nominal{5}} \lor \\ 
    & \left(
      \left(F_{mon} \land \lnot F_{b_1}\right) \land F_{b_2}
    \right)^{\Omission} \lor \\
    & \left(
      \left(F_{mon} \land \lnot F_{b_1} \right) \land \lnot F_{b_2}
    \right)^{\Nominal{5}} \lor \\
    & \left(
      F_{mon} \land F_{b_1}
    \right)^{\Omission}
  \left.\right) = \Omission\\
\VTValue\left(\cout{mon}{1}\right) = \Omission \defs &
  \VTValue\left(\right.
    \left(
      \left(\lnot F_{mon} \land F_{b_1}\right) \land F_{b_2} 
    \right)^{\Omission } \lor \\  
    & \left(
      \left(F_{mon} \land \lnot F_{b_1}\right) \land F_{b_2}
    \right)^{\Omission} \lor \\
    & \left(
      F_{mon} \land F_{b_1}
    \right)^{\Omission}
  \left.\right) = \Omission \\
\VTValue\left(\cout{mon}{1}\right) = \Omission \defs & 
  \left(
    \lnot F_{mon} \land F_{b_1} \land F_{b_2} 
  \right) \lor \\  
  & \left(
    F_{mon} \land \lnot F_{b_1}\land F_{b_2}
  \right) \lor \\
  & \left(
    F_{mon} \land F_{b_1}
  \right) \\
\VTValue\left(\cout{mon}{1}\right) = \Omission \defs & 
  \left(F_{b_1} \land F_{b_2}\right) \lor
  \left(F_{mon} \land \left(F_{b_1} \lor F_{b_2}\right) \right)
\end{align*}

%\subsection{Imported from Isabelle/HOL - example}

%\Snippet{temp1}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Failure value and failure state%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Failure value and failure state}

%A function $F_i : Input \rightarrow Boolean$ expresses whether the current value on an input is a failure value. 
%
%Similarly, a function $F_c : Component \rightarrow Boolean$ expresses whether the current state of a component is a failure state.
%
%The type of a failure value is defined by a unbounded value.

To illustrate these definitions, suppose a component $C$ that contains only one output, and its failure logic depends only on its internal state: if it is faulty, it produces an omission value $O_M$, otherwise it produces a nominal value $N$. 
%
The failure logic for its output $O$ is: $O = F \land O_M \lor \lnot F \land N$.

TODO: all Boolean operators relate to $FailureMode$ as: if the Boolean value is $true$, then it results in the $FailureMode$ value, otherwise it results in $false$. It creates an invariant that all output functions are tautologies.

\subsection{Order of occurrence}

The order of occurrence of events is defined as a sequence value as it is in \HIPHOPS: it is a natural value assigned to each input.
%
The value does not contain gaps, so always there is a pair of input that the modulus of the difference of their sequence values is 1, or the modulus of the difference is 0 for all pairs of inputs.
%
For example, if we have two variables, they can be assigned values 0 and 1 or 1 and 2, but not 0 and 2. 

We define a relation $S : Input \rightarrow \Nat $ as the sequence value for the given input.

