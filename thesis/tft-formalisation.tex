\section{Formalisation of Temporal Fault Trees}
\label{sec:tft-formalisation}

In this section, I propose a formalisation in \CSP of \TFT to enable a comparison of \TFTs and the calculation of the probability of occurrence of top events.

The formalisation occurs in three steps: (i) formalising sequence values calculations to achieve \TTTs for a given temporal expression (\cref{sec:sv-calculus}), (ii) converting these \TTTs to sequences of events (\cref{sec:ttt-to-seqs}), and (iii) building a process to call these events to verify refinements (\cref{sec:seqs-to-process}).

\subsection{Sequence Value Calculus}
\label{sec:sv-calculus}

Given two sequence values as inputs, each temporal gate expression is encoded as a \CSP function as following:
\begin{align}
OR(a,b) & = 
  \begin{cases}
  min(a,b) & \text{if } a > 0 \land b > 0\\
  max(a,b) & \text{otherwise}
  \end{cases}\\
AND(a,b) & =
  \begin{cases}
  max(a,b) & \text{if } a > 0 \land b > 0\\
  0 & \text{otherwise}
  \end{cases}\\ 
POR(a,b) & =
  \begin{cases}
  a & \text{if } a > 0 \land (b = 0 \lor a < b)\\
  0 & \text{otherwise}
  \end{cases}\\ 
PAND(a,b) & =
  \begin{cases}
  b & \text{if } a > 0 \land a < b\\
  0 & \text{otherwise}
  \end{cases}\\ 
SAND(a,b) & =
  \begin{cases}
  a & \text{if } a = b\\
  0 & \text{otherwise}
  \end{cases}
\end{align}

Combining these functions, any temporal expression can be written. For example, given the expression $\PAND{\OR{A}{B}}{C}$, it can be written as: $PAND(OR(A,B),C)$. \Cref{tab:example-expression-ttt} shows the truth table for this example formula, by applying the function definitions for each row.

\begin{table}
\caption{\TTT for the expression $\PAND{\OR{A}{B}}{C}$}
\label{tab:example-expression-ttt}
\center
{\scriptsize
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{A} & \textbf{B} & \textbf{C} & $\OR{A}{B}$ & $\PAND{\OR{A}{B}}{C}$ \\
\hline
\hline
0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
0 & 1 & 0 & 1 & 0\\
0 & 1 & 1 & 1 & 0\\
0 & 1 & 2 & 1 & 2\\
0 & 2 & 1 & 2 & 0\\
1 & 0 & 0 & 1 & 0\\
1 & 0 & 1 & 1 & 0\\
1 & 0 & 2 & 1 & 2\\
1 & 1 & 0 & 1 & 0\\
1 & 1 & 1 & 1 & 0\\
1 & 1 & 2 & 1 & 2\\
1 & 2 & 0 & 1 & 0\\
1 & 2 & 1 & 1 & 0\\
1 & 2 & 2 & 1 & 2\\
1 & 2 & 3 & 1 & 3\\
1 & 3 & 2 & 1 & 2\\
2 & 0 & 1 & 2 & 0\\
2 & 1 & 0 & 1 & 0\\
2 & 1 & 1 & 1 & 0\\
2 & 1 & 2 & 1 & 2\\
2 & 1 & 3 & 1 & 3\\
2 & 2 & 1 & 2 & 0\\
2 & 3 & 1 & 2 & 0\\
3 & 1 & 2 & 1 & 2\\
3 & 2 & 1 & 2 & 0\\
\hline
\end{tabular}
}
\end{table} 

\subsection{From \TTTs to sequences of events}
\label{sec:ttt-to-seqs}

Obtaining (a set of) sequences of events is an intermediate step to get a process that represents a \TFT. This step is an optimisation to remove non-determinism, trimming the paths that lead to the top-level event. It combines paths that have the same initial event, building an hierarchical structure of choices.

The function $TTT$ below creates a set o tuples of size $n+1$, where $n$ is the number of basic events on the expression and the value on position $n+1$ is the result of the application of the temporal expression:
\begin{align}
TTT & :: TExp \Longrightarrow \powerset\left(\SVtuple[n+1]\right)\nonumber\\
TTT(expression) & = \left\{ (a_1, \ldots, a_n, expression(a_1, \ldots, a_n)) \vphantom{\clause}\nonumber\right.\\
& \qquad\left.\clause (a_1, \ldots, a_n) \in TTT_{inputs}(n)) \right\}
\end{align}
\noindent where $1,\ldots,n$ are the indexes of basic events, $\SV = \left\{0,\ldots,n\right\}$ are sequence values and $TTT_{inputs}$ defines a set of tuples of size $n$ that represents the events (inputs) for each row in a \TTT:
\begin{align}
TTT_{inputs} & :: I \Longrightarrow \powerset\left(\SVtuple\right)\\
TTT_{inputs}(n) & = \left\{ (a_1, \ldots, a_n) \vphantom{\clause}\right.\nonumber\\
 & \qquad\left. \clause max(a_1,\ldots,a_n) = card\left(\left\{a_1, \ldots, a_n\right\} \setminus \left\{0\right\}\right) \right\} \label{eq:ttt-inputs}
\end{align}

\noindent where $I = \left\{1,\ldots,n\right\}$. Note that the clause $max(a_1,\ldots,a_n) = card\left(\left\{a_1, \ldots, a_n\right\} \setminus \left\{0\right\}\right)$ guarantees that there are no gaps between two $a_i$'s, satisfying the \TFT property for sequence values.

For the example expression $\PAND{\OR{A}{B}}{C}$, the functions $TTT$ and $TTT_{inputs}$ return a set with cardinality $26$.

Finally, we create a data structure to avoid non-determinism and optimise the final process creation. This data structure is created in two steps: 
\begin{enumerate}
  \item Each tuple is converted into a set of pairs recursively where the first element is an available event and the second element is a set of options of events to choose. This set of options may contain others pairs recursively.
  \begin{align}
  SoP\left(sync_{ev}, \left(a_1,\ldots,a_n\right)\right) &= 
  \end{align}
  \noindent where $sync_{ev}$ is an event that indicates that the following events occur with the same sequence value.
  \item These pairs are then merged with respect to the first element. If there two pairs with the same first element, they are merged, making a union of the second element sets. 
\end{enumerate}


\subsection{Checking process refinements}
\label{sec:seqs-to-process}

Using the tuples defined by \cref{eq:ttt-inputs}, we now define a process that represents the execution of a temporal expression.